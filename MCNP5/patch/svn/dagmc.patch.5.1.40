
Property changes on: dotcomm/src
___________________________________________________________________
Added: svn:ignore
   + *.mod


Index: config/Linux.gcf
===================================================================
--- config/Linux.gcf	(.../vendor/5.1.40/Source)	(revision 218)
+++ config/Linux.gcf	(.../5.1.40/trunk/Source)	(revision 218)
@@ -136,6 +136,9 @@
 ifeq (pathscale,$(filter pathscale,$(CONFIG)))
   FCOMPILER ?= PATHSCALE
 endif
+ifeq (gfortran,$(filter gfortran,$(CONFIG)))
+  FCOMPILER ?= GFORTRAN
+endif
 ifeq (absoft,$(filter absoft,$(CONFIG)))
   FCOMPILER ?= ABSOFT
 endif
@@ -389,6 +392,50 @@
   endif
 endif
 
+ifeq (GFORTRAN,$(filter GFORTRAN,$(FCOMPILER)))
+  ifeq (debug,$(filter debug,$(CONFIG)))
+    FDEBUG ?= -g
+    FOPT   ?= -O0
+  else
+    FDEBUG ?=
+    FOPT   ?= -O0
+  endif
+
+  ifeq (,$(premake))
+    FC = gfortran
+  endif
+
+  ifeq (M32,$(MARCH))
+    FCPU ?= -m32
+  endif
+  ifeq (M64,$(MARCH))
+    FCPU ?= -m64
+  endif
+  FCPU ?=
+
+  FC_FLAGS ?= -mieee-fp -fdollar-ok
+  DEF_FCOMPILER= -DABSOFT
+  FIXEDFORM= -ffixed-form
+  FREEFORM = -ffree-form
+  FC_I4 =
+  FC_I8 = -fdefault-integer-8
+  FC_R4 =
+  FC_R8 = -fdefault-real-8
+  F2C_FLAG =
+  MOD_INC  = -I
+  DOTCOMM_FFLAGS=
+
+  FC_LDFLAGS=
+
+  # --- OpenMP threads option.
+  ifeq (omp,$(filter omp,$(CONFIG)))
+    SMMP     = -fopenmp
+    DEF_SMMP = -DMULTT
+  endif
+endif
+
+
+
 # --- Pathscale compiler
 ifeq (PATHSCALE,$(filter PATHSCALE,$(FCOMPILER)))
 
@@ -502,8 +549,21 @@
 endif
 CC = gcc
 
+ifeq (M32,$(MARCH))
+  CCPU ?= -m32
+endif
+ifeq (M64,$(MARCH))
+  ifeq (ia64,$(filter ia64,$(ARCH)))
+    CCPU ?=
+  else
+    CCPU ?= -m64
+  endif
+endif
+CCPU ?=
+
 COPT ?=
-CFLAGS   = $(CDEBUG) $(COPT) 
+CFLAGS   = $(CCPU) $(CDEBUG) $(COPT) 
+CXXFLAGS = $(CFLAGS)
 CPPFLAGS = $(DEFS)
 OBJC     = .o
 OBJF     = .o
@@ -535,6 +595,32 @@
 endif
 # ---END PLOT OPTIONS-------------------
 
+# --- DAGMC option.
+DAGMC_MOD=
+
+ifeq (dagmc,$(filter dagmc,$(CONFIG)))
+
+  ifeq (,$(premake)) 
+    include $(MOAB_DIR)/lib/moab.make   
+    CUBIT_LINK_PATH=$(CUBIT_DIR)
+  else
+    include $(menudagpath)/lib/moab.make
+    CUBIT_LINK_PATH=$(menucubitpath)
+  endif
+
+  CPP_FLAGS += $(MOAB_CPPFLAGS)
+  CXXFLAGS += $(MOAB_CXXFLAGS) $(DAGMC_CFLAGS)
+  INCLUDES += $(MOAB_INCLUDES)
+  LDFLAGS = $(MOAB_LDFLAGS) $(CXX_FORTRAN_LDFLAGS) \
+       -Wl,-rpath=$(CUBIT_LINK_PATH)
+
+  DAGMC_LIBS += $(MOAB_LIBS_LINK) -ldagmc -lstdc++
+
+  DAGMC_MOD=  dagmc_mod$(OBJF)
+
+endif
+# ---END DAGMC OPTIONS-------------------
+
 # --- Include and Module search directories.
 INCLUDE_DIRS = 
 
Index: config/Makefile
===================================================================
--- config/Makefile	(.../vendor/5.1.40/Source)	(revision 218)
+++ config/Makefile	(.../5.1.40/trunk/Source)	(revision 218)
@@ -27,6 +27,12 @@
 	@ $(ECHO) 'menugincl='$(menugincl) >> "$(custfile)"
 	@ $(ECHO) '# --- Datapath ---' >> "$(custfile)"
 	@ $(ECHO) 'DATAPATH='$(DATAPATH) >> "$(custfile)"
+	@ $(ECHO) '# --- DAGMC Option ---' >> "$(custfile)"
+	@ $(ECHO) 'menudagmc='$(menudagmc) >> "$(custfile)"
+	@ $(ECHO) '# --- DAGMC library path ---' >> "$(custfile)"
+	@ $(ECHO) 'menudagpath='$(menudagpath) >> "$(custfile)"
+	@ $(ECHO) '# --- Cubit binary path ---' >> "$(custfile)"
+	@ $(ECHO) 'menucubitpath='$(menucubitpath) >> "$(custfile)"
 	@ $(ECHO) '# --- Number of PVM processors ---' >> "$(custfile)"
 	@ $(ECHO) 'NPVM='$(NPVM) >> "$(custfile)"
 	@ $(ECHO) '# --- Number of threads ---' >> "$(custfile)"
Index: install
===================================================================
--- install	(.../vendor/5.1.40/Source)	(revision 218)
+++ install	(.../5.1.40/trunk/Source)	(revision 218)
@@ -239,6 +239,96 @@
   esac 
   done
 }
+#----------                                                                                                                       
+# DAGMC                                                                                                                           
+#----------                                                                                                                       
+# This sets the DAGMC library location and toggles use of DAGMC                                                                   
+DagMC () {
+# Loop until told to exit.                                                                                                        
+ while [ "$EXIT" = '0' ]; do
+  Clear
+  echo '**************************** DAGMC OPTIONS *************************'
+  echo ' '
+  echo 'Configurable Numbered Items                   Current Value'
+  echo '-----------------------------------------------------------'
+  echo '1. Enable DAGMC (toggle)                      '$menudagmc
+
+  if [ "$menudagmc" = 'on' ]
+  then {
+  echo ' '
+  echo '2. DAGMC Library Path (entry)                 '$menudagpath
+  echo ' '
+
+  if [ ! -d "$menudagpath" ]
+  then {
+    echo "Warning:  DAGMC Library Path $menudagpath is not set or is not valid."
+  }
+  else
+    echo "Confirmed:  DAGMC Library Path $menudagpath is valid."
+  fi
+
+  echo ' '
+  echo '3. Cubit Binary Path (entry)                 '$menucubitpath
+  echo ' '
+
+  if [ ! -d "$menucubitpath" ]
+  then {
+    echo "Warning:  Cubit Binary Path $menucubitpath is not set or is not valid."
+    echo "          (It might not be needed.)"
+  }
+  else
+    echo "Confirmed:  Cubit Binary Path $menucubitpath is valid."
+  fi
+
+  }
+  fi
+
+
+  echo ' '
+  echo 'Permitted Letter Actions'
+  echo '------------------------'
+  echo 'X. Exit DAGMC Options'
+  echo ' '
+  echo ' '
+  echo '***************** Type your choice and hit <Enter> ********************'
+  echo '***********************************************************************'
+  read menuselect
+  case $menuselect in
+     1 | 1*)
+       if [ "$menudagmc" = 'on' ]
+       then {
+         menudagmc=off
+       }
+       else
+         menudagmc=on
+       fi
+     ;;
+
+     2 | 2*)
+       echo ' '
+       echo ' Enter the DAGMC Library Path:'
+       read menudagpath
+       menudagpath32=$menudagpath
+       menudagpath64=$menudagpath
+     ;;
+
+     3 | 3*)
+       echo ' '
+       echo ' Enter the Cubit Binary Path:'
+       read menucubitpath
+       menucubitpath32=$menucubitpath
+       menucubitpath64=$menucubitpath
+     ;;
+
+     X | x | X* | x*)
+       EXIT='1'
+     ;;
+
+     *)
+     ;;
+  esac
+  done
+} 
 #----------------------
 # FindPortlandCompiler
 #----------------------
@@ -868,6 +958,7 @@
 menudebug='no'
 menucomp='no'
 menudata='no'
+menudagmc='off'
 
 # Set DATAPATH if it is NOT already set as environment variable.
 # If already set, leave that value alone.
@@ -1481,6 +1572,11 @@
     echo "menudebug=$menudebug" >> $ansfile
     echo "menudata=$menudata"   >> $ansfile
 
+    echo "menudagmc=$menudagmc" >> $ansfile
+    echo "menudagpath=$menudagpath" >> $ansfile
+    echo "menucubitpath=$menucubitpath" >> $ansfile
+
+
 }
 #--------------------------
 # ExportVariables Function 
@@ -1563,6 +1659,22 @@
     export menudata
     export TESTDATA
 
+    menudagmc=$menudagmc
+    export menudagmc
+
+    menudagpath=$menudagpath
+    export menudagpath
+
+    menucubitpath=$menucubitpath
+    export menucubitpath
+    if [ "$LD_LIBRARY_PATH" == '' ] 
+    then
+       LD_LIBRARY_PATH=$menucubitpath
+    else
+       LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$menucubitpath
+    fi
+    export LD_LIBRARY_PATH
+
     FC=$menuf90path
     export FC
 
@@ -1610,6 +1722,13 @@
        export menub
     fi
 
+    if [ "$menudagmc" = 'on' ]
+    then {
+       menudag=dagmc
+       export menudag
+    }
+    fi
+
     if [ "$menudebug" = 'yes' ]
     then {
        debug='debug'
@@ -1762,6 +1881,17 @@
 
     echo ' '
     echo '7. Test Type 2 Cross Section Data? (toggle)      '$menudata
+   if [ "$menudagmc" = 'on' ]
+   then {
+     echo ' '
+     echo '8. DAGMC (menu driven)                           on'
+     echo '   DAGMC Library Path                            '$menudagpath
+     echo '   Cubit Binary Path                             '$menucubitpath
+   }
+   else
+     echo ' '
+     echo '8. DAGMC (menu driven)                           off'
+    fi
     echo ' '
     echo 'Permitted Letter Actions '
     echo '------------------------'
@@ -1846,6 +1976,10 @@
        fi
      ;;
 
+     8 | 8*)
+       DagMC
+       EXIT='0'
+     ;;
 
      Z | z | Z* | z*)
        CreateAnsfile
Index: src/namchg.F90
===================================================================
--- src/namchg.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/namchg.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -6,15 +6,19 @@
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
-  if( mm==2 ) then
+  ! DAGMC: Need to change some of these conditionals, no bounding
+  !        surfaces exist in CAD mode, handle as regular surface
+
+  if( ( mm==2 ) .or. ( ( mm == 3) .and. ( isdgmc == 1 ) ) ) then
     !  >>>>>  mm=2 -- surface
     do namchg=1,mxj
       if( nsf(namchg)==abs(ji) )  return
     end do
-  elseif( mm==3 ) then
+  elseif( ( mm==3 ) .and. ( isdgmc == 0 ) ) then
     !  >>>>>  mm=3 -- bounding surface
     do kk=1,nlja
       namchg = abs(lja(kk))
Index: src/angl.F90
===================================================================
--- src/angl.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/angl.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -9,11 +9,19 @@
   ! Modules used:
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   integer :: ij = 0 ! local jsu error counter
   integer :: is = 0 ! local surface error counter
 
+  ! DAGMC: In CAD mode, circumvent entire function and call DAGMC version instead
+  if (isdgmc == 1) then
+     call dagmcangl(jsu,xxx,yyy,zzz,ang)
+     angl=max(-one,min(one,ang(1)*uuu+ang(2)*vvv+ang(3)*www))
+     return
+  endif
+
   ! initialize angl so that angl doesn't get underflow or overflow
   angl=one
 
Index: src/pass1.F90
===================================================================
--- src/pass1.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/pass1.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -11,9 +11,13 @@
   use mcnp_debug
   use mcnp_input
   use dynamic_arrays
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
+  ! DAGMC: For CAD mode, read cell/surface cards from log file
+  if ( isdgmc == 1) call lcadrd
+
   ! Process 3 data blocks, which are separated by blank lines.
   rewind iu1
   DO_50: do ib=1,3
Index: src/mcnp_iofiles.F90
===================================================================
--- src/mcnp_iofiles.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/mcnp_iofiles.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -34,8 +34,13 @@
     &  wwinp   = '        ', &  != weight windows input name.
     &  meshtal = '        ', &  != meshtally output file
     &  dumn1   = '        ', &
-    &  dumn2   = '        '
+    &  dumn2   = '        ', &
+    &  gcad    = '        ', &  != DAGMC geometry input file (CAD or facets)
+    &  lcad    = '        ', &  != DAGMC input log file
+    &  fcad    = '        ', &  != DAGMC facets output file
+    &  ftol    = '        '     != DAGMC faceting tolerance
 
+
   ! isub:  names of files.
   character(len=8) ::  isub(ndef) = & != Runtime file names.
     & (/ ('        ',j=1,ndef) /)
@@ -45,7 +50,9 @@
     & (/ 'inp     ', 'outp    ', 'runtpe  ', 'mctal   ', 'wssa    ', &
     &    'ptrac   ', 'comout  ', 'srctp   ', 'wwout   ', 'wwone   ', &
     &    'plotm   ', 'rssa    ', 'xsdir   ', 'com     ', 'wwinp   ', &
-    &    'meshtal ', 'dumn1   ', 'dumn2   ', ('        ',j=1,14) /)
+    &    'meshtal ', 'dumn1   ', 'dumn2   ', &
+    &    'gcad    ', 'lcad    ', 'fcad    ', 'ftol    ', &
+    &   ('        ',j=1,10) /)
 
   ! General character variables:
   character(len=80) :: hdpath, hdpth
@@ -80,6 +87,10 @@
     meshtal = isub(16)
     dumn1   = isub(17)
     dumn2   = isub(18)
+    gcad    = isub(19)
+    lcad    = isub(20)
+    fcad    = isub(21)
+    ftol    = isub(22)
     return
   end subroutine set_filenames
 
Index: src/dagmc_mod.F90
===================================================================
--- src/dagmc_mod.F90	(.../vendor/5.1.40/Source)	(revision 0)
+++ src/dagmc_mod.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -0,0 +1,253 @@
+module dagmc_mod
+
+  use mcnp_params
+
+  integer, parameter, public :: & ! named constant for file distribution mode
+     & DGFM_SEQ   = 0, &
+     & DGFM_READ  = 1, & 
+     & DGFM_BCAST = 2 
+
+  integer, save :: isdgmc 
+
+  integer, save :: dagmc_geom_file_mode = DGFM_SEQ  ! default to a distributed read
+
+  integer, save :: dagmc_srcmode = 0
+  integer, save :: dagmc_usecad  = 0
+  integer, save :: dagmc_distlimit = 0
+  
+  real(dknd), save :: dagmc_facet_tol
+  real(dknd), save :: dagmc_tolerance
+  real(dknd), save :: dagmc_version
+  
+  integer, save :: dagmc_subversion
+
+  public :: &
+    &   lcadrd, &        ! read log file information
+    &   dagmc_msgput, &  ! share dagmc settings to slave tasks
+    &   dagmc_msgget    ! receive dagmc settings from master task
+
+contains
+
+  subroutine lcadrd
+    ! Description:
+    ! Reads in the CAD log file and "inserts" it at the header
+    ! of the input file.
+    
+    ! >>>>> Modules used
+    use mcnp_global
+    use mcnp_params
+    use mcnp_iofiles
+    
+    ! >>>>> Implict declaration of real variables as doubles
+    implicit real(dknd) (a-h,o-z)
+    
+    ! >>>>> Other variables
+    character(len=80)  :: hk          ! Character for line of file being read
+    integer, parameter :: ie = 70     ! I/O index of a scratch file
+    integer            :: it, iu = 0  ! Indices for nxtsym function
+    integer            :: ios = 0     ! IOSTAT for file reading
+    
+    ! >>>>> Initialize the scratch file and get to beginning of input file
+    open(ie,status='scratch')
+    rewind iui
+    
+    ! >>>>> Check if first line is message block, otherwise assume a title card
+    read(iui,'(a80)',end=1000) hk
+    call nxtsym(hk,' ',1,it,iu,1)
+    
+    if (hk(it:iu) == 'message:') then
+       ! Message block exists, read until blank line found
+       do
+          read(iui,'(a80)',end=1000) hk   ! Read in string: exception for eof
+          if (hk == ' ') exit             ! Terminate loop once blank line found 
+       enddo
+       ! Read in title card, for message block case
+       read(iui,'(a80)',end=1000) hk
+    endif
+    
+    ! Write title card to scratch file
+    write(ie,'(a80)') hk
+    
+    ! >>>>> Read in cell/surface cards from log
+    rewind iulc
+    do
+       read(iulc, '(a80)', iostat=ios) hk
+       
+       ! Check for end of file or errors
+       if (ios == 0) then
+          write(ie,'(a80)') hk     ! Write the line normally
+       elseif (ios < 0) then
+          exit                     ! Break loop at EOF
+       else
+          goto 2000                ! Exception for severe I/O error
+       endif
+    enddo
+    
+    ! >>>> Read in rest of input file
+    ios = 0
+    do
+       read(iui, '(a80)', iostat = ios) hk
+       
+       ! Check for end of file or errors
+       if (ios == 0) then
+          write(ie,'(a80)') hk     ! Write the line to scratch file
+       elseif (ios < 0) then
+          exit                     ! Break loop at EOF
+       else
+          goto 3000                ! Exception for severe I/O error
+       endif
+    enddo
+    
+    ! >>>>> Echo back to new scratch input file
+    close(iui)
+    rewind ie
+    open(iui,status='scratch')
+    ios = 0
+    do      
+       read(ie, '(a80)', iostat = ios) hk
+       
+       ! Check for end of file or errors
+       if (ios == 0) then
+          write(iui,'(a80)') hk    ! Write the line in the scratch input file
+       elseif (ios < 0) then
+          exit                     ! Break loop at EOF
+       else
+          goto 4000                ! Exception for severe I/O error
+       endif
+       
+    enddo
+    
+    ! >>>>> Finish up
+    rewind iui
+    ! pass1 expects iui to be advanced beyond the title card, 
+    ! so read past the first line now
+    read(iui, '(a)')
+
+    close(ie)
+    return
+    
+    ! >>>>> Exceptions
+    ! End of File at header of input file
+1000 call expire(0,'lcadrd','unexpected eof in file '//inp)
+    return
+    ! Severe I/O error during reading of CAD log
+2000 call expire(0,'lcadrd','error during read of file '//lcad)
+    return
+    ! Severe I/O error during reading of CAD log
+3000 call expire(0,'lcadrd','error during read of file '//inp)
+    return
+    ! Severe I/O error during echo of scratch file to new input file
+4000 call expire(0,'lcadrd','error stitching input and CAD log')
+    return
+    
+  end subroutine lcadrd
+
+  subroutine dagmc_msgput
+
+    use messages, only : msg_put
+    use mcnp_iofiles, only: gcad, ftol
+    use fixcom, only : ntal
+    use mcnp_debug
+
+    call msg_put (isdgmc)
+    call msg_put (dagmc_geom_file_mode)
+    call msg_put (gcad)
+    call msg_put (ftol)
+    call msg_put (dagmc_srcmode)
+    call msg_put (dagmc_usecad)
+    call msg_put (dagmc_distlimit)
+    call msg_put (dagmc_tolerance)
+    call msg_put (dagmc_facet_tol)
+    call msg_put (dagmc_version)
+
+  end subroutine dagmc_msgput
+
+  subroutine dagmc_msgget
+   
+    use messages, only : msg_get
+    use mcnp_iofiles, only: gcad, ftol
+    use fixcom, only : ntal
+    use mcnp_debug
+
+    implicit none
+
+    real(dknd) :: master_dagmc_version
+
+    call msg_get (isdgmc)
+    call msg_get (dagmc_geom_file_mode)
+    call msg_get (gcad)
+    call msg_get (ftol)
+    call msg_get (dagmc_srcmode)
+    call msg_get (dagmc_usecad)
+    call msg_get (dagmc_distlimit)
+    call msg_get (dagmc_tolerance)
+    call msg_get (dagmc_facet_tol)
+    call msg_get (master_dagmc_version)
+
+    if ( isdgmc == 1 ) then
+       call dagmcinit(gcad//char(0),len_trim(gcad),      &
+          &           ftol//char(0),len_trim(ftol),      &
+	  &           dagmc_geom_file_mode, dagmc_version, dagmc_subversion )
+       if (dagmc_version /= master_dagmc_version) then
+          ! errprt and fail!
+       end if
+       call set_settings(dagmc_srcmode, dagmc_distlimit, dagmc_usecad, dagmc_tolerance)
+    end if
+
+  end subroutine dagmc_msgget
+  
+  subroutine init_dagmc
+
+     use mcnp_iofiles
+
+     ! Check to see if the CAD file exists, if not, abort
+     inquire( file = gcad, exist = file_exists)
+     if (.not.file_exists) then
+        call expire(0,'main','CAD geometry file '//gcad// &
+             &            ' does not exist.')
+     endif
+     
+     ! initialize DAGMC, read geometry and initialize OBBTree
+     call dagmcinit(gcad//char(0),len_trim(gcad),      &
+          &         ftol//char(0),len_trim(ftol),      &
+	  &         dagmc_geom_file_mode,dagmc_version, dagmc_subversion )
+
+
+     call init_settings(dagmc_srcmode, dagmc_distlimit, dagmc_usecad, &
+                       dagmc_tolerance, dagmc_facet_tol)
+
+     ! print version number message to terminal
+     call dagmc_version_heading(jtty)
+
+     ! write mesh file if requested
+     if ( len_trim(fcad) .gt. 0) then
+        call dagmcwritefacets(fcad//char(0),len_trim(fcad))     
+     endif
+
+
+     ! parse metadata and write input cards
+     call dagmcwritemcnp(lcad//char(0), len_trim(lcad))
+     
+     ! Check to ensure that the log file is written
+     inquire( file = lcad, exist = file_exists)
+     if (.not.file_exists) then
+        call expire(0,'main','CAD list file '//lcad// &
+             &             ' not written by DAGMC.')
+     endif
+     
+     ! Open the cad log file on the MCNP side
+     open( unit=iulc, file=lcad, status='old' )
+
+  end subroutine init_dagmc
+
+  ! write DagMC version number message to given file
+  subroutine dagmc_version_heading(o)
+    
+    integer :: o 
+
+     write(o,150) dagmc_version, dagmc_subversion
+150  format(1x,'This problem is using DAGMC version ',f8.3,' w/ DagMC r', i4)
+
+  end subroutine dagmc_version_heading
+
+end module dagmc_mod

Property changes on: src/dagmc_mod.F90
___________________________________________________________________
Added: svn:executable
   + *
Added: svn:mergeinfo

Index: src/sourcb.F90
===================================================================
--- src/sourcb.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/sourcb.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -6,11 +6,14 @@
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   character(len=5) ::  hc
   real(dknd) :: fb(maxv), sf(3)
   integer    :: ic(maxv)
+
+  integer :: idagsrc
   
   sf(1:3) = 0.
   sff(1:3,1:maxv) = srv(1:3,1:maxv)
@@ -469,6 +472,15 @@
   
   ! default for cel:  find the cell that contains xyz.
 470 continue
+
+  ! DAGMC: In CAD mode, read DAGMC setting for treatment of source cell
+  if ( isdgmc == 1 ) then
+    call dagmcsrccell(idagsrc)
+    if (idagsrc > 0) then
+      return
+    endif
+  endif
+
   if( icl==0 ) then
     if( junf==0 ) then
       do m=1,nlse 
Index: src/celsrf.F90
===================================================================
--- src/celsrf.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/celsrf.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -10,6 +10,7 @@
   use mcnp_debug
   use mcnp_input
   use erprnt_mod
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   character hj(2,3)*10, hl*5, hp*130, hq*2, ht*4
@@ -307,6 +308,10 @@
 470 continue
   jp = 0
   DO_500: do j=1,mxj
+
+    ! DAGMC: Skip this loop if in DAGMC mode
+    if (isdgmc == 1) exit
+
     if( idns(j)/=0 )  cycle DO_500
     if( ksm(j)/=0  )  cycle DO_500
     if( ksu(j)>0   )  jp=1
Index: src/Makefile
===================================================================
--- src/Makefile	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/Makefile	(.../5.1.40/trunk/Source)	(revision 218)
@@ -9,10 +9,11 @@
 # These variables MIGHT be defined in config/$(OS).gcf
 #
 #    FFLAGS,  CFLAGS,  LDFLAGS,  OBJF, OBJC, I, OUT
-#    DEF_MACH,  DEF_PLOT,  DEF_SMMP,  DEF_DMMP
+#    DEF_MACH,  DEF_PLOT,  DEF_DAGMC, DEF_SMMP,  DEF_DMMP
 #    Q, ECHO, RM, MV
 #    FPP, FPPFLAGS, CPPFLAGS
 #    PLOTLIBS
+#    MOAB_DIR
 #    COMPILER
 #    PREPROCESS
 #    DMMP defs & libs & includes
@@ -81,12 +82,12 @@
   -DDPATH=$Q${DATAPATH}$Q
 
 # Complete set of preprocessor defs
-DEFS    = $(DEF_CODEINFO) $(DEF_MACH) $(DEF_PLOT) $(DEF_SMMP) $(DEF_DMMP) $(DMMP_NAME)
+DEFS    = $(DEF_CODEINFO) $(DEF_MACH) $(DEF_PLOT) $(DEF_DAGMC) $(DEF_SMMP) $(DEF_DMMP) $(DMMP_NAME)
 
 #############################
 # Part III. Lists of Files  #
 #############################
-# Defined in FILE.list:  F_SRC, F_OBJS, C_SRC, C_OBJS
+# Defined in FILE.list:  F_SRC, F_OBJS, C_SRC, C_OBJS, CXX_SRC, CXX_OBJS
 
 # - - - - - - - -
 include FILE.list
@@ -95,20 +96,22 @@
 ###########################################################
 # Part IV. Lists of libs, include-dirs, complete options  #
 ###########################################################
-LIBS	= $(PLOTLIBS)  $(LIB_DMMP) $(EXTRALIBS) 
-INCLUDES= -I.  $(INC_DMMP)  $(INCLUDE_DIRS) 
+LIBS	= $(PLOTLIBS)  $(LIB_DMMP) $(EXTRALIBS) $(DAGMC_LIBS)
+INCLUDES += -I.  $(INC_DMMP)  $(INCLUDE_DIRS) 
 
 ifeq (,$(PREPROCESS))
   # explicit f90 preprocessing NOT NEEDED, compiler does it
   ALL_FPPFLAGS	=
   ALL_FFLAGS	= $(FPPFLAGS) $(INCLUDES) $(FFLAGS)
   ALL_CFLAGS	= $(CPPFLAGS) $(INCLUDES) $(CFLAGS)
+  ALL_CXXFLAGS	= $(CPPFLAGS) $(INCLUDES) $(CXXFLAGS)
   ALL_LDFLAGS	= $(LDFLAGS)  $(LIBS)
 else
   # explicit f90 preprocessing NEEDED, compiler does not do it.
   ALL_FPPFLAGS	= $(FPPFLAGS) 
   ALL_FFLAGS	=             $(INCLUDES) $(FFLAGS)
   ALL_CFLAGS	= $(CPPFLAGS) $(INCLUDES) $(CFLAGS)
+  ALL_CXXFLAGS	= $(CPPFLAGS) $(INCLUDES) $(CXXFLAGS)
   ALL_LDFLAGS	= $(LDFLAGS)  $(LIBS) 
 endif
 
@@ -117,18 +120,18 @@
 ####################
 ##.SILENT:
 
-$(EXEC):   $(F_OBJS) $(C_OBJS) 
+$(EXEC):   $(F_OBJS) $(C_OBJS) $(CXX_OBJS)
 	@ $(ECHO) "--- $@ ---"
-	@ $(LD)  $(OUT)$(EXEC) $(F_OBJS) $(C_OBJS) $(ALL_LDFLAGS)
+	@ $(LD)  $(OUT)$(EXEC) $(F_OBJS) $(C_OBJS) $(CXX_OBJS) $(ALL_LDFLAGS)
 
 clean:
 	@ $(ECHO) --- $@ src ---
-	@ $(RM) -f $(F_OBJS) $(C_OBJS) ./*$(OBJF)
+	@ $(RM) -f $(F_OBJS) $(C_OBJS) $(CXX_OBJS) ./*$(OBJF) ../dagmc/*$(OBJC)
 	@ $(RM) -f ./*$(I) ./*.mod ./*.MOD core
 
 realclean:
 	@ $(ECHO) --- $@ src ---
-	@ $(RM) -f $(F_OBJS) $(C_OBJS) ./*$(OBJF)
+	@ $(RM) -f $(F_OBJS) $(C_OBJS) $(CXX_OBJS) ./*$(OBJF) ../dagmc/*$(OBJC)
 	@ $(RM) -f ./*$(I) ./*.mod ./*.MOD core $(EXEC) $(EXEC).exe
 
 #########################
@@ -143,7 +146,7 @@
 # Part VII. Rules  #
 ####################
 .SUFFIXES:
-.SUFFIXES:      .F90    .c      $(OBJF)		$(OBJC)		$(I)	.a
+.SUFFIXES:      .F90    .c      .cpp	$(OBJF)		$(OBJC)		$(I)	.a
 
 $(DOTCOMMROOT)/src/libdotcomm.a :
 	$(ECHO) "--- $@ ---"
@@ -159,6 +162,13 @@
   endif
 	$(CC) $(ALL_CFLAGS) -c $<
 
+%$(OBJC) : %.cpp
+	$(ECHO) "--- $@ ---"
+  ifeq (1,$(scr_trace))
+	$(ECHO) "$(CXX) $(ALL_CXXFLAGS) -c -o $@ $<"
+  endif
+	$(CXX) $(ALL_CXXFLAGS) -c -o $@ $<
+
 ifeq (,$(PREPROCESS))
   # no separate preprocessing, compiler does it
   %$(OBJF) : %.F90 
Index: src/track.F90
===================================================================
--- src/track.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/track.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -12,6 +12,7 @@
   use mcnp_global
   use mcnp_debug
   use qttyin_mod, only: qttyin
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   real(dknd) :: dl(0:mxlv)
@@ -23,6 +24,15 @@
       call qttyin(-1,' "nps =",i12,5x,  "collisions =",i6')
     endif
   endif
+
+  ! DAGMC: If in CAD mode, call DAGMC version of track instead
+  if ( isdgmc == 1 ) then    
+    call dagmctrack(ih,uuu,vvv,www,xxx,yyy,zzz,huge_float,dls, &
+     &               jap,jsu,nps)
+    if ( dls == huge_float ) kdb = 2
+    return
+  endif
+
   ll = lev
   ic = ih
 
Index: src/Depends
===================================================================
--- src/Depends	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/Depends	(.../5.1.40/trunk/Source)	(revision 218)
@@ -18,7 +18,7 @@
 action$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 addtfc$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) ra2_mod$(OBJF) 
 amatrx$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
-angl$(OBJF)   : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+angl$(OBJF)   : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
 arbobv$(OBJF) : mcnp_params$(OBJF) mcnp_debug$(OBJF)
 avrclc$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 avrnrm$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
@@ -42,7 +42,7 @@
 celpar$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) mcnp_input$(OBJF) \
 		erprnt$(OBJF)
 celsrf$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) mcnp_input$(OBJF) \
-		erprnt$(OBJF)
+		erprnt$(OBJF) $(DAGMC_MOD)
 cgsdci$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 chekcs$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) mcnp_input$(OBJF) \
 		erprnt$(OBJF)
@@ -50,7 +50,7 @@
 		ra1_mod$(OBJF) fmesh_mod$(OBJF)  erprnt$(OBJF)
 chektr$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) mcnp_input$(OBJF) \
 		erprnt$(OBJF) fmesh_mod$(OBJF)
-chkcel$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+chkcel$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
 chksrc$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 chqcel$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) mcnp_input$(OBJF)
 ckchar$(OBJF) : mcnp_debug$(OBJF)
@@ -69,7 +69,7 @@
 		erprnt$(OBJF)
 crspro$(OBJF) : mcnp_params$(OBJF) mcnp_debug$(OBJF)
 crtcze$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
-dbmin$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+dbmin$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
 dddet$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 dddiag$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 dddlev$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
@@ -85,7 +85,7 @@
 dynamic_arrays$(OBJF) : dmmp$(OBJF) mcnp_debug$(OBJF)
 echkcl$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 electr$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) fmesh_mod$(OBJF) \
-		dxtran_mod$(OBJF)  mcnp_landau$(OBJF)
+		dxtran_mod$(OBJF)  mcnp_landau$(OBJF) $(DAGMC_MOD)
 electron_history$(OBJF) : mcnp_params$(OBJF) mcnp_data$(OBJF) ephcom$(OBJF) fixcom$(OBJF) \
 		tskcom$(OBJF) pblcom$(OBJF) mcnp_global$(OBJF) fmesh_mod$(OBJF) dxtran_mod$(OBJF) \
 		mcnp_landau$(OBJF) mcnp_debug$(OBJF)
@@ -134,12 +134,13 @@
 gxsub$(OBJF)  : mcnp_global$(OBJF) mcnp_plot$(OBJF) gkssim$(OBJF) mcnp_debug$(OBJF)
 hpsort$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 hstory$(OBJF) : mcnp_global$(OBJF) smmp$(OBJF) ra1_mod$(OBJF) fmesh_mod$(OBJF) \
-		rmc_mod$(OBJF) mcnp_debug$(OBJF) dxtran_mod$(OBJF)
+		rmc_mod$(OBJF) mcnp_debug$(OBJF) dxtran_mod$(OBJF) $(DAGMC_MOD)
 igeom$(OBJF)  : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) \
-		erprnt$(OBJF)
+		erprnt$(OBJF) $(DAGMC_MOD)
 imcn$(OBJF)   : mcnp_global$(OBJF) mcnp_input$(OBJF) crit1_mod$(OBJF) \
 		ra1_mod$(OBJF) ra2_mod$(OBJF) \
-		fmesh_mod$(OBJF) rmc_mod$(OBJF) mcnp_debug$(OBJF)
+		fmesh_mod$(OBJF) rmc_mod$(OBJF) mcnp_debug$(OBJF) \
+		$(DAGMC_MOD)
 inpert$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) \
 		erprnt$(OBJF)
 inter$(OBJF)  : mcnp_global$(OBJF) mcnp_plot$(OBJF) mcnp_debug$(OBJF)
@@ -153,7 +154,7 @@
 issrc$(OBJF)  : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) \
 		erprnt$(OBJF)
 itally$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) \
-		fmesh_mod$(OBJF) erprnt$(OBJF)
+		fmesh_mod$(OBJF) erprnt$(OBJF) $(DAGMC_MOD)
 italpr$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF)
 items$(OBJF)  : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) \
 		erprnt$(OBJF)
@@ -181,7 +182,7 @@
 main$(OBJF)   : mcnp_global$(OBJF) dmmp$(OBJF) lx5_mod$(OBJF) \
 		mcplot_module$(OBJF) crit1_mod$(OBJF) \
            	crit2_mod$(OBJF) ra1_mod$(OBJF) ra2_mod$(OBJF) gxsub$(OBJF) \
-		mcnp_debug$(OBJF)
+		mcnp_debug$(OBJF) $(DAGMC_MOD)
 mapmaz$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) qttyin$(OBJF) \
 		erprnt$(OBJF)
 mbody$(OBJF)  : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) \
@@ -221,16 +222,16 @@
 		erprnt$(OBJF)
 msgtsk$(OBJF) : mcnp_global$(OBJF) dmmp$(OBJF) messages$(OBJF) dynamic_arrays$(OBJF) \
 		smmp$(OBJF) ra1_mod$(OBJF) racom$(OBJF) fmesh_mod$(OBJF) mcnp_debug$(OBJF)
-namchg$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+namchg$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
 namrsd$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
 newcd1$(OBJF) : mcnp_global$(OBJF) dynamic_arrays$(OBJF) mcnp_input$(OBJF) \
 		ra2_mod$(OBJF) fmesh_mod$(OBJF) mcnp_debug$(OBJF) qttyin$(OBJF) \
 		erprnt$(OBJF)
-newcel$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+newcel$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
 newcrd$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) fmesh_mod$(OBJF) mcnp_debug$(OBJF) \
 		qttyin$(OBJF) erprnt$(OBJF)
 nextit$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) ra1_mod$(OBJF) ra2_mod$(OBJF) \
-		fmesh_mod$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
+		fmesh_mod$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF) $(DAGMC_MOD)
 norma$(OBJF)  : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
 normh$(OBJF)  : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
 nsf$(OBJF)    : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF)
@@ -241,11 +242,12 @@
 oldcd1$(OBJF) : mcnp_global$(OBJF) dynamic_arrays$(OBJF) mcnp_input$(OBJF) \
 		fmesh_mod$(OBJF) mcnp_debug$(OBJF)
 oldcrd$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) ra1_mod$(OBJF) \
-		fmesh_mod$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
+		fmesh_mod$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF) $(DAGMC_MOD)
 output$(OBJF) : mcnp_global$(OBJF) mcplot_module$(OBJF) crit1_mod$(OBJF) \
 		ra1_mod$(OBJF) mcnp_debug$(OBJF) qttyin$(OBJF)
 pareto$(OBJF) : mcnp_params$(OBJF) mcnp_debug$(OBJF)
-pass1$(OBJF)  : mcnp_global$(OBJF) dynamic_arrays$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF)
+pass1$(OBJF)  : mcnp_global$(OBJF) dynamic_arrays$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) \
+	        $(DAGMC_MOD)
 pathmz$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 pblcom$(OBJF) : mcnp_params$(OBJF)
 pconst$(OBJF) : fixcom$(OBJF) mcnp_params$(OBJF) mcnp_iofiles$(OBJF) \
@@ -327,7 +329,7 @@
 sing$(OBJF)   : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 smmp$(OBJF)   : mcnp_params$(OBJF) mcnp_debug$(OBJF)
 smpsrc$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
-sourcb$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+sourcb$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
 source$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 sourck$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 spec$(OBJF)   : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_params$(OBJF) mcnp_debug$(OBJF)
@@ -350,7 +352,7 @@
 sursrc$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 tallmg$(OBJF) : mcnp_global$(OBJF) smmp$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
 talloc$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
-tally$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+tally$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
 tallyd$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 tallyh$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) qttyin$(OBJF)
 tallyp$(OBJF) : mcnp_global$(OBJF) ra2_mod$(OBJF) mcnp_debug$(OBJF)
@@ -367,8 +369,8 @@
 torus$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF)
 tpefil$(OBJF) : mcnp_global$(OBJF) dynamic_arrays$(OBJF) lx5_mod$(OBJF) ra1_mod$(OBJF) \
 		ra2_mod$(OBJF) mcnp_debug$(OBJF)
-track$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF) qttyin$(OBJF)
-transm$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+track$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF) qttyin$(OBJF) $(DAGMC_MOD)
+transm$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
 trfmat$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
 trfsrf$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
 trnspt$(OBJF) : mcnp_global$(OBJF) smmp$(OBJF) ra2_mod$(OBJF) mcnp_debug$(OBJF)
@@ -386,7 +388,7 @@
 viewz$(OBJF)  : mcnp_global$(OBJF) mcnp_plot$(OBJF) mcnp_debug$(OBJF) fmesh_plot_mod$(OBJF) 
 voidcd$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
 volume$(OBJF) : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) qttyin$(OBJF) \
-		erprnt$(OBJF)
+		erprnt$(OBJF) $(DAGMC_MOD)
 vtask$(OBJF)  : mcnp_global$(OBJF) smmp$(OBJF) ra1_mod$(OBJF) \
 		fmesh_mod$(OBJF) mcnp_debug$(OBJF)
 wgtul$(OBJF)  : mcnp_global$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF)
@@ -415,3 +417,9 @@
 ifneq (,$(DOTCOMMROOT))
 $(LIBDOTCOMM) : mcnp_params$(OBJF)
 endif
+#
+# DagMC objects
+ifneq (,$(DAGMC_MOD))
+dagmc_mod$(OBJF) : mcnp_global$(OBJF) messages$(OBJF)
+../dagmc/mcnp_funcs$(OBJC) : ../dagmc/mcnp_funcs.h 
+endif
Index: src/tally.F90
===================================================================
--- src/tally.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/tally.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -8,6 +8,7 @@
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   integer :: ik(8), ii(3)
@@ -285,6 +286,10 @@
     if( iptal(4,1,ital)==0 )  go to 470
     ig = iptal(4,1,ital)
     call chkcel(ig,3,j)
+
+    ! DAGMC: If in CAD mode, make sure distance to physics collision is initialized
+    if ( isdgmc == 1 ) call setdis(huge_float)
+
     call track(ig)
     if( kdb/=0 )  go to 999 ! Return
     n = iptal(4,4,ital)-2
Index: src/imcn.F90
===================================================================
--- src/imcn.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/imcn.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -12,6 +12,7 @@
   use rmc_mod
   use crit1_mod
   use fmesh_mod, only: nmesh, fmesh_initialize
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
@@ -422,6 +423,11 @@
       &                   new_stride       = RN_stride_input,  &
       &                   new_part1        = RN_hist_input     )
 
+    ! Initialize DAGMC
+    if (isdgmc == 1) then   ! set DAGMC parameters from idum & rdum
+       call set_settings(dagmc_srcmode, dagmc_distlimit, dagmc_usecad, dagmc_tolerance)
+    endif
+
     if( uran_n>0 ) then
       write(jtty,17) (uran_univ(j),(uran_xyz(i,j),i=1,3),j=1,uran_n)
 17    format(1x,/, &
Index: src/dbmin.F90
===================================================================
--- src/dbmin.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/dbmin.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -9,9 +9,21 @@
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
+  ! DAGMC: Explicitly declare variable for return value for inter-language call
+  real(dknd) :: dbmin_retval = zero
+
+  ! DAGMC: In CAD mode, call MOAB version instead
+  if ( isdgmc == 1 ) then
+     call dagmcdbmin(icl,xxx,yyy,zzz,huge_float,dbmin_retval)
+     dbmin = dbmin_retval
+     return
+  endif
+
+
   dbmin = huge_float
   ic = icl
   x0 = xxx
Index: src/electr.F90
===================================================================
--- src/electr.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/electr.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -9,6 +9,7 @@
   use mcnp_debug
   use mcnp_landau, only: esloss
   use fmesh_mod, only:  mesh_score, nmesh
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
@@ -82,6 +83,12 @@
           call chkcel(icl,3,j)
         endif
 
+        ! DAGMC: In DAGMC mode, use the known physics distance to limit geometry search
+        if ( isdgmc == 1 ) then
+           d = min(dtc,pmf)
+           call setdis(d)
+        endif
+
         call track(icl)
         if( kdb/=0 )  go to 999 ! Return
         jsu = jap
Index: src/oldcrd.F90
===================================================================
--- src/oldcrd.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/oldcrd.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -9,6 +9,7 @@
   use mcnp_input
   use fmesh_mod
   use erprnt_mod
+  use dagmc_mod
 #if defined(VISED) && defined(DEC)
   use c_interfaces
 #endif
@@ -34,7 +35,8 @@
     if( likef==0 ) then
       if(m1c /= 0)  call erprnt(2,1,0,0,0,0,0,0,'  "parentheses used incorrectly."')
       lca(mxa+1) = nlja+1
-      if( lca(mxa)==nlja+1 ) &
+      ! DAGMC: In DAGMC mode, cells should have no surfaces
+      if( ( lca(mxa)==nlja+1 ) .and. ( isdgmc == 0)  ) &
         & call erprnt(2,1,0,0,0,0,0,0,'  "this cell has no surfaces."')
     else
       call likebt(2)
@@ -46,6 +48,10 @@
     !  >>>>>  surface descriptions
     ! m1c=surface type index.
     ! m2c=1 if surface type symbol is the second item.
+
+    ! DAGMC: Break out of subroutine here in CAD mode
+    if ( isdgmc == 1 ) return
+
     ix = lsc(mxj)
     if( (m1c==1 .and. nwc>5+m2c) .or. &
       & (m1c>=27 .and. m1c<=29)   .or. m1c>39 ) then
Index: src/mcnp_input.F90
===================================================================
--- src/mcnp_input.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/mcnp_input.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -8,7 +8,7 @@
   integer,private :: i                  ! Local loop variable.
 
   ! Module Parameters:
-  integer,parameter :: nkcd   = 104     != Number of different types of input cards.
+  integer,parameter :: nkcd   = 107     != Number of different types of input cards.
   integer,parameter :: ntalmx = 1000    != Maximum number of tallies.
   integer,parameter :: mopts  = 7       != Number of M card options (gas, estep, etc.).
 
@@ -121,6 +121,12 @@
   ! rand card keywords, input values
   character(len=6), parameter ::  hrand(4) = (/'gen   ','seed  ','stride','hist  '/)
 
+  ! dagmc card keywords, input values
+  character(len=14), parameter :: hdagmc(4) = (/'check_src_cell', &
+    &                                           'usecad        ', &
+    &                                           'distlimit     ', &
+    &                                           'tolerance     ' /)
+
   !  ----------------------------------------------------------------------
   ! initialize data for imcn.
   integer,parameter,private :: nx=5*mxdx+3
@@ -239,4 +245,5 @@
   data cnm(102),(krq(i,102),i=1,7)/ 'spdtl',0,0, 0,0, 0,   1,0 / 
   data cnm(103),(krq(i,103),i=1,7)/ 'uran ',0,0, 0,0, 0,   0,0 / 
   data cnm(104),(krq(i,104),i=1,7)/ 'hsrc ',0,0, 0,0, 0,   0,0 / 
+  data cnm(107),(krq(i,104),i=1,7)/ 'dagmc',0,0, 0,0, 0,  12,0 / 
 end module mcnp_input
Index: src/main.F90
===================================================================
--- src/main.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/main.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -53,6 +53,7 @@
   use crit2_mod
   use ra1_mod
   use ra2_mod
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
@@ -142,6 +143,31 @@
   endif
 
   call exemes
+
+  ! DAGMC: initialize a DAGMC run if specified
+  if (gcad /= ' ') then
+     isdgmc = 1
+     
+     if (mcnp_opt_multp) dagmc_geom_file_mode = DGFM_READ;
+
+  else
+     
+     ! Error checking for user specifying worthless files
+     if(lcad /= ' ') then
+        call expire(0,'main','CAD list file specified &
+             &   without a geometry file.')
+     endif
+     if(fcad /= ' ') then
+        call expire(0,'main','CAD facet file specified &
+             &   without a geometry file.')
+     endif
+     if(ftol /= ' ') then
+        call expire(0,'main','Facet tolerance specified &
+             &   without a geometry file.')
+     endif
+     
+  endif
+  
   if( konrun==0 )  probid = idtm
 
   ! Alternate method for setting ltasks for MPI-based versions.
@@ -177,10 +203,14 @@
       if( file_exists )  call expire(0,'main',&
         & 'name='//iname//' fails. '//isub(i)//' already exists.')
     endif
-    if( isub(i)==' ' .and. msub(i)/='com' )  isub(i)=msub(i)
+    if( isub(i)==' ' .and. msub(i)/='com' .and. msub(i)/='fcad')  isub(i)=msub(i)
   enddo
   call set_filenames
 
+  if (isdgmc == 1) then
+     call init_dagmc
+  endif 
+
   ! Create the output print file and write heading on it.
   call unique(outp,jtty)
   open(iuo,file=outp,status='new')
@@ -192,6 +222,7 @@
 170 format( "1",a8, " version ",a5, " ld=",a8,8x,a10,2x,a19/&
     & ,1x,73( "*"),:17x, "probid = ",a19)
   write(iuo,'(1x,a80/)') exms
+  if (isdgmc == 1) call dagmc_version_heading(iuo)
 
   call ttyint
 
Index: src/FILE.list
===================================================================
--- src/FILE.list	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/FILE.list	(.../5.1.40/trunk/Source)	(revision 218)
@@ -72,7 +72,11 @@
 ####################
 C_SRC :=  mc.c
 
-#################################################
+####################
+# C++ Source Files #
+####################
+CXX_SRC :=  
+
 # Files not needed, depending on CONFIG options #
 #################################################
 UNWANTED_F_SRC :=	cgsdci.F90
@@ -90,14 +94,21 @@
 	viewz.F90
 endif
 
+ifeq (dagmc,$(filter dagmc,$(CONFIG)))
+  F_SRC   := $(F_SRC) dagmc_mod.F90
+  CXX_SRC := $(CXX_SRC) ../dagmc/mcnp_funcs.cpp 
+endif
+
 #################################
 # Useful lists of derived files #
 #################################
 
 F_SRC :=	$(filter-out $(UNWANTED_F_SRC),$(F_SRC))
 C_SRC :=	$(filter-out $(UNWANTED_C_SRC),$(C_SRC))
+CXX_SRC :=	$(filter-out $(UNWANTED_CXX_SRC),$(CXX_SRC))
 
 F_OBJS =	$(F_SRC:.F90=$(OBJF))
 C_OBJS =	$(C_SRC:.c=$(OBJC))
+CXX_OBJS =	$(CXX_SRC:.cpp=$(OBJC))
 
 I_FILES =	$(F_OBJS:$(OBJF)=$(I))
Index: src/itally.F90
===================================================================
--- src/itally.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/itally.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -17,6 +17,7 @@
   use mcnp_input
   use fmesh_mod,  only:  nmesh
   use erprnt_mod
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   character(len=1) :: h
@@ -89,6 +90,13 @@
         j = rtp(ipnt(1,7+m,ital)-1+i)
         k = namchg(2*m-1,j)
         if( k==0 ) go to 40
+
+        ! DAGMC: If in CAD mode, skip up until line prior to marker 40
+        if ( isdgmc == 1 ) then
+          itds(li+i) = k
+          goto 40
+        endif
+
         ! if macrobody identical surface, use master surface number.
         if( m==2 ) then
           ! check if a bounding surface, include facet if macrobody.
Index: src/msgtsk.F90
===================================================================
--- src/msgtsk.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/msgtsk.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -15,6 +15,7 @@
   use dynamic_arrays
   use messages
   use fmesh_mod, only:  fmesh_msgget, fmesh_msgtsk
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
@@ -80,6 +81,9 @@
   call dyn_msgget
   call fmesh_msgget
 
+  call dm_recv(-1,20,i)
+  call dagmc_msgget  
+
   ! Receive cross section data.
   if( lxs>0 ) then
     is_assoc = associated(xss)
Index: src/newcel.F90
===================================================================
--- src/newcel.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/newcel.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -8,8 +8,17 @@
   use mcnp_global
   use mcnp_debug
   use uran_mod
+  use dagmc_mod
   implicit real(dknd) (a-h,o-z)
    
+  ! DAGMC: In CAD mode, call MOAB version of this
+  if ( isdgmc == 1 ) then
+    if ( cs /= 0 ) cs = angl()
+    call dagmcnewcel(lev,uuu,vvv,www,xxx,yyy,zzz,dls,jap,jsu, &
+     &               icl,iap,mxa)
+    if ( mxa == -1 ) kdb = 1
+  endif
+
   ! shift to the higher level if one was found in track.
   if( levp/=lev ) then
     lev = levp
@@ -33,7 +42,10 @@
   if( iovr==2 ) then
     kdb = 1
   else
-    call expirx(1,'newcel','the surface crossed is not a surface of this cell.')
+    ! DAGMC: Only check this if running normally, (NOT in CAD mode)
+    if (isdgmc == 0) then
+      call expirx(1,'newcel','the surface crossed is not a surface of this cell.')
+    endif
   endif
   return
 
Index: src/chkcel.F90
===================================================================
--- src/chkcel.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/chkcel.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -20,10 +20,18 @@
   ! Modules used:
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   integer :: j,k,ie=0
 
+  ! DAGMC: In CAD mode, circumvent this function and call DAGMC version instead
+  if ( isdgmc == 1 .and. (m == 0 .or. m==2) ) then
+     call dagmcchkcel(lev,uuu,vvv,www,xxx,yyy,zzz,dls,jap, &
+          &               jsu,icl,iap,mxa,i1,j)
+     return
+  endif
+  
   ! Do all surfaces of cell i1 or until mm is matched.
   j2 = abs(lca(i1))
   iL = j2-lca(i1)+m
Index: src/igeom.F90
===================================================================
--- src/igeom.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/igeom.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -7,6 +7,7 @@
   use mcnp_debug
   use mcnp_input
   use erprnt_mod
+  use dagmc_mod
 #if defined(VISED) && defined(DEC)
   use c_interfaces
 #endif
@@ -69,7 +70,8 @@
 
   ! expand # operators and check the cells and surfaces.
 80 continue
-  call chekcs
+  ! DAGMC: only call this when running in normal (non-CAD) mode
+  if (isdgmc == 0) call chekcs
 
   ! calculate the constants of any lattices in the geometry.
   if( nlat/=0 ) then
Index: src/transm.F90
===================================================================
--- src/transm.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/transm.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -8,6 +8,7 @@
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
   implicit real(dknd) (a-h,o-z)
 
   iz = 0
@@ -30,6 +31,8 @@
     endif
 
     ! calculate the attenuation for this section of the track.
+    ! DAGMC: If in CAD mode, call setdis first
+    if ( isdgmc == 1 ) call setdis( dd - sd )
     call track(icl)
     if( kdb/=0 ) go to 90
     totm = 0.
Index: src/msgcon.F90
===================================================================
--- src/msgcon.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/msgcon.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -16,6 +16,7 @@
   use fmesh_mod, only:fmesh_msgput,fmesh_msgcon
   use qttyin_mod, only: qttyin
   use erprnt_mod, only: erprnt, erprnt_i8_k1
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
@@ -157,6 +158,11 @@
   call fmesh_msgput
   call dm_send(-1,14,i)
 
+  write(jtty,*) "master sending DAGMC information...."
+  call dm_sndi
+  call dagmc_msgput
+  call dm_send(-1,20,i)
+
   ! Send cross section data.
   if( lxs>0 ) then
     write(jtty,*) "master sending cross section data..."
Index: src/nextit.F90
===================================================================
--- src/nextit.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/nextit.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -10,6 +10,7 @@
   use fmesh_mod
   use erprnt_mod
   use entropy_mod
+  use dagmc_mod
 #if defined(VISED) && defined(DEC)
   use c_interfaces
 #endif
@@ -1566,7 +1567,28 @@
       hsrc_auto_mesh = 0
       call entropy_mesh_set_params
     endif
- 
+
+  case( 107 )
+    !  >>>>>  DAGMC parameters                                          dagmc
+    !  Modeled after RAND (99)
+    ! m1c=index of current dagmc keyword.
+    if( m1c == 0 ) then
+      if( index(',=',hitm(1:1))==0 ) then
+        do m1c = 1,4
+          if( hitm(1:14)==hdagmc(m1c) )  return
+        enddo
+        m1c = 0
+      endif
+    else
+      if( index(',=',hitm(1:1))==0 ) then
+        if( m1c==1 .and. ( hitm(1:2) == 'of' .or. hitm(1:2) == 'no') )  dagmc_srcmode = 1 
+        if( m1c==2 .and. ( hitm(1:2) == 'on' .or. hitm(1:2) == 'ye') )  dagmc_usecad = 1
+        if( m1c==3 .and. ( hitm(1:2) == 'on' .or. hitm(1:2) == 'ye') )  dagmc_distlimit = 1
+        if( m1c==4 )  dagmc_tolerance = ritm
+        m1c = 0
+      endif
+    endif
+
   end select
   return
 end subroutine nextit
Index: src/mcnp_params.F90
===================================================================
--- src/mcnp_params.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/mcnp_params.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -128,6 +128,7 @@
   integer,parameter :: iumt = 54        != I/O unit for the mesh tally output file
   integer,parameter :: iuwe = 55        != I/O unit for output WWOUT file.
   integer,parameter :: iuw1 = 56        != I/O unit for output WWONE file.
+  integer,parameter :: iulc = 57        != I/O unit for DAGMC log file
   integer,parameter :: iub  = 60        != I/O unit for bank backup file.
 
   integer,parameter :: uran_mx = 2      != max number of random universe translations
Index: src/hstory.F90
===================================================================
--- src/hstory.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/hstory.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -16,6 +16,7 @@
   use c_interfaces
 #endif
   use fmesh_mod, only: mesh_end_history, mesh_score, nmesh
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   real(dknd)       :: sr(3), sd(3)
@@ -79,7 +80,8 @@
   endif
 
   ! Calculate the distance to the cell boundary, dls.
-   if( lca(icl)<0 ) then
+  ! DAGMC: only do this when running in non-CAD mode
+  if( lca(icl)<0 .and. (isdgmc == 0) ) then
      call chkcel(icl,3,j)
    endif
 50 continue
@@ -90,7 +92,8 @@
     endif
     call expirx(1,'hstory','the weight of the current particle is zero or less.')
   endif
-  call track(icl)
+  ! DAGMC: only call track here if in normal mode (NOT in CAD mode)
+  if (isdgmc == 0) call track(icl)
   if( kdb/=0 )  go to 390
 
   ! Calculate the distance to the nearest dxtran sphere, dxl.
@@ -147,6 +150,14 @@
         ! Sample the distance to collision, pmf, normally.
         pmf = -log(rang())*gs
       else
+        ! DAGMC: In CAD mode, call DAGMC before forcing collision
+        if ( isdgmc == 1 ) then
+           if ( lca(icl) < 0 ) call chkcel(icl,3,j)
+           call setdis(huge_float)
+           call track(icl)
+           if ( kdb /= 0 ) goto 390
+        endif
+         
         ! Force a collision.
         call forcol
         if( kdb/=0  )  go to 390
@@ -160,6 +171,16 @@
   ! Banked uncollided forced collision part comes back here.
   ! 1 mfp mesh-based weight window check survivors come back here.
 90 continue
+
+  ! DAGMC: In CAD mode, get particle information
+  if ( isdgmc == 1 ) then
+     if (lca(icl) < 0) call chkcel(icl,3,j)
+     d = min( pmf, dxl, dtc, deb, dw )
+     call setdis(d)
+     call track(icl)
+     if ( kdb /= 0 ) goto 390
+  endif
+
   d = min( pmf, dls, dxl, dtc, deb, dw )
 
   ! Adjust the weight for exponential transformation.
Index: src/volume.F90
===================================================================
--- src/volume.F90	(.../vendor/5.1.40/Source)	(revision 218)
+++ src/volume.F90	(.../5.1.40/trunk/Source)	(revision 218)
@@ -9,10 +9,17 @@
   use mcnp_input
   use qttyin_mod, only: qttyin
   use erprnt_mod, only: erprnt
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   character(len=23) :: hh
   
+  ! DAGMC: In CAD mode, circumvent most of this function and call DAGMC version
+  if (isdgmc == 1) then
+    call dagmcvolume(mxa,vols,mxj,aras)
+    goto 260
+  endif
+
   ! assume y-axis symmetry to start with.
   bbb(1:4,1:4) = 0.
   bbb(1,1) = 1.

Property changes on: src
___________________________________________________________________
Added: svn:ignore
   + *.mod
mcnp5
mcnp5.mpi


Index: dagmc/mcnp_funcs.h
===================================================================
--- dagmc/mcnp_funcs.h	(.../vendor/5.1.40/Source)	(revision 0)
+++ dagmc/mcnp_funcs.h	(.../5.1.40/trunk/Source)	(revision 218)
@@ -0,0 +1,100 @@
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* initialize DAGMC from FORTRAN main */
+  void dagmcinit_(char *cfile, int *clen,  
+		  char *ftol,  int *ftlen, 
+		  int *parallel_file_mode,
+		  double* dagmc_version, int* moab_version );
+
+/* write facet file after initialization and OBBTree generation */
+  void dagmcwritefacets_(char *ffile, int *flen);
+
+/* parse metadata and write applications specific data for: MCNP5 */
+  void dagmcwritemcnp_(char *lfile, int *llen);
+
+/* get the problem id of the DAGMC guaranteed source cell */
+  void dagmcsrccell_(int *source_cell);
+
+/* Get normal of surface with id *jsu at location (*xxx,*yyy,*zzz) and store
+   in three doubles at ang */
+  void dagmcangl_(int *jsu, double *xxx, double *yyy, double *zzz, double *ang);
+
+
+  void dagmcchkcel_(int *lev,double *uuu,double *vvv,double *www,double *xxx,
+                  double *yyy,double *zzz,double *dls,int *jap,int *jsu,int *icl,
+                  int *iap,int *mxa, int *i1, int *j);
+
+/* Determine distance to nearest surface
+ * *ih - current RefVolume ID
+ * *xxx, *yyy, *zzz - current point
+ * *huge - passed definition of a large number
+ * *dbmin - Output, distance to nearest surface
+ */
+  void dagmcdbmin_( int *ih, 
+                  double *xxx, double *yyy, double *zzz, 
+                  double *huge, double* dbmin);
+
+
+/* Get next Cell
+ * *jap - RefFace ID
+ * *icl - Previous RefVolume ID
+ * *iap - Output, next RefVolume ID or -1 if none
+ * Don't know what the other arguments are for.  We don't use them.
+ */
+  void dagmcnewcel_( int *i1, 
+                   double *d1, double *d2, double *d3, double *d4,
+                   double *d5, double *d6, double *d7,
+                   int *jap, int *i2, int *icl, int *iap, int *mxa);
+
+/* Do ray fire
+ * *ih  - Volume ID to do ray fire against
+ * *jsu - ? (RefFace ID)
+ * *nps - ?
+ * (*uuu,*vvv,*www) - Ray direction vector
+ * (*xxx,*yyy,*zzz) - Ray point
+ * *huge - ?
+ * *dls - output distnace of intersection
+ * *jap - Next intersected surface, or zero if none
+ */
+  void dagmctrack_(int *ih, double *uuu,double *vvv,double *www,double *xxx,
+                 double *yyy,double *zzz,double *huge,double *dls,int *jap,int *jsu,
+                 int *nps);
+
+/* Measure entities
+ * vols - 2xN array where first column contains, as output, measure of every volume.
+ * aras - 2xN array where first column contains, as output, measure of every surface
+ */                        
+  void dagmcvolume_(int* mxa, double* vols, int* mxj, double* aras);
+
+/* Set distance limit */
+  void setdis_(double *d);
+
+/* Return number of surfaces in *mxj */
+  void setnos_(int *mxj);
+
+  void setrsf_(int *ksu);
+
+/* Initialize surface ID vector.
+ * *mxj number of surfaces
+ * *nsfm As output, surface ID list
+ */
+  void setxreflists_(int* mxa, int *ncl, int* mxj, int *nsfm);
+
+  void set_settings_(int* source_cell, int* use_dist_limit,
+                   int* use_cad,     double* distance_tolerance);
+
+  void init_settings_(int* source_cell, int* use_dist_limit,
+		      int* use_cad,     double* distance_tolerance,
+		      double* facet_tol);
+
+  void dagmc_version_(double* dagmcVersion);
+
+  /* Get the corners of the OBB for a given volume ID */
+  void getobb_(int *volID, double minPt[3], double maxPt[3]);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+

Property changes on: dagmc/mcnp_funcs.h
___________________________________________________________________
Added: svn:executable
   + *

Index: dagmc/mcnp_funcs.cpp
===================================================================
--- dagmc/mcnp_funcs.cpp	(.../vendor/5.1.40/Source)	(revision 0)
+++ dagmc/mcnp_funcs.cpp	(.../5.1.40/trunk/Source)	(revision 218)
@@ -0,0 +1,393 @@
+#include "mcnp_funcs.h"
+
+#include "MBInterface.hpp"
+#include "MBRange.hpp"
+#include "MBOrientedBoxTreeTool.hpp"
+#include "MBCartVect.hpp"
+#include "MBTagConventions.hpp"
+
+#include "DagMC.hpp"
+using moab::DagMC;
+
+#include <limits>
+#include <iostream>
+#include <algorithm>
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+  // globals
+
+#define DAG DagMC::instance()
+
+#define DGFM_SEQ   0
+#define DGFM_READ  1
+#define DGFM_BCAST 2
+
+#ifdef ENABLE_RAYSTAT_DUMPS
+
+#include <fstream>
+#include <numeric>
+
+static std::ostream* raystat_dump = NULL;
+
+#endif 
+
+
+void dagmcinit_(char *cfile, int *clen,  // geom
+                char *ftol,  int *ftlen, // faceting tolerance
+                int *parallel_file_mode, // parallel read mode
+                double* dagmc_version, int* moab_version )
+{
+ 
+  MBErrorCode rval;
+
+#ifdef ENABLE_RAYSTAT_DUMPS
+  // the file to which ray statistics dumps will be written
+  raystat_dump = new std::ofstream("dagmc_raystat_dump.csv");
+#endif 
+  
+  *dagmc_version = DAG->version();
+  *moab_version = DAG->interface_revision();
+  
+    // terminate all filenames with null char
+  cfile[*clen] = ftol[*ftlen] = '\0';
+
+    // initialize this as -1 so that DAGMC internal defaults are preserved
+    // user doesn't set this
+  double arg_facet_tolerance = -1;
+                                                                        
+  if ( *ftlen > 0 ) arg_facet_tolerance = atof(ftol);
+  
+  // read geometry
+  rval = DAG->load_file(cfile, arg_facet_tolerance );
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC failed to read input file: " << cfile << std::endl;
+    exit(EXIT_FAILURE);
+  }
+ 
+    // initialize geometry
+  rval = DAG->init_OBBTree();
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC failed to initialize geometry and create OBB tree" <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+}
+
+void dagmcwritefacets_(char *ffile, int *flen)  // facet file
+{
+    // terminate all filenames with null char
+  ffile[*flen]  = '\0';
+
+  MBErrorCode rval = DAG->write_mesh(ffile,*flen);
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC failed to write mesh file: " << ffile <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  return;
+
+}
+
+
+
+void dagmcwritemcnp_(char *lfile, int *llen)  // file with cell/surface cards
+                     
+{
+  MBErrorCode rval;
+
+  lfile[*llen]  = '\0';
+
+  // parse data from geometry
+  rval = DAG->parse_metadata();
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC failed to parse metadata" <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  std::string lfname(lfile, *llen);
+  // only overwrite mcnp log file if lfname==lcad, that is lfname.compare("lcad") == 0
+  rval = DAG->write_mcnp(lfname, lfname.compare("lcad") == 0);
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC failed to write mcnp file: " << lfile <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+}
+
+void dagmcsrccell_(int *source_cell)
+{
+  *source_cell = DAG->source_cell();
+}
+
+void dagmcangl_(int *jsu, double *xxx, double *yyy, double *zzz, double *ang)
+{
+  MBEntityHandle surf = DAG->entity_by_index( 2, *jsu );
+  MBErrorCode rval = DAG->get_angle(surf, *xxx, *yyy, *zzz, ang);
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC: failed in calling get_angle" <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+}
+
+
+void dagmcchkcel_(int *lev,double *uuu,double *vvv,double *www,double *xxx,
+                double *yyy,double *zzz,double *dls,int *jap,int *jsu,int *icl,
+                int *iap,int *mxa,
+                int *i1, int *j)
+{
+
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout<< " " << std::endl;
+  std::cout<< "chkcel: vol=" << DAG->id_by_index(3,*i1) << " xyz=" << *xxx 
+           << " " << *yyy << " " << *zzz << std::endl;
+#endif
+
+  int inside;
+  MBEntityHandle vol = DAG->entity_by_index( 3, *i1 );
+  MBErrorCode rval = DAG->point_in_volume( vol, *xxx, *yyy, *zzz, inside, 
+                                                *uuu, *vvv, *www );
+
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC: failed in point_in_volume" <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  if (MB_SUCCESS != rval) *j = -2;
+  else
+    switch (inside)
+      {
+      case 1: 
+	*j = 0; // inside==  1 -> inside volume -> j=0
+	break;
+      case 0:
+	*j = 1; // inside== 0  -> outside volume -> j=1
+	break;
+      case -1:
+	*j = 1; // inside== -1 -> on boundary -> j=1 (assume leaving volume)
+	break;
+      }
+  
+#ifdef TRACE_DAGMC_CALLS
+  std::cout<< "chkcel: j=" << *j << std::endl;
+#endif
+
+}
+
+
+void dagmcdbmin_( int *ih, double *xxx, double *yyy, double *zzz, double *huge, double* dbmin)
+{
+  double point[3] = {*xxx, *yyy, *zzz};
+
+  // get handle for this volume (*ih)
+  MBEntityHandle vol  = DAG->entity_by_index( 3, *ih );
+
+  // get distance to closest surface
+  MBErrorCode rval = DAG->closest_to_location(vol,point,*dbmin);
+
+  // if failed, return 'huge'
+  if (MB_SUCCESS != rval) {
+    *dbmin = *huge;
+    std::cerr << "DAGMC: error in closest_to_location, returning huge value from dbmin_" <<  std::endl;
+  }
+
+}
+
+void dagmcnewcel_( int *i1, 
+                 double *d1, double *d2, double *d3, double *d4,
+                 double *d5, double *d6, double *d7,
+                 int *jap, int *i2, int *icl, int *iap, int *mxa)
+{
+
+  MBEntityHandle surf = DAG->entity_by_index( 2, *jap );
+  MBEntityHandle vol  = DAG->entity_by_index( 3, *icl );
+  
+  std::vector<MBEntityHandle> parents;
+  MBErrorCode rval = DAG->moab_instance()->get_parent_meshsets( surf, parents );
+
+  if (MB_SUCCESS != rval) {
+    *iap = -1;
+    std::cerr << "DAGMC: error calling get_parent_meshsets, newcel_ returning -1" << std::endl;
+  }
+  else if (parents.size() != 2) {
+    *iap = -1;
+    std::cerr << "DAGMC: mesh error in newcel_, returning -1" << std::endl;
+  }
+  else if (parents.front() == vol) {
+    *iap = DAG->index_by_handle( parents.back() );
+  }
+  else {
+    assert(parents.back() == vol);
+    *iap = DAG->index_by_handle( parents.front() );
+  }
+
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout<< "newcel: prev_vol=" << DAG->id_by_index(3,*icl) << " surf= " 
+           << DAG->id_by_index(2,*jap) << " next_vol= " << DAG->id_by_index(3,*iap) <<std::endl;
+
+#endif
+}
+
+// *ih              - volue index
+// *uuu, *vvv, *www - ray direction
+// *xxx, *yyy, *zzz - ray point
+// *huge            - passed to ray_fire as 'huge'
+// *dls             - output from ray_fire as 'dist_traveled'
+// *jap             - intersected surface index, or zero if none
+// *jsu             - previous surface index
+// *nps             - ????????
+void dagmctrack_(int *ih, double *uuu,double *vvv,double *www,double *xxx,
+               double *yyy,double *zzz,double *huge,double *dls,int *jap,int *jsu,
+               int *nps)
+{
+    // Get data from IDs
+  MBEntityHandle vol = DAG->entity_by_index( 3, *ih );
+  MBEntityHandle prev = DAG->entity_by_index( 2, *jsu );
+  MBEntityHandle next_surf = 0;
+  
+
+#ifdef ENABLE_RAYSTAT_DUMPS
+  moab::OrientedBoxTreeTool::TrvStats trv;
+#endif 
+
+  MBErrorCode result = DAG->ray_fire(vol, prev, *nps, *uuu, *vvv, *www, 
+                                     *xxx, *yyy, *zzz, *huge, *dls, next_surf
+#ifdef ENABLE_RAYSTAT_DUMPS
+				     , raystat_dump ? &trv : NULL 
+#endif
+				     );
+
+  
+  if(MB_SUCCESS != result){
+    std::cerr << "DAGMC: failed in ray_fire" << std::endl;
+    exit( EXIT_FAILURE );
+  }
+
+    // return results
+  *jap = (next_surf ? DAG->index_by_handle(next_surf) : 0);
+  
+#ifdef ENABLE_RAYSTAT_DUMPS
+  if( raystat_dump ){
+
+    *raystat_dump << *ih << ",";
+    *raystat_dump << trv.ray_tri_tests() << ",";
+    *raystat_dump << std::accumulate( trv.nodes_visited().begin(), trv.nodes_visited().end(), 0 ) << ",";
+    *raystat_dump << std::accumulate( trv.leaves_visited().begin(), trv.leaves_visited().end(), 0 ) << std::endl;
+
+  }
+#endif 
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout<< "track: vol=" << DAG->id_by_index(3,*ih) << " prev_surf=" << DAG->id_by_index(2,*jsu) 
+           << " next_surf=" << DAG->id_by_index(2,*jap) << " nps=" << *nps <<std::endl;
+  std::cout<< "     : xyz=" << *xxx << " " << *yyy << " " << *zzz <<std::endl;
+#endif
+
+}
+
+void dagmcvolume_(int* mxa, double* vols, int* mxj, double* aras)
+{
+  MBErrorCode rval;
+  
+    // get size of each volume
+  int num_vols = DAG->num_entities(3);
+  for (int i = 0; i < num_vols; ++i) {
+    rval = DAG->measure_volume( DAG->entity_by_index(3, i+1), vols[i*2] );
+    if( MB_SUCCESS != rval ){
+      std::cerr << "DAGMC: could not measure volume " << i+1 << std::endl;
+      exit( EXIT_FAILURE );
+    }
+  }
+  
+    // get size of each surface
+  int num_surfs = DAG->num_entities(2);
+  for (int i = 0; i < num_surfs; ++i) {
+    rval = DAG->measure_area( DAG->entity_by_index(2, i+1), aras[i*2] );
+    if( MB_SUCCESS != rval ){
+      std::cerr << "DAGMC: could not measure surface " << i+1 << std::endl;
+      exit( EXIT_FAILURE );
+    }
+  }
+
+}
+
+void setdis_(double *d)
+{
+  DAG->distance_limit(*d);
+}
+
+void setnos_( int* mxj )
+{
+  *mxj = DAG->num_entities(2);
+}
+
+void setrsf_( int* ksu )
+{
+  static const void * const refl_strs[] = { DAG->get_spec_reflect(), 
+                                            DAG->get_white_reflect() };
+  static const MBTag tag = DAG->name_tag();
+
+  MBErrorCode rval;
+
+  for (int refl_type=0;refl_type<2;refl_type++) {
+    MBRange surfs;
+    rval = DAG->moab_instance()->
+      get_entities_by_type_and_tag( 0, MBENTITYSET, &tag, refl_strs + refl_type, 1, surfs );
+    
+    if( MB_SUCCESS != rval ){
+      std::cerr << "DAGMC: trouble in setrfs_" << std::endl;
+    }
+
+    for (MBRange::const_iterator i = surfs.begin(); i != surfs.end(); ++i) {
+      int srfNum = DAG->index_by_handle( *i );
+        // remember that srfNum 1-based index but ksu is currently being accessed
+        // as a 0-based array.
+      ksu[srfNum-1] = -(refl_type+1);
+    }
+  }
+}  
+
+void setxreflists_(int* mxa, int *ncl, int* mxj, int *nsfm)
+{
+    // initialize surface id vector
+  for (int jsu=1;jsu<=*mxj;jsu++)
+    nsfm[jsu-1] = DAG->id_by_index( 2, jsu );
+}
+
+
+void set_settings_(int* source_cell, int* use_dist_limit,
+		   int* use_cad,     double* distance_tolerance)
+{
+
+  DAG->set_settings(*source_cell, *use_cad, *use_dist_limit, 
+		    (*distance_tolerance)*100, *distance_tolerance);
+
+}
+
+void init_settings_(int* source_cell, int* use_dist_limit,
+		    int* use_cad,     double* distance_tolerance,
+		    double* facet_tol)
+{
+
+  DAG->get_settings(source_cell, use_cad, use_dist_limit, distance_tolerance, facet_tol);
+
+}
+
+void dagmc_version_(double* dagmcVersion)
+{
+  *dagmcVersion = DAG->version();
+}
+
+void getobb_(int *volID, double minPt[3], double maxPt[3])
+{
+    MBEntityHandle vol = DAG->entity_by_id( 3, *volID );
+    MBErrorCode rval = DAG->getobb( vol, minPt, maxPt); 
+    if (MB_SUCCESS != rval) {
+      std::cerr << "Failed to get OBB for volume " << *volID << std::endl;
+      return;
+    }
+}

Property changes on: dagmc/mcnp_funcs.cpp
___________________________________________________________________
Added: svn:executable
   + *

Index: Makefile
===================================================================
--- Makefile	(.../vendor/5.1.40/Source)	(revision 218)
+++ Makefile	(.../5.1.40/trunk/Source)	(revision 218)
@@ -19,7 +19,7 @@
 CONFIG_DIR  = ./config
 
 ifneq (,$(premake))
-  CONFIG = $(menup) $(menuproc) $(menub) $(debug) $(menuf90) $(menucc) $(MPI)
+  CONFIG = $(menup) $(menudag) $(menuproc) $(menub) $(debug) $(menuf90) $(menucc) $(MPI)
   export
 else
   -include  $(CONFIG_DIR)/custom_$(OS).gcf
