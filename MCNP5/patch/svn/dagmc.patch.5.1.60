
Property changes on: datasrc
___________________________________________________________________
Added: svn:ignore
   + makxsf
*.mod




Property changes on: dotcomm/src
___________________________________________________________________
Added: svn:ignore
   + *.mod


Index: config/Linux.gcf
===================================================================
--- config/Linux.gcf	(.../vendor/5.1.60/Source)	(revision 424)
+++ config/Linux.gcf	(.../5.1.60/trunk/Source)	(revision 424)
@@ -735,0 +736 @@
+CXXFLAGS = $(CFLAGS)
@@ -778,0 +780,32 @@
+
+# --- DAGMC option.
+DAGMC_MOD=
+
+ifeq (dagmc,$(filter dagmc,$(CONFIG)))
+
+  ifeq (,$(premake)) 
+    include $(MOAB_DIR)/lib/moab.make   
+    CUBIT_LINK_PATH=$(CUBIT_DIR)
+  else
+    include $(menudagpath)/lib/moab.make
+    CUBIT_LINK_PATH=$(menucubitpath)
+  endif
+
+  ifneq (,$(CUBIT_LINK_PATH))
+    # Cubit-based MOAB build specified; ensure library paths work
+    DAGMC_CFLAGS += -DCUBIT_LIBS_PRESENT
+    MOAB_LDFLAGS += -Wl,-rpath=$(CUBIT_LINK_PATH)
+  endif
+
+  CPP_FLAGS += $(MOAB_CPPFLAGS)
+  CXXFLAGS += $(MOAB_CXXFLAGS) $(DAGMC_CFLAGS) 
+  INCLUDES += $(MOAB_INCLUDES)
+  LDFLAGS = $(MOAB_LDFLAGS) $(CXX_FORTRAN_LDFLAGS) 
+
+  DAGMC_LIBS += $(MOAB_LIBS_LINK) -ldagmc -lstdc++
+
+  DAGMC_MOD=  dagmc_mod$(OBJF)
+
+endif
+# ---END DAGMC OPTIONS-------------------
+
Index: config/Makefile
===================================================================
--- config/Makefile	(.../vendor/5.1.60/Source)	(revision 424)
+++ config/Makefile	(.../5.1.60/trunk/Source)	(revision 424)
@@ -33,0 +34,6 @@
+	@ $(ECHO) '# --- DAGMC Option ---' >> "$(custfile)"
+	@ $(ECHO) 'menudagmc='$(menudagmc) >> "$(custfile)"
+	@ $(ECHO) '# --- DAGMC library path ---' >> "$(custfile)"
+	@ $(ECHO) 'menudagpath='$(menudagpath) >> "$(custfile)"
+	@ $(ECHO) '# --- Cubit binary path ---' >> "$(custfile)"
+	@ $(ECHO) 'menucubitpath='$(menucubitpath) >> "$(custfile)"
Index: src/namchg.F90
===================================================================
--- src/namchg.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/namchg.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -8,0 +9 @@
+  use dagmc_mod
@@ -12 +13,4 @@
-  if( mm==2 ) then
+  ! DAGMC: Need to change some of these conditionals, no bounding
+  !        surfaces exist in CAD mode, handle as regular surface
+
+  if( ( mm==2 ) .or. ( ( mm == 3) .and. ( isdgmc == 1 ) ) ) then
@@ -17 +21 @@
-  elseif( mm==3 ) then
+  elseif( ( mm==3 ) .and. ( isdgmc == 0 ) ) then
Index: src/angl.F90
===================================================================
--- src/angl.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/angl.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -11,0 +12 @@
+  use dagmc_mod
@@ -15,0 +17,7 @@
+
+  ! DAGMC: In CAD mode, circumvent entire function and call DAGMC version instead
+  if (isdgmc == 1) then
+     call dagmcangl(jsu,xxx,yyy,zzz,ang)
+     angl=max(-one,min(one,ang(1)*uuu+ang(2)*vvv+ang(3)*www))
+     return
+  endif
Index: src/pass1.F90
===================================================================
--- src/pass1.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/pass1.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -13,0 +14 @@
+  use dagmc_mod
@@ -15,0 +17,3 @@
+
+  ! DAGMC: For CAD mode, read cell/surface cards from log file
+  if ( isdgmc == 1) call lcadrd
Index: src/mcnp_iofiles.F90
===================================================================
--- src/mcnp_iofiles.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/mcnp_iofiles.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -37 +37,5 @@
-    &  dumn2   
+    &  dumn2   , &
+    &  gcad    , &  != DAGMC geometry input file (CAD or facets)
+    &  lcad    , &  != DAGMC input log file
+    &  fcad    , &  != DAGMC facets output file
+    &  ftol         != DAGMC faceting tolerance
@@ -77,0 +82,4 @@
+    gcad    = isub(19)
+    lcad    = isub(20)
+    fcad    = isub(21)
+    ftol    = isub(22)
@@ -105,0 +114,4 @@
+      gcad(i:i)   = ' '
+      lcad(i:i)   = ' '
+      fcad(i:i)   = ' '
+      ftol(i:i)   = ' '
@@ -129,0 +142,4 @@
+    msub(19)(1:8) = 'gcad    '
+    msub(20)(1:8) = 'lcad    '
+    msub(21)(1:8) = 'fcad    '
+    msub(22)(1:8) = 'ftol    '
Index: src/dagmc_mod.F90
===================================================================
--- src/dagmc_mod.F90	(.../vendor/5.1.60/Source)	(revision 0)
+++ src/dagmc_mod.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,254 @@
+module dagmc_mod
+
+  use mcnp_params
+  use pblcom, only: mpb
+
+  integer, parameter, public :: & ! named constant for file distribution mode
+     & DGFM_SEQ   = 0, &
+     & DGFM_READ  = 1, & 
+     & DGFM_BCAST = 2 
+
+  integer, save :: isdgmc 
+
+  integer, save :: dagmc_geom_file_mode = DGFM_SEQ  ! default to a distributed read
+
+  integer, save :: dagmc_srcmode = 0
+  integer, save :: dagmc_usecad  = 0
+  integer, save :: dagmc_distlimit = 0
+  
+  real(dknd), save :: dagmc_facet_tol
+  real(dknd), save :: dagmc_overlap_thickness
+  real(dknd), save :: dagmc_version
+  
+  integer, save :: dagmc_subversion
+
+  public :: &
+    &   lcadrd, &        ! read log file information
+    &   dagmc_msgput, &  ! share dagmc settings to slave tasks
+    &   dagmc_msgget    ! receive dagmc settings from master task
+
+contains
+
+  subroutine lcadrd
+    ! Description:
+    ! Reads in the CAD log file and "inserts" it at the header
+    ! of the input file.
+    
+    ! >>>>> Modules used
+    use mcnp_global
+    use mcnp_params
+    use mcnp_iofiles
+    
+    ! >>>>> Implict declaration of real variables as doubles
+    implicit real(dknd) (a-h,o-z)
+    
+    ! >>>>> Other variables
+    character(len=80)  :: hk          ! Character for line of file being read
+    integer, parameter :: ie = 70     ! I/O index of a scratch file
+    integer            :: it, iu = 0  ! Indices for nxtsym function
+    integer            :: ios = 0     ! IOSTAT for file reading
+    
+    ! >>>>> Initialize the scratch file and get to beginning of input file
+    open(ie,status='scratch')
+    rewind iui
+    
+    ! >>>>> Check if first line is message block, otherwise assume a title card
+    read(iui,'(a80)',end=1000) hk
+    call nxtsym(hk,' ',1,it,iu,1)
+    
+    if (hk(it:iu) == 'message:') then
+       ! Message block exists, read until blank line found
+       do
+          read(iui,'(a80)',end=1000) hk   ! Read in string: exception for eof
+          if (hk == ' ') exit             ! Terminate loop once blank line found 
+       enddo
+       ! Read in title card, for message block case
+       read(iui,'(a80)',end=1000) hk
+    endif
+    
+    ! Write title card to scratch file
+    write(ie,'(a80)') hk
+    
+    ! >>>>> Read in cell/surface cards from log
+    rewind iulc
+    do
+       read(iulc, '(a80)', iostat=ios) hk
+       
+       ! Check for end of file or errors
+       if (ios == 0) then
+          write(ie,'(a80)') hk     ! Write the line normally
+       elseif (ios < 0) then
+          exit                     ! Break loop at EOF
+       else
+          goto 2000                ! Exception for severe I/O error
+       endif
+    enddo
+    
+    ! >>>> Read in rest of input file
+    ios = 0
+    do
+       read(iui, '(a80)', iostat = ios) hk
+       
+       ! Check for end of file or errors
+       if (ios == 0) then
+          write(ie,'(a80)') hk     ! Write the line to scratch file
+       elseif (ios < 0) then
+          exit                     ! Break loop at EOF
+       else
+          goto 3000                ! Exception for severe I/O error
+       endif
+    enddo
+    
+    ! >>>>> Echo back to new scratch input file
+    close(iui)
+    rewind ie
+    open(iui,status='scratch')
+    ios = 0
+    do      
+       read(ie, '(a80)', iostat = ios) hk
+       
+       ! Check for end of file or errors
+       if (ios == 0) then
+          write(iui,'(a80)') hk    ! Write the line in the scratch input file
+       elseif (ios < 0) then
+          exit                     ! Break loop at EOF
+       else
+          goto 4000                ! Exception for severe I/O error
+       endif
+       
+    enddo
+    
+    ! >>>>> Finish up
+    rewind iui
+    ! pass1 expects iui to be advanced beyond the title card, 
+    ! so read past the first line now
+    read(iui, '(a)')
+
+    close(ie)
+    return
+    
+    ! >>>>> Exceptions
+    ! End of File at header of input file
+1000 call expire(0,'lcadrd','unexpected eof in file '//inp)
+    return
+    ! Severe I/O error during reading of CAD log
+2000 call expire(0,'lcadrd','error during read of file '//lcad)
+    return
+    ! Severe I/O error during reading of CAD log
+3000 call expire(0,'lcadrd','error during read of file '//inp)
+    return
+    ! Severe I/O error during echo of scratch file to new input file
+4000 call expire(0,'lcadrd','error stitching input and CAD log')
+    return
+    
+  end subroutine lcadrd
+
+  subroutine dagmc_msgput
+
+    use messages, only : msg_put
+    use mcnp_iofiles, only: gcad, ftol
+    use fixcom, only : ntal
+    use mcnp_debug
+
+    call msg_put (isdgmc)
+    call msg_put (dagmc_geom_file_mode)
+    call msg_put (gcad)
+    call msg_put (ftol)
+    call msg_put (dagmc_srcmode)
+    call msg_put (dagmc_usecad)
+    call msg_put (dagmc_distlimit)
+    call msg_put (dagmc_overlap_thickness)
+    call msg_put (dagmc_facet_tol)
+    call msg_put (dagmc_version)
+
+  end subroutine dagmc_msgput
+
+  subroutine dagmc_msgget
+   
+    use messages, only : msg_get
+    use mcnp_iofiles, only: gcad, ftol
+    use fixcom, only : ntal
+    use mcnp_debug
+
+    implicit none
+
+    real(dknd) :: master_dagmc_version
+
+    call msg_get (isdgmc)
+    call msg_get (dagmc_geom_file_mode)
+    call msg_get (gcad)
+    call msg_get (ftol)
+    call msg_get (dagmc_srcmode)
+    call msg_get (dagmc_usecad)
+    call msg_get (dagmc_distlimit)
+    call msg_get (dagmc_overlap_thickness)
+    call msg_get (dagmc_facet_tol)
+    call msg_get (master_dagmc_version)
+
+    if ( isdgmc == 1 ) then
+       call dagmcinit(gcad//char(0),len_trim(gcad),      &
+          &           ftol//char(0),len_trim(ftol),      &
+          &           dagmc_geom_file_mode, dagmc_version, dagmc_subversion, mpb )
+       if (dagmc_version /= master_dagmc_version) then
+          ! errprt and fail!
+       end if
+       call dagmc_set_settings(dagmc_distlimit, dagmc_usecad, dagmc_overlap_thickness, dagmc_srcmode )
+    end if
+
+  end subroutine dagmc_msgget
+  
+  subroutine init_dagmc
+
+     use mcnp_iofiles
+
+     ! Check to see if the CAD file exists, if not, abort
+     inquire( file = gcad, exist = file_exists)
+     if (.not.file_exists) then
+        call expire(0,'main','CAD geometry file '//gcad// &
+             &            ' does not exist.')
+     endif
+     
+     ! initialize DAGMC, read geometry and initialize OBBTree
+     call dagmcinit(gcad//char(0),len_trim(gcad),      &
+          &         ftol//char(0),len_trim(ftol),      &
+          &         dagmc_geom_file_mode,dagmc_version, dagmc_subversion, mpb )
+
+
+     call dagmc_init_settings(dagmc_distlimit, dagmc_usecad, &
+                              dagmc_overlap_thickness, dagmc_facet_tol, dagmc_srcmode)
+
+     ! print version number message to terminal
+     call dagmc_version_heading(jtty)
+
+     ! write mesh file if requested
+     if ( len_trim(fcad) .gt. 0) then
+        call dagmcwritefacets(fcad//char(0),len_trim(fcad))     
+     endif
+
+
+     ! parse metadata and write input cards
+     call dagmcwritemcnp(lcad//char(0), len_trim(lcad))
+     
+     ! Check to ensure that the log file is written
+     inquire( file = lcad, exist = file_exists)
+     if (.not.file_exists) then
+        call expire(0,'main','CAD list file '//lcad// &
+             &             ' not written by DAGMC.')
+     endif
+     
+     ! Open the cad log file on the MCNP side
+     open( unit=iulc, file=lcad, status='old' )
+
+  end subroutine init_dagmc
+
+  ! write DagMC version number message to given file
+  subroutine dagmc_version_heading(o)
+    
+    integer :: o 
+
+     write(o,150) dagmc_version, dagmc_subversion
+150  format(1x,'This problem is using DAGMC version ',f8.3,' w/ DagMC r', i4)
+
+  end subroutine dagmc_version_heading
+
+end module dagmc_mod

Property changes on: src/dagmc_mod.F90
___________________________________________________________________
Added: svn:executable
   + *

Index: src/sourcb.F90
===================================================================
--- src/sourcb.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/sourcb.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -9 +9,2 @@
- 
+  use dagmc_mod
+
@@ -517 +518,6 @@
-      call chkcel(ji,0,j)
+      ! DAGMC: if dagmc_srcmode is on, skip chkcel and assume particle is in user-specified cell
+      if( isdgmc==1 .and. dagmc_srcmode==1 ) then 
+         j = 0
+      else
+         call chkcel(ji,0,j)
+      endif
Index: src/savpar.F90
===================================================================
--- src/savpar.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/savpar.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -11,0 +12 @@
+  use dagmc_mod
@@ -18,0 +20,6 @@
+
+  ! DAGMC: save this particle's ray history
+  if (isdgmc == 1) then 
+     call dagmc_savpar(n)
+  endif
+
Index: src/bankit.F90
===================================================================
--- src/bankit.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/bankit.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -12,0 +13 @@
+  use dagmc_mod
@@ -53,0 +55,5 @@
+    ! DAGMC: 
+    if ( isdgmc == 1 ) then    
+       call dagmc_bank_push( nbnk )
+    endif
+
@@ -183,0 +190,6 @@
+
+    ! DAGMC: 
+    if ( isdgmc == 1 ) then    
+       call dagmc_bank_usetop(  )
+    endif
+
@@ -259,0 +272,4 @@
+       ! DAGMC: 
+       if ( isdgmc == 1 ) then    
+          call dagmc_bank_pop( nbnk  )
+       endif
Index: src/celsrf.F90
===================================================================
--- src/celsrf.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/celsrf.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -12,0 +13 @@
+  use dagmc_mod
@@ -314,0 +316,4 @@
+     
+    ! DAGMC: Skip tihs loop if in CAD mode
+     if (isdgmc == 1) exit
+
Index: src/Makefile
===================================================================
--- src/Makefile	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/Makefile	(.../5.1.60/trunk/Source)	(revision 424)
@@ -12 +12 @@
-#    DEF_MACH,  DEF_PLOT,  DEF_SMMP,  DEF_DMMP
+#    DEF_MACH,  DEF_PLOT,  DEF_DAGMC, DEF_SMMP,  DEF_DMMP
@@ -15,0 +16 @@
+#    MOAB_DIR
@@ -80 +81 @@
-DEFS    = $(DEF_CODEINFO) $(DEF_MACH) $(DEF_PLOT) $(DEF_SMMP) $(DEF_DMMP) $(DMMP_NAME) 
+DEFS    = $(DEF_CODEINFO) $(DEF_MACH) $(DEF_PLOT) $(DEF_DAGMC) $(DEF_SMMP) $(DEF_DMMP) $(DMMP_NAME) 
@@ -85 +86 @@
-# Defined in FILE.list:  F_SRC, F_OBJS, C_SRC, C_OBJS
+# Defined in FILE.list:  F_SRC, F_OBJS, C_SRC, C_OBJS, CXX_SRC, CXX_OBJS
@@ -94,2 +95,2 @@
-LIBS	= $(PLOTLIBS)  $(LIB_DMMP) $(EXTRALIBS) 
-INCLUDES= -I.  $(INC_DMMP)  $(INCLUDE_DIRS) 
+LIBS	  = $(PLOTLIBS)  $(LIB_DMMP) $(EXTRALIBS) $(DAGMC_LIBS) 
+INCLUDES += -I.  $(INC_DMMP)  $(INCLUDE_DIRS) 
@@ -101,0 +103 @@
+  ALL_CXXFLAGS  = $(CPPFLAGS) $(INCLUDES) $(CXXFLAGS)
@@ -107,0 +110 @@
+  ALL_CXXFLAGS  = $(CPPFLAGS) $(INCLUDES) $(CXXFLAGS)
@@ -116 +119 @@
-$(EXEC):   $(F_OBJS) $(C_OBJS) 
+$(EXEC):   $(F_OBJS) $(C_OBJS) $(CXX_OBJS)
@@ -118 +121 @@
-	@ $(LD)  $(OUT)$(EXEC) $(F_OBJS) $(C_OBJS) $(ALL_LDFLAGS); \
+	@ $(LD)  $(OUT)$(EXEC) $(F_OBJS) $(C_OBJS) $(CXX_OBJS) $(ALL_LDFLAGS); \
@@ -128 +131 @@
-	@ $(RM) -f $(F_OBJS) $(C_OBJS) ./*$(OBJF)
+	@ $(RM) -f $(F_OBJS) $(C_OBJS) $(CXX_OBJS) ./*$(OBJF) ../dagmc/*$(OBJC)
@@ -133 +136 @@
-	@ $(RM) -f $(F_OBJS) $(C_OBJS) ./*$(OBJF)
+	@ $(RM) -f $(F_OBJS) $(C_OBJS) $(CXX_OBJS) ./*$(OBJF) ../dagmc/*$(OBJC)
@@ -149 +152 @@
-.SUFFIXES:      .F90    .c      $(OBJF)		$(OBJC)		$(I)	.a
+.SUFFIXES:      .F90    .c	.cpp	 $(OBJF)	$(OBJC)		$(I)	.a
@@ -163,0 +167,7 @@
+
+%$(OBJC) : %.cpp
+	$(ECHO) "--- $@ ---"
+  ifeq (1,$(scr_trace))
+	$(ECHO) "$(CXX) $(ALL_CXXFLAGS) -c -o $@ $<"
+  endif
+	$(CXX) $(ALL_CXXFLAGS) -c -o $@ $<
Index: src/track.F90
===================================================================
--- src/track.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/track.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -14,0 +15 @@
+  use dagmc_mod
@@ -25,0 +27,9 @@
+
+  ! DAGMC: If in CAD mode, call DAGMC version of track instead
+  if ( isdgmc == 1 ) then    
+    call dagmctrack(ih,uuu,vvv,www,xxx,yyy,zzz,huge_float,dls, &
+     &               jap,jsu,nps)
+    if ( dls == huge_float ) kdb = 2
+    return
+  endif
+
Index: src/Depends
===================================================================
--- src/Depends	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/Depends	(.../5.1.60/trunk/Source)	(revision 424)
@@ -21 +21 @@
-angl$(OBJF)   : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+angl$(OBJF)   : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -46 +46 @@
-		erprnt$(OBJF)
+		erprnt$(OBJF) $(DAGMC_MOD)
@@ -54 +54 @@
-chkcel$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+chkcel$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -72 +72 @@
-dbmin$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+dbmin$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -88 +88,2 @@
-		dxtran_mod$(OBJF)  mcnp_landau$(OBJF) eventp$(OBJF)
+		dxtran_mod$(OBJF)  mcnp_landau$(OBJF) eventp$(OBJF) \
+		$(DAGMC_MOD)
@@ -141 +142 @@
-		phtvr_mod$(OBJF) 
+		phtvr_mod$(OBJF) $(DAGMC_MOD)
@@ -143 +144 @@
-		erprnt$(OBJF)
+		erprnt$(OBJF) $(DAGMC_MOD)
@@ -146 +147 @@
-		fmesh_mod$(OBJF) rmc_mod$(OBJF) mcnp_debug$(OBJF)
+		fmesh_mod$(OBJF) rmc_mod$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -163 +164,2 @@
-		fmesh_mod$(OBJF) phtvr_mod$(OBJF) erprnt$(OBJF) dynamic_arrays$(OBJF)
+		fmesh_mod$(OBJF) phtvr_mod$(OBJF) erprnt$(OBJF) dynamic_arrays$(OBJF) \
+        $(DAGMC_MOD)
@@ -191 +193 @@
-		mcnp_debug$(OBJF)
+		mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -232 +234 @@
-namchg$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+namchg$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -237 +239 @@
-newcel$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+newcel$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -241 +243,2 @@
-		fmesh_mod$(OBJF) mcnp_debug$(OBJF) phtvr_mod$(OBJF) erprnt$(OBJF)
+		fmesh_mod$(OBJF) mcnp_debug$(OBJF) phtvr_mod$(OBJF) erprnt$(OBJF)  \
+		$(DAGMC_MOD)
@@ -252 +255 @@
-		fmesh_mod$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF)
+		fmesh_mod$(OBJF) mcnp_debug$(OBJF) erprnt$(OBJF) $(DAGMC_MOD)
@@ -256 +259,2 @@
-pass1$(OBJF)  : mcnp_global$(OBJF) dynamic_arrays$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF)
+pass1$(OBJF)  : mcnp_global$(OBJF) dynamic_arrays$(OBJF) mcnp_input$(OBJF) mcnp_debug$(OBJF) \
+		$(DAGMC_MOD)
@@ -342 +346 @@
-sourcb$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+sourcb$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -366 +370 @@
-tally$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+tally$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -383,2 +387,2 @@
-track$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF) qttyin$(OBJF)
-transm$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF)
+track$(OBJF)  : mcnp_global$(OBJF) mcnp_debug$(OBJF) qttyin$(OBJF) $(DAGMC_MOD)
+transm$(OBJF) : mcnp_global$(OBJF) mcnp_debug$(OBJF) $(DAGMC_MOD)
@@ -403 +407 @@
-		erprnt$(OBJF)
+		erprnt$(OBJF) $(DAGMC_MOD)
@@ -462,0 +467,17 @@
+endif
+#
+# DagMC objects
+ifneq (,$(DAGMC_MOD))
+dagmc_mod$(OBJF) : mcnp_global$(OBJF) messages$(OBJF)
+../dagmc/mcnp_funcs$(OBJC) : ../dagmc/mcnp_funcs.h 
+../dagmc/meshtal_funcs$(OBJC): ../dagmc/mcnp_funcs.h ../dagmc/MeshTally.hpp \
+                               ../dagmc/TrackLengthMeshTally.hpp ../dagmc/KDEMeshTally.hpp
+../dagmc/TrackLengthMeshTally$(OBJC): ../dagmc/MeshTally.hpp ../dagmc/Matrix3.hpp \
+                                      ../dagmc/TrackLengthMeshTally.hpp
+../dagmc/KDEKernel$(OBJC): ../dagmc/KDEKernel.hpp
+../dagmc/KDECollision$(OBJC): ../dagmc/KDECollision.hpp ../dagmc/KDEKernel.hpp 
+../dagmc/KDETrack$(OBJC): ../dagmc/KDETrack.hpp ../dagmc/KDEKernel.hpp
+../dagmc/KDEMeshTally$(OBJC): ../dagmc/KDEMeshTally.hpp ../dagmc/MeshTally.hpp \
+                              ../dagmc/KDECollision.hpp ../dagmc/KDEKernel.hpp \
+                              ../dagmc/KDETrack.hpp 
+../dagmc/MeshTally$(OBJC): ../dagmc/MeshTally.hpp
Index: src/tally.F90
===================================================================
--- src/tally.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/tally.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -10,0 +11 @@
+  use dagmc_mod
@@ -292,0 +294,4 @@
+
+    ! DAGMC: If in CAD mode, make sure distance to physics collision is initialized
+    if ( isdgmc == 1 ) call dagmc_setdis(huge_float)
+
Index: src/chekit.F90
===================================================================
--- src/chekit.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/chekit.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -1085,0 +1086 @@
+        & .and.hitm(1:3)/='dag'  &  ! DAGMC option  
Index: src/imcn.F90
===================================================================
--- src/imcn.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/imcn.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -17,0 +18 @@
+  use dagmc_mod
@@ -455,0 +457,6 @@
+
+    ! Initialize DAGMC
+    if (isdgmc == 1) then   ! set DAGMC parameters from idum & rdum
+       call dagmc_set_settings(dagmc_distlimit, dagmc_usecad, dagmc_overlap_thickness, dagmc_srcmode)
+    endif
+       
Index: src/echkcl.F90
===================================================================
--- src/echkcl.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/echkcl.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -11,0 +12 @@
+  use dagmc_mod
@@ -18 +19,10 @@
-    call  chkcel(icl,2,j)
+    if( isdgmc == 1 ) then
+       ! dagmc note: I'm not aware that lev/levp ever differ during dagmc execution,
+       !           : and I know that repeated structures are not involved,
+       !           : so I have not modified the other call to chkcel in this function.
+       !           : If I'm wrong, this same check should be added below.
+       call dagmcchkcel_by_angle( uuu, vvv, www, xxx, yyy, zzz, jsu, icl, j )
+       call dagmc_surf_reflection( uuu, vvv, www, 1 )
+    else
+       call  chkcel(icl,2,j)
+    endif
Index: src/dbmin.F90
===================================================================
--- src/dbmin.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/dbmin.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -11,0 +12 @@
+  use dagmc_mod
@@ -13,0 +15,11 @@
+
+  ! DAGMC: Explicitly declare variable for return value for inter-language call
+  real(dknd) :: dbmin_retval = zero
+
+  ! DAGMC: In CAD mode, call MOAB version instead
+  if ( isdgmc == 1 ) then
+     call dagmcdbmin(icl,xxx,yyy,zzz,huge_float,dbmin_retval)
+     dbmin = dbmin_retval
+     return
+  endif
+
Index: src/electr.F90
===================================================================
--- src/electr.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/electr.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -12,0 +13 @@
+  use dagmc_mod
@@ -85,0 +87,7 @@
+        
+        ! DAGMC: In DAGMC mode, use the known physics distance to limit geometry search
+        if ( isdgmc == 1 ) then
+           d = min(dtc,pmf)
+           call dagmc_setdis(d)
+        endif
+        
Index: src/oldcrd.F90
===================================================================
--- src/oldcrd.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/oldcrd.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -11,0 +12 @@
+  use dagmc_mod
@@ -33 +34,2 @@
-      if( lca(mxa)==nlja+1 ) &
+      ! DAGMC: In CAD mode, cells should have no surfaces
+      if( ( lca(mxa)==nlja+1 ) .and. ( isdgmc == 0 ) ) &
@@ -44,0 +47,4 @@
+
+    ! DAGMC: Break out of subroutine here in CAD mode
+     if ( isdgmc == 1 ) return
+
@@ -737,0 +744,3 @@
+     ! DAGMC: skip handling imesh/jmesh/kmesh/orig when geom=DAG; check emesh before jump
+    if( ifmsh(13)==0 ) ientmp(1:ifmsh(12)) = 1
+    if( fm(nmesh)%icrd==3 ) goto 4900
@@ -847,0 +857 @@
+4900 continue ! DAGMC jump target
Index: src/mcnp_input.F90
===================================================================
--- src/mcnp_input.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/mcnp_input.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -11 +11 @@
-  integer,parameter :: nkcd   = 106     != Number of different types of input cards.
+  integer,parameter :: nkcd   = 107     != Number of different types of input cards.
@@ -129,0 +130,6 @@
+  ! dagmc card keywords, input values
+  character(len=18), parameter :: hdagmc(4) = (/'check_src_cell    ', &
+    &                                           'usecad            ', &
+    &                                           'distlimit         ', &
+    &                                           'overlap_thickness ' /)
+
@@ -249,0 +256 @@
+  data cnm(107),(krq(i,107),i=1,7)/ 'dagmc',0,0, 0,0, 0,  12,0 / 
Index: src/main.F90
===================================================================
--- src/main.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/main.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -56 +56 @@
-
+  use dagmc_mod
@@ -142,0 +143,26 @@
+
+  ! DAGMC: initialize a DAGMC run if specified
+  if (gcad /= ' ') then
+     isdgmc = 1
+
+     if (mcnp_opt_mpi) dagmc_geom_file_mode = DGFM_READ;
+
+  else
+     
+     ! Error checking for user specifying worthless files
+     if(lcad /= ' ') then
+        call expire(0,'main','CAD list file specified &
+             &   without a geometry file.')
+     endif
+     if(fcad /= ' ') then
+        call expire(0,'main','CAD facet file specified &
+             &   without a geometry file.')
+     endif
+     if(ftol /= ' ') then
+        call expire(0,'main','Facet tolerance specified &
+             &   without a geometry file.')
+     endif
+     
+  endif
+  
+
@@ -180,0 +207,4 @@
+  if (isdgmc == 1) then
+     call init_dagmc
+  endif 
+
@@ -191,0 +222 @@
+  if (isdgmc == 1) call dagmc_version_heading(iuo)
Index: src/FILE.list
===================================================================
--- src/FILE.list	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/FILE.list	(.../5.1.60/trunk/Source)	(revision 424)
@@ -74,0 +75,5 @@
+####################
+# C++ Source Files #
+####################
+CXX_SRC :=  
+
@@ -79,0 +85 @@
+UNWANTED_CXX_SRC :=
@@ -92,0 +99,8 @@
+ifeq (dagmc,$(filter dagmc,$(CONFIG)))
+  F_SRC   := $(F_SRC) dagmc_mod.F90
+  CXX_SRC := $(CXX_SRC) ../dagmc/mcnp_funcs.cpp ../dagmc/meshtal_funcs.cpp \
+  ../dagmc/KDEMeshTally.cpp ../dagmc/KDEKernel.cpp ../dagmc/KDECollision.cpp \
+  ../dagmc/KDETrack.cpp ../dagmc/TrackLengthMeshTally.cpp ../dagmc/MeshTally.cpp
+
+endif
+
@@ -98,0 +113 @@
+CXX_SRC :=	$(filter-out $(UNWANTED_CXX_SRC),$(CXX_SRC))
@@ -101,0 +117 @@
+CXX_OBJS =	$(CXX_SRC:.cpp=$(OBJC))
Index: src/fmesh_mod.F90
===================================================================
--- src/fmesh_mod.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/fmesh_mod.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -12,0 +13,2 @@
+  use dagmc_mod
+
@@ -19,0 +22,2 @@
+  logical :: enable_dag_collision_tallies = .false. != DAGMC: Flag indiciating presence of KDE tally
+
@@ -126,0 +131,31 @@
+
+  ! DAGMC: These helper functions must be called with non-dereferenced Fortran pointers.
+  ! This interface specification ensures that the calls to these functions
+  ! (which are implemented in C) are made with the correct types
+  interface
+     subroutine dagmc_fmesh_get_tally_data( idx, fref )
+       implicit none
+       integer :: idx
+       ! The dknd parameter is unavailable in this scope for some reason,
+       ! so I have copied the definition of dknd from mcnp_params
+       real(selected_real_kind(15,307)) , dimension(:), pointer :: fref 
+       !real(dknd), dimension(:), pointer :: fref
+     end subroutine dagmc_fmesh_get_tally_data
+
+     subroutine dagmc_fmesh_get_error_data( idx, fref )
+       implicit none
+       integer :: idx
+       real(selected_real_kind(15,307)) , dimension(:), pointer :: fref
+       !real(dknd), dimension(:), pointer :: fref
+     end subroutine dagmc_fmesh_get_error_data
+
+     subroutine dagmc_fmesh_get_scratch_data( idx, fref )
+       implicit none
+       integer :: idx
+       real(selected_real_kind(15,307)), dimension(:), pointer:: fref 
+       !real(dknd), dimension(:), pointer :: fref
+     end subroutine dagmc_fmesh_get_scratch_data
+
+  end interface
+
+
@@ -130,0 +166,42 @@
+  ! DAGMC: Helper function - create a valid Fortran pointer from a C array and a length 
+  subroutine dagmc_make_fortran_pointer( fref, carray, size )
+    implicit none
+
+    integer :: size ! The size (in doubles) of the array in C
+    real(dknd), dimension(size), target :: carray ! The C pointer
+    real(dknd), dimension(:), pointer :: fref     ! The returned Fortran pointer
+    
+    fref => carray
+
+  end subroutine dagmc_make_fortran_pointer
+
+  subroutine dagmc_setup_mesh_tally( idx )
+    implicit none
+    integer :: idx
+    integer :: dagmc_iscol
+
+    print *, shape(fm(idx)%fmarry)
+
+    ! Setup dagmc mesh; paramaters will be read in from FC card
+    if( fm(idx)%n_comment_lines > 0 ) then 
+       call dagmc_fmesh_setup_mesh( fm(idx)%ipt, fm(idx)%id, idx, &
+                                    fm(idx)%enbin, fm(idx)%nenb, fm(idx)%tot_energy_bin, &
+                                    fm(idx)%comment, fm(idx)%n_comment_lines, dagmc_iscol )
+    else
+       ! No FC card; avoid passing uninitialized pointer to C
+       ! The following call will halt mcnp with an error because of the missing card.
+       ! We could also signal an error and halt here instead.
+       call dagmc_fmesh_setup_mesh( fm(idx)%ipt, fm(idx)%id, idx, &
+                                    fm(idx)%enbin, fm(idx)%nenb, fm(idx)%tot_energy_bin, &
+                                    0, 0, dagmc_iscol )
+    endif
+    
+    if( dagmc_iscol == 1 ) then 
+       enable_dag_collision_tallies = .true. 
+    endif
+    
+  end subroutine dagmc_setup_mesh_tally
+    
+    
+  !-----------------------------------------------------------------------------------------
+
@@ -137,0 +215 @@
+    real(dknd), dimension(:), pointer :: dagmc_runtpe_data
@@ -138,0 +217,3 @@
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_runtpw'
+
@@ -182,0 +264,9 @@
+
+       ! DAGMC: 
+       if ( fm(i)%icrd==3 ) then          
+          ! Get pointer to mesh's working data and fill runtpe with those contents
+          call dagmc_fmesh_get_tally_data( i, dagmc_runtpe_data )
+          write(iu) dagmc_runtpe_data
+          call dagmc_fmesh_get_error_data( i, dagmc_runtpe_data )
+          write(iu) dagmc_runtpe_data
+       endif
@@ -193 +283 @@
-    use mcnp_global, only:ntasks,iovr
+    use mcnp_global, only:ntasks,iovr,icl
@@ -203,0 +294,5 @@
+    real(dknd), dimension(:), pointer :: dagmc_runtpe_data
+
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_runtpr'
+
@@ -254,0 +350,2 @@
+          ! From reading tpefil.F90, I think this branch only executes if runtpe file 
+          ! has suffered a read failure-- which should be uncommon. --sjackson
@@ -350,0 +448,16 @@
+
+
+       if ( fm(i)%icrd==3 ) then 
+          ! DAGMC:
+
+          call dagmc_fmesh_initialize( icl )
+          call dagmc_setup_mesh_tally( i )
+
+          ! Get pointer to mesh's working memory and fill it with runtpe data
+          call dagmc_fmesh_get_tally_data( i, dagmc_runtpe_data )
+          read(iu) dagmc_runtpe_data
+          call dagmc_fmesh_get_error_data( i, dagmc_runtpe_data )
+          read(iu) dagmc_runtpe_data
+ 
+       endif
+
@@ -387,0 +501,3 @@
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: ifmesh_print'
+
@@ -517,0 +634,3 @@
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_allocate'
+
@@ -591,0 +711,3 @@
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: wtmult_fmesh'
+
@@ -802 +924,5 @@
-    integer :: i
+    integer :: i,j
+    
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_msgput'
+
@@ -849,0 +976,9 @@
+       ! DAGMC: send comment contents if this is a dagmc mesh
+       if( fm(i)%icrd == 3 ) then
+          call msg_put( fm(i)%n_comment_lines )
+
+          do j=1,fm(i)%n_comment_lines
+             call msg_put( fm(i)%comment(j) )
+          enddo
+       endif
+
@@ -863 +998 @@
-    use mcnp_global, only: ntasks
+    use mcnp_global, only: ntasks, icl
@@ -865,0 +1001,4 @@
+    integer :: j
+
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_msgget'
@@ -943,0 +1083,13 @@
+       ! DAGMC: receive comment contents if this is a dagmc mesh
+       if( fm(i)%icrd == 3 ) then
+          call msg_get( fm(i)%n_comment_lines )
+
+          allocate( fm(i)%comment( fm(i)%n_comment_lines ), stat=is )
+          if(is/=0) call erprnt(1,1,0,0,0,0,0,1,' "mesh tally memory allocation failure"')
+
+          do j=1,fm(i)%n_comment_lines 
+             call msg_get( fm(i)%comment(j) )
+          enddo
+
+       endif
+
@@ -983,0 +1136,9 @@
+   ! DAGMC: 
+    call dagmc_fmesh_initialize( icl )
+
+    do i = 1,nmesh
+       if( fm(i)%icrd == 3 ) then
+          call dagmc_setup_mesh_tally( i )
+       endif
+    enddo
+
@@ -995,0 +1157,4 @@
+    real(dknd), dimension(:), pointer :: dagmc_mpi_data
+
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_msgcon'
@@ -1006,0 +1172 @@
+       if( fm(i)%icrd /= 3 ) then 
@@ -1015,0 +1182,11 @@
+       
+       else
+          ! DAGMC
+          call dagmc_fmesh_get_scratch_data( i, dagmc_mpi_data )
+          call msg_get( dagmc_mpi_data, 1, size(dagmc_mpi_data) )
+          call dagmc_fmesh_add_scratch_to_tally( i )
+          call msg_get( dagmc_mpi_data, 1, size(dagmc_mpi_data) )
+          call dagmc_fmesh_add_scratch_to_error( i )
+
+       endif
+
@@ -1030,0 +1208,4 @@
+    real(dknd), dimension(:), pointer :: dagmc_mpi_data
+
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_msgtsk'
@@ -1041,0 +1223,2 @@
+       if( fm(i)%icrd /= 3 ) then
+
@@ -1048,0 +1232,11 @@
+       
+       else
+          ! DAGMC
+          call dagmc_fmesh_get_tally_data( i, dagmc_mpi_data )
+          call msg_put( dagmc_mpi_data, 1, size(dagmc_mpi_data) )
+          call dagmc_fmesh_get_error_data( i, dagmc_mpi_data )
+          call msg_put( dagmc_mpi_data, 1, size(dagmc_mpi_data) )
+          call dagmc_fmesh_clear_data( i )
+
+       endif
+
@@ -1064,0 +1259,3 @@
+    ! DAGMC: 
+    call dagmc_fmesh_end_history()
+
@@ -1112,0 +1310,49 @@
+  
+  subroutine dagmc_mesh_choose_ebin( i, erg, ien )
+    integer :: i, ien
+    real(dknd) :: erg
+    
+    ! See if energy is within the desired bins
+    if( fm(i)%nenb>1 ) then
+       if( erg<fm(i)%enbin(1) .or. erg>fm(i)%enbin(fm(i)%nenb)) then
+          ien = -1
+       else
+          ien = ibin_search(erg,fm(i)%enbin,fm(i)%nenb)
+       endif
+    else
+       ien = 1
+    endif
+
+  end subroutine dagmc_mesh_choose_ebin
+
+  !-----------------------------------------------------------------------------------------
+
+  subroutine dagmc_mesh_score( i, erg, wgt, d, score )
+
+    use mcnp_params, only:dknd
+    use mcnp_global, only:rho,icl
+
+    integer   , intent(in) :: i
+    real(dknd), intent(in) :: erg,wgt,d 
+    real(dknd), intent(out) :: score
+    real(dknd) :: t
+
+    t = 1._dknd
+    if( fm(i)%ifm_card/=0 ) then
+       call wtmult_fmesh(t,i)
+    endif
+    t = t*fm(i)%fmult
+    if( fm(i)%fmult < 0 ) t = -t*rho(icl)
+    
+    if ( fm(i)%ifm_card == -1 ) then ! Special tally multiplier -- # of tracks
+       score = t
+    else
+       score = d*wgt*t
+       if ( fm(i)%icx == 1 ) score = score*erg
+       if ( fm(i)%intrpol /= 0 ) score = score*dosef_fmesh(erg,i)
+    endif
+
+    return
+  end subroutine dagmc_mesh_score
+          
+  !-----------------------------------------------------------------------------------------
@@ -1148,0 +1395,16 @@
+       ! DAGMC: 
+       if ( fm(i)%icrd==3 ) then
+
+          ! See if energy is within the desired bins
+          if( fm(i)%nenb>1 ) then
+             if( erg<fm(i)%enbin(1) .or. erg>fm(i)%enbin(fm(i)%nenb)) cycle Loop1
+             
+             ien = ibin_search(erg,fm(i)%enbin,fm(i)%nenb)
+          else
+             ien = 1
+          endif
+
+          call dagmc_fmesh_score(i,x,y,z,u,v,w,erg,wgt,d,ien)
+          cycle
+       endif
+
@@ -1339,0 +1602 @@
+            ! DAGMC: begin borrowed source for subroutine dagmc_mesh_score
@@ -1354,0 +1618 @@
+            ! DAGMC: end borrowed source 
@@ -1422,0 +1687,3 @@
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: mesh_score_cyl'
+
@@ -1730,0 +1998,5 @@
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmsh_setup'
+    ! For a dagmc mesh (icrd==3), origin and bins information will be missing
+    ! In these cases, allocate a single bin in all directions to keep this code happy
+
@@ -1733,4 +2005,8 @@
-    fm(nmesh)%nxrb = 1
-    do i = 1,ifmsh(6)
-       fm(nmesh)%nxrb = fm(nmesh)%nxrb+ixrtmp(i)
-    enddo
+    if( fm(nmesh)%icrd /= 3 ) then
+       fm(nmesh)%nxrb = 1
+       do i = 1,ifmsh(6)
+          fm(nmesh)%nxrb = fm(nmesh)%nxrb+ixrtmp(i)
+       enddo
+    else
+       fm(nmesh)%nxrb = 2
+    endif
@@ -1740,4 +2016,8 @@
-    fm(nmesh)%nyzb = 1
-    do i = 1,ifmsh(8)
-       fm(nmesh)%nyzb = fm(nmesh)%nyzb+iyztmp(i)
-    enddo
+    if( fm(nmesh)%icrd /= 3 ) then
+       fm(nmesh)%nyzb = 1
+       do i = 1,ifmsh(8)
+          fm(nmesh)%nyzb = fm(nmesh)%nyzb+iyztmp(i)
+       enddo
+    else
+       fm(nmesh)%nyzb = 2 
+    endif
@@ -1747,4 +2027,8 @@
-    fm(nmesh)%nztb = 1
-    do i = 1,ifmsh(10)
-       fm(nmesh)%nztb = fm(nmesh)%nztb+izttmp(i)
-    enddo
+    if( fm(nmesh)%icrd /= 3 ) then
+       fm(nmesh)%nztb = 1
+       do i = 1,ifmsh(10)
+          fm(nmesh)%nztb = fm(nmesh)%nztb+izttmp(i)
+       enddo
+    else
+       fm(nmesh)%nztb = 2
+    endif
@@ -1874,0 +2159,3 @@
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: dosef_fmesh'
+
@@ -1934,0 +2222,3 @@
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_print'
+
@@ -1973,0 +2264,6 @@
+       ! DAGMC
+       if( fm(j)%icrd == 3 ) then
+          call dagmc_fmesh_print( j, sp_norm, fm(j)%fact ) 
+          cycle
+       endif
+
@@ -2439,0 +2736,3 @@
+    ! DAGMC DEBUGGING
+    !print '(a80)', 'DAGMC MESTHAL: fmesh_initialize'
+
@@ -2749,0 +3049,9 @@
+   ! DAGMC: 
+    call dagmc_fmesh_initialize( icl )
+
+    do i = 1,nmesh
+       if( fm(i)%icrd == 3 ) then
+          call dagmc_setup_mesh_tally( i )
+       endif
+    enddo
+    
@@ -2764,0 +3073,3 @@
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_vtask'
+   
@@ -2856,0 +3168,3 @@
+
+  ! DAGMC DEBUGGING
+  !  print '(a80)', 'DAGMC MESTHAL: ibin_search'
Index: src/getpar.F90
===================================================================
--- src/getpar.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/getpar.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -11,0 +12 @@
+  use dagmc_mod
@@ -17,0 +19,6 @@
+
+  ! DAGMC: Restore the ray history associated with this particle
+  if (isdgmc == 1) then 
+     call dagmc_getpar(n)
+  endif
+
Index: src/itally.F90
===================================================================
--- src/itally.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/itally.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -21,0 +22 @@
+  use dagmc_mod
@@ -98,0 +100,7 @@
+
+        ! DAGMC: If in CAD mode, skip up until line prior to marker 40
+        if ( isdgmc == 1 ) then
+          itds(li+i) = k
+          goto 40
+        endif
+
Index: src/reflec.F90
===================================================================
--- src/reflec.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/reflec.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -10,0 +11 @@
+  use dagmc_mod
@@ -83,0 +85 @@
+  if( isdgmc == 1 ) call dagmc_surf_reflection( uuu, vvv, www, 0 )
Index: src/msgtsk.F90
===================================================================
--- src/msgtsk.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/msgtsk.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -22,0 +23 @@
+  use dagmc_mod
@@ -89,0 +91,3 @@
+
+  call dm_recv(-1,20,i)
+  call dagmc_msgget  
Index: src/newcel.F90
===================================================================
--- src/newcel.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/newcel.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -10,0 +11,2 @@
+  use dagmc_mod
+
@@ -12,0 +15,7 @@
+  ! DAGMC: In CAD mode, call MOAB version of this
+  if ( isdgmc == 1 ) then
+    if ( cs /= 0 ) cs = angl()
+    call dagmcnewcel(jsu,icl,iap)
+    if ( mxa == -1 ) kdb = 1
+  endif
+
@@ -36 +45,4 @@
-    call expirx(1,'newcel','the surface crossed is not a surface of this cell.')
+    ! DAGMC: Only check this if running normally, (NOT in CAD mode)
+    if (isdgmc == 0) then
+      call expirx(1,'newcel','the surface crossed is not a surface of this cell.')
+    endif
Index: src/chkcel.F90
===================================================================
--- src/chkcel.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/chkcel.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -22,0 +23 @@
+  use dagmc_mod
@@ -27,0 +29,6 @@
+  ! DAGMC: In CAD mode, circumvent this function and call DAGMC version instead
+  if ( isdgmc == 1 .and. (m == 0 .or. m==2) ) then
+     call dagmcchkcel(uuu,vvv,www,xxx,yyy,zzz,i1,j)
+     return
+  endif
+  
Index: src/igeom.F90
===================================================================
--- src/igeom.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/igeom.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -10,0 +11 @@
+  use dagmc_mod
@@ -103 +104,2 @@
-  call chekcs
+  ! DAGMC: only call this when running in normal (non-CAD) mode
+  if (isdgmc == 0) call chekcs
Index: src/transm.F90
===================================================================
--- src/transm.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/transm.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -10,0 +11,2 @@
+  use dagmc_mod
+
@@ -32,0 +35,2 @@
+    ! DAGMC: If in CAD mode, call dagmc_setdis first
+    if ( isdgmc == 1 ) call dagmc_setdis( dd - sd )
Index: src/startp.F90
===================================================================
--- src/startp.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/startp.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -15,0 +16 @@
+  use dagmc_mod
@@ -59,0 +61,4 @@
+ ! DAGMC: nbnk = 0
+  if ( isdgmc == 1 ) then
+     call dagmc_bank_clear
+  endif
Index: src/msgcon.F90
===================================================================
--- src/msgcon.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/msgcon.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -22,0 +23 @@
+  use dagmc_mod 
@@ -169,0 +171,5 @@
+
+  write(jtty,*) "master sending DAGMC information...."
+  call dm_sndi
+  call dagmc_msgput
+  call dm_send(-1,20,i)
Index: src/nextit.F90
===================================================================
--- src/nextit.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/nextit.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -15,0 +16 @@
+  use dagmc_mod
@@ -1462,0 +1464 @@
+        if( hitm(1:3)=='dag' )                        fm(nmesh)%icrd=3 ! DAGMC option
@@ -1676,0 +1679,23 @@
+
+
+  case( 107 )
+    !  >>>>>  DAGMC parameters                                          dagmc
+    !  Modeled after RAND (99)
+    ! m1c=index of current dagmc keyword.
+    if( m1c == 0 ) then
+      if( index(',=',hitm(1:1))==0 ) then
+        do m1c = 1,4
+          if( hitm(1:18)==hdagmc(m1c) )  return
+        enddo
+        m1c = 0
+      endif
+    else
+      if( index(',=',hitm(1:1))==0 ) then
+        if( m1c==1 .and. ( hitm(1:2) == 'of' .or. hitm(1:2) == 'no') )  dagmc_srcmode = 1 
+        if( m1c==2 .and. ( hitm(1:2) == 'on' .or. hitm(1:2) == 'ye') )  dagmc_usecad = 1
+        if( m1c==3 .and. ( hitm(1:2) == 'on' .or. hitm(1:2) == 'ye') )  dagmc_distlimit = 1
+        if( m1c==4 )  dagmc_overlap_thickness = ritm
+        m1c = 0
+      endif
+    endif
+
Index: src/mcnp_params.F90
===================================================================
--- src/mcnp_params.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/mcnp_params.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -122,0 +123 @@
+  integer,parameter :: iulc = 57        != I/O unit for DAGMC log file
Index: src/hstory.F90
===================================================================
--- src/hstory.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/hstory.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -19 +19 @@
-  use fmesh_mod, only: mesh_end_history, mesh_score, nmesh
+  use fmesh_mod, only: mesh_end_history, mesh_score, nmesh, enable_dag_collision_tallies
@@ -21,0 +22 @@
+  use dagmc_mod
@@ -139 +140,2 @@
-  if( lca(icl)<0 ) then
+  ! DAGMC: only do this when running in non-CAD mode
+  if( lca(icl)<0 .and. (isdgmc == 0) ) then
@@ -150 +152,2 @@
-  call track(icl)
+  ! DAGMC: only call track here if in normal mode (NOT in CAD mode)
+  if (isdgmc == 0) call track(icl)
@@ -215 +218,9 @@
-        ! Force a collision.
+        ! DAGMC: In CAD mode, call DAGMC before forcing collision
+        if ( isdgmc == 1 ) then
+           if ( lca(icl) < 0 ) call chkcel(icl,3,j)
+           call dagmc_setdis(huge_float)
+           call track(icl)
+           if ( kdb /= 0 ) goto 390
+        endif
+         
+        !  Force a collision.
@@ -227,0 +239,10 @@
+
+  ! DAGMC: In CAD mode, get particle information
+  if ( isdgmc == 1 ) then
+     if (lca(icl) < 0) call chkcel(icl,3,j)
+     d = min( pmf, dxl, dtc, deb, dw )
+     call dagmc_setdis(d)
+     call track(icl)
+     if ( kdb /= 0 ) goto 390
+  endif
+
@@ -487,0 +509,6 @@
+
+  ! DAGMC: Alternative Tally - Kernel Density Estimator
+  if ( enable_dag_collision_tallies ) then
+     call dagmc_kde_tally( xxx, yyy, zzz, wgt, ple, erg )
+  endif
+
@@ -532,0 +560,2 @@
+
+  if (isdgmc == 1) call dagmc_particle_terminate()
Index: src/volume.F90
===================================================================
--- src/volume.F90	(.../vendor/5.1.60/Source)	(revision 424)
+++ src/volume.F90	(.../5.1.60/trunk/Source)	(revision 424)
@@ -11,0 +12 @@
+  use dagmc_mod
@@ -15,0 +17,6 @@
+  ! DAGMC: In CAD mode, circumvent most of this function and call DAGMC version
+  if (isdgmc == 1) then
+    call dagmcvolume(mxa,vols,mxj,aras)
+    goto 260
+  endif
+

Property changes on: src
___________________________________________________________________
Added: svn:ignore
   + *.mod
mcnp5
mcnp5.mpi


Index: dagmc/TrackLengthMeshTally.hpp
===================================================================
--- dagmc/TrackLengthMeshTally.hpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/TrackLengthMeshTally.hpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,120 @@
+#ifndef DAGMC_TRACK_LENGTH_MESH_TALLY_H
+#define DAGMC_TRACK_LENGTH_MESH_TALLY_H
+
+
+#include <string>
+#include <cassert>
+#include <set>
+
+#include "moab/Interface.hpp"
+#include "moab/CartVect.hpp"
+#include "moab/Range.hpp"
+
+#include "Matrix3.hpp"
+#include "MeshTally.hpp"
+
+
+struct MCNPTrackParam {
+  int *fmesh_index;
+  double *erg;
+  double *wgt;
+
+  MCNPTrackParam(int *i, double *e, double *w): 
+    fmesh_index(i), erg(e), wgt(w) {}
+};
+
+namespace moab{
+
+/* Forward Declarations */
+class AdaptiveKDTree;
+class OrientedBoxTreeTool;
+
+
+class TrackLengthMeshTally : public MeshTally{ 
+
+public:
+  /**
+   * Public constructor interface- actual constructor is protected.
+   */
+  static TrackLengthMeshTally* setup( const fmesh_card& params, Interface* mbi, const int* cur_mcnp_cell );
+
+  /**
+   * Tally a single particle track segment
+   */
+  void add_track_segment( CartVect& start, CartVect& vec, double length, int ebin,  MCNPTrackParam* score_params );
+  
+  virtual void end_history ();
+    
+  virtual void print(  double sp_norm, double mult_fact );
+
+  ~TrackLengthMeshTally();
+
+ 
+
+protected:
+
+  ErrorCode load_mesh( const std::string& input_filename, 
+                       std::string tag_name, std::vector<std::string>& tag_values );  
+  ErrorCode write_results( double sp_norm, double mult_fact, 
+                           const std::string* override_output_filename = NULL );
+
+  bool point_in_tet( const CartVect& point, const EntityHandle* tet );
+
+  void add_score_to_mesh_cell( EntityHandle mesh_cell, double score, int ebin );
+ 
+  void get_skin_triangle_adjacencies( EntityHandle triangle, 
+                                      EntityHandle& tetrahedron, EntityHandle vertices[3] );
+
+
+  EntityHandle find_next_tet_by_ray_fire( CartVect& start, CartVect& vec, double length, 
+                                          EntityHandle first_tri[3], double& first_t, 
+                                          EntityHandle last_crossing = 0 );
+
+  EntityHandle get_starting_tet( CartVect& start, CartVect& vec, double length, 
+                                 EntityHandle first_tri[3], double& first_t );
+    
+
+  EntityHandle get_starting_tet_conformal( CartVect& start, EntityHandle first_tri[3] );
+
+
+  void set_convex_flag( bool c ){ convex = c; } 
+
+  Interface* mb;
+
+  std::string output_filename;
+
+  EntityHandle tally_set;
+
+  AdaptiveKDTree* kdtree;
+  EntityHandle kdtree_root;
+
+  OrientedBoxTreeTool* obb_tool;
+  EntityHandle obbtree_root;
+
+  EntityHandle last_visited_tet;
+
+  std::vector< Matrix3 > tet_baryc_data;
+
+  bool convex; // true if user asserts this mesh tally has convex geometry
+
+  // if non-null, user has asserted mesh tally geometry
+  // conforms to the cells identified in this set
+  std::set<int>* conformality; 
+  bool conformal_surface_source;
+
+  const int* mcnp_current_cell; // non-null if user has asserted conformal geometry
+  int last_cell;
+  std::set<EntityHandle> visited_this_history; 
+    
+  TrackLengthMeshTally( const fmesh_card& fmesh_params, Interface* mb_p, const std::string& output_filename );
+
+private:
+  TrackLengthMeshTally& operator=( const TrackLengthMeshTally& mt ); // unimplemented
+  TrackLengthMeshTally( const TrackLengthMeshTally& mt ); // unimplemented
+
+};
+
+} // end namespace moab
+
+
+#endif /* DAGMC_TRACK_LENGTH_MESH_TALLY_H */
Index: dagmc/meshtal_funcs.h
===================================================================
--- dagmc/meshtal_funcs.h	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/meshtal_funcs.h	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,94 @@
+#ifndef DAGMC_MESHTAL_IFACE_H
+#define DAGMC_MESHTAL_IFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***********************************************************
+ * This file declares the functions forming the C/Fortran bridge for the
+ * advanced MOAB-based mesh tally features, including tetrahedral mesh tallies
+ * and KDE tallies.
+ ***********************************************************/
+
+/**
+ * mcnp_weight_calculation: bridge to call back into MCNP code to compute the weight
+ *     of a scored event on a mesh tally
+ *
+ * @param i The fmesh_index number assigned to the tally
+ * @param erg The particle's energy
+ * @param wgt The current weight of the particle
+ * @param dist The distance over which to tally the particle; for track length tallies, 
+ *             this is typically a track segment length
+ * @param (out) score_result Output parameter returned from MCNP
+ *
+ **/
+void mcnp_weight_calculation( int* index, double* erg, double* wgt, 
+                              double* dist, double* score_result );
+
+/**
+ * Functions from fmesh_mod are implemented in src/fmesh_mod.F90 
+ * and should only be called from within meshtal_funcs.cpp
+ */
+
+/** FORT_FUNC:
+ * Macro to access symbol of fortran function 'func' in module 'mod' 
+ **/
+#ifndef FORT_FUNC
+
+/* gcc/gfortran 4.3 and above: name mangling is '__module_MOD_function' */
+#if __GNUC__ > 4 || ( __GNUC__ == 4  && __GNUC_MINOR__ >= 3 )
+#define FORT_FUNC( mod, func ) __##mod##_MOD_##func
+
+/* gcc/gfortran < 4.3: name mangling is '__module__function' */
+#elif __GNUC__ == 4 
+#define FORT_FUNC( mod, func ) __##mod##__##func
+
+/* Something we haven't encountered yet */
+#else
+/* Comment out this error to force compile to proceed; it may or may not work */
+#error "DagMC: unknown compiler with unknown fortran name mangling scheme."
+#define FORT_FUNC( mod, func ) __##mod##__##func
+
+#endif
+#endif /* FORT_FUNC */
+
+#define FMESH_FUNC( func ) FORT_FUNC( fmesh_mod, func )
+
+/* Mesh weight/score calculation */
+extern void FMESH_FUNC(dagmc_mesh_score)( int* i, double* erg, double* wgt, double* d, double *score );
+/* Make a valid Fortran pointer to a C arary */
+extern void FMESH_FUNC(dagmc_make_fortran_pointer)( void* fort_ref, double* array, int* size );
+/* Choose the energy bin for the i'th tally, given the current particle energy
+ * This is only used by collision tallies for which dagmc_fmesh_score is not called directly*/
+extern void FMESH_FUNC(dagmc_mesh_choose_ebin)( int* i, double* erg, int* ien );
+
+/**
+ * The dagmc_fmesh_*_ functions are called from fortran to drive our advanced mesh tallies,
+ * mostly from fmesh_mod.F90.  They should probably not be called from C++ code.
+ * Per-function documentation is found in meshtal_funcs.cpp
+ */
+void dagmc_fmesh_initialize_( const int* mcnp_icl );
+void dagmc_fmesh_setup_mesh_( int* ipt, int* id, int* fmesh_index, 
+                            double* energy_mesh, int* n_energy_mesh, int* tot_energy_bin, 
+                            char* comment, int* n_comment_lines, int *is_collision_tally );
+void dagmc_fmesh_end_history_();
+void dagmc_fmesh_score_(int *fmesh_index, double *x, double *y, double *z,
+                      double *u, double *v, double *w, double *erg,double *wgt,double *d, int* ien );
+void dagmc_fmesh_print_( int* fmesh_index, double* sp_norm, double* fmesh_fact );
+
+void dagmc_fmesh_get_tally_data_( int* fmesh_index, void* fortran_data_pointer );
+void dagmc_fmesh_get_error_data_( int* fmesh_index, void* fortran_data_pointer );
+void dagmc_fmesh_get_scratch_data_( int* fmesh_index, void* fortran_data_pointer );
+void dagmc_fmesh_clear_data_( int* fmesh_index );
+void dagmc_fmesh_add_scratch_to_tally_( int* fmesh_index );
+void dagmc_fmesh_add_scratch_to_error_( int* fmesh_index );
+
+void dagmc_kde_tally_( double* x, double* y, double* z, double* wgt,
+                     double* ple, double* erg );
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif 
+
+#endif /* DAGMC_MESHTAL_IFACE_H */
Index: dagmc/mcnp_funcs.h
===================================================================
--- dagmc/mcnp_funcs.h	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/mcnp_funcs.h	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,129 @@
+#ifndef DAGMC_MCNP_IFACE_H
+#define DAGMC_MCNP_IFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* initialize DAGMC from FORTRAN main 
+ * @param max_pbl - The maximum index of the pblcm (temporary particle state) array
+ *                  This is the largest n that will arrive in calls to savpar and getpar
+ */
+  void dagmcinit_(char *cfile, int *clen,  
+                  char *ftol,  int *ftlen, 
+                  int *parallel_file_mode,
+                  double* dagmc_version, int* moab_version, int* max_pbl );
+
+/* Add the current particle state to the bank */
+  void dagmc_bank_push_( int* nbnk );
+
+/* Revert to the most recently banked particle state */
+  void dagmc_bank_usetop_( ) ;
+  
+/* Remove and forget the most recently banked particle state.
+ * Called after dagmc_bank_usetop_() */
+  void dagmc_bank_pop_( int* nbnk );
+
+/* Remove all entries in the particle bank */
+  void dagmc_bank_clear_( ) ; 
+
+/* Save the current particle state to temporary index n */
+  void dagmc_savpar_( int* n );
+
+/* Reset the current particle state using temporary index n*/
+  void dagmc_getpar_( int* n );
+
+/* write facet file after initialization and OBBTree generation */
+  void dagmcwritefacets_(char *ffile, int *flen);
+
+/* parse metadata and write applications specific data for: MCNP5 */
+  void dagmcwritemcnp_(char *lfile, int *llen);
+
+/* Get normal of surface with id *jsu at location (*xxx,*yyy,*zzz) and store
+   in three doubles at ang (an arry of length 3) */
+  void dagmcangl_(int *jsu, double *xxx, double *yyy, double *zzz, double *ang);
+
+
+  /* Given point and direction, determine if the particle is going into 
+   * cell i1.  Assume the point is on the surface jsu.  Return j=0 if
+   * the particle is directed into the cell, j=1 if it is leaving the cell.
+   * This is used as a point-in-volume query for points that are known
+   * to be on a surface.
+   */
+  void dagmcchkcel_by_angle_( double *uuu, double *vvv, double *www, 
+                              double *xxx, double *yyy, double *zzz,
+                              int *jsu, int *i1, int *j);
+
+  /* Point-in-volume query.  Determine if the particle at given coordinates
+   * is inside or outside of cell i1.  Return j=1 if outside or on boundary,
+   * and j=0 if inside.  
+   */
+  void dagmcchkcel_(double *uuu,double *vvv,double *www,double *xxx,
+                    double *yyy,double *zzz, int *i1, int *j);
+
+/* Determine distance to nearest surface
+ * *ih - current RefVolume ID
+ * *xxx, *yyy, *zzz - current point
+ * *huge - passed definition of a large number
+ * *dbmin - Output, distance to nearest surface
+ */
+  void dagmcdbmin_( int *ih, 
+                  double *xxx, double *yyy, double *zzz, 
+                  double *huge, double* dbmin);
+
+
+/* Get next Cell
+ * *jsu - Surface to cross
+ * *icl - Previous cell ID
+ * *iap - Next cell ID (output parameter)
+ */
+  void dagmcnewcel_( int *jsu, int *icl, int* iap );
+
+  /**
+   * Tell dagmc that a particle has changed direction at the most recently reached surface boundary,
+   * and reset ray history as necessary.
+   * The parameters are the new particle direction and a flag.
+   * If *verify_dir_change==0, assume without checking that a direction change has actually happened.
+   * If *verify_dir_change==1, compare the new uvw to the last known one, and hold on to 
+   * all ray history if not.  (This mode is used during electron transport,
+   * which occasionally calls this function without having changed the direction;
+   * it's less invasive to do the check in C++ instead of Fortran.)
+   */
+  void dagmc_surf_reflection_( double *uuu, double *vvv, double *www, int* verify_dir_change );
+
+  void dagmc_particle_terminate_( );
+
+/* Do ray fire
+ * *ih  - Volume ID to do ray fire against
+ * *jsu - ? (RefFace ID)
+ * *nps - ?
+ * (*uuu,*vvv,*www) - Ray direction vector
+ * (*xxx,*yyy,*zzz) - Ray point
+ * *huge - ?
+ * *dls - output distnace of intersection
+ * *jap - Next intersected surface, or zero if none
+ */
+  void dagmctrack_(int *ih, double *uuu,double *vvv,double *www,double *xxx,
+                   double *yyy,double *zzz,double *huge,double *dls,int *jap,int *jsu,
+                   int *nps );
+
+/* Measure entities
+ * vols - 2xN array where first column contains, as output, measure of every volume.
+ * aras - 2xN array where first column contains, as output, measure of every surface
+ */                        
+  void dagmcvolume_(int* mxa, double* vols, int* mxj, double* aras);
+
+/* Set distance limit */
+  void dagmc_setdis_(double *d);
+
+  void dagmc_set_settings_(int* use_dist_limit, int* use_cad, double* overlap_thickness, int* srccell_mode);
+
+  void dagmc_init_settings_(int* use_dist_limit, int* use_cad,     
+                            double* overlap_thickness, double* facet_tol, int* srccell_mode );
+
+  void dagmc_version_(double* dagmcVersion);
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif /* DAGMC_MCNP_IFACE_H */

Property changes on: dagmc/mcnp_funcs.h
___________________________________________________________________
Added: svn:executable
   + *

Index: dagmc/MeshTally.cpp
===================================================================
--- dagmc/MeshTally.cpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/MeshTally.cpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,39 @@
+#include "MeshTally.hpp" 
+
+#include "moab/Interface.hpp"
+
+#include <sstream>
+#include <iostream>
+
+moab::ErrorCode MeshTally::setup_tags( moab::Interface* mbi, const char* prefix ){
+  
+  moab::ErrorCode rval;
+
+  std::string pfx = prefix;
+
+  tally_tags.resize( ebins );
+  error_tags.resize( ebins );
+
+  for( unsigned i = 0; i < ebins; ++i ){
+
+    std::string t_name = pfx + "TALLY_TAG", e_name = pfx + "ERROR_TAG";
+    std::stringstream str;  
+
+    if( i + 1 != ebins ){
+      str << "_" << fmesh.energy_bin_bounds[i] << '-' << fmesh.energy_bin_bounds[i+1];
+    }  
+    t_name += str.str();
+    e_name += str.str();
+
+    rval = mbi->tag_get_handle( t_name.c_str(), 1, moab::MB_TYPE_DOUBLE, 
+                                tally_tags[i], moab::MB_TAG_DENSE|moab::MB_TAG_CREAT );
+    if( rval != moab::MB_SUCCESS ) return rval;
+    
+    rval = mbi->tag_get_handle( e_name.c_str(), 1, moab::MB_TYPE_DOUBLE,
+                                error_tags[i], moab::MB_TAG_DENSE|moab::MB_TAG_CREAT );
+    if( rval != moab::MB_SUCCESS ) return rval;
+  }
+
+  return moab::MB_SUCCESS;
+
+}
Index: dagmc/KDEKernel.cpp
===================================================================
--- dagmc/KDEKernel.cpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/KDEKernel.cpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,72 @@
+// KDEKernel.cpp
+
+#include <cmath>
+
+#include "KDEKernel.hpp"
+
+// initializing static variable
+const char* const KDEKernel::kernel_names[] = { "epanechnikov", "uniform" };
+
+//-----------------------------------------------------------------------------
+KDEKernel::KernelType KDEKernel::get_type()
+{
+
+  return type;
+
+}
+//-----------------------------------------------------------------------------
+void KDEKernel::change_type( KernelType k )
+{
+
+  type = k;
+
+}
+//-----------------------------------------------------------------------------
+double KDEKernel::evaluate( double u )
+{
+
+  double value = 0;
+
+  switch ( type ) {
+  
+    case EPANECHNIKOV :
+
+      value = epanechnikov( u );
+      break;
+
+    case UNIFORM :
+
+      value = uniform( u );
+      break;
+
+  }
+
+  return value;
+
+}
+//-----------------------------------------------------------------------------
+double KDEKernel::epanechnikov( double u )
+{
+
+  double value = 0;
+  
+  if ( fabs( u ) <= 1 )
+    value = 0.75 * ( 1 - pow( u, 2 ) );
+
+
+  return value;
+
+}
+//-----------------------------------------------------------------------------
+double KDEKernel::uniform( double u )
+{
+
+  double value = 0;
+  
+  if ( fabs( u ) <= 1 )
+    value = 0.5;
+
+  return value;
+
+}
+//-----------------------------------------------------------------------------
Index: dagmc/MeshTally.hpp
===================================================================
--- dagmc/MeshTally.hpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/MeshTally.hpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,150 @@
+#ifndef DAGMC_MESHTALLY_H
+#define DAGMC_MESHTALLY_H
+
+#include <string>
+#include <map>
+#include <vector>
+
+#include <cassert>
+
+#include "moab/Range.hpp"
+
+/**
+ * Data from the MCNP FMESH card and its associated dagmc FC card.
+ */
+typedef struct {
+
+  /// The user-specified tally ID, i.e. the NN in the fmeshNN card.
+  int id; 
+  /// The index in the fortran 'fm' array, also used to index arrays in meshtal_funcs.cpp
+  int fmesh_index;
+
+  /// Pointer to array of energy bin boundaries, setup with emesh/eints keywords
+  /// These values live in fortran's memory and should not be modified from C
+  const double* energy_bin_bounds;
+  /// The length of energy_bin_boundaries
+  int num_ebin_bounds;
+  /// If true, an extra bin to tally all energy levels will be used
+  bool total_energy_bin;
+
+  /// Typedef for how to access FC card parameters; each key may have one or more values
+  typedef std::multimap<std::string,std::string> fc_params_t;
+
+  /// The params for this tally's FC card. 
+  fc_params_t fc_params;
+
+}  fmesh_card;
+
+// forward declaration
+namespace moab{
+  class Interface;
+}
+
+/**
+ * MOAB-based mesh tally class
+ */
+class MeshTally {
+
+protected:
+
+
+  MeshTally( const fmesh_card& input ):
+    fmesh(input)
+  {
+    ebins = fmesh.num_ebin_bounds;
+    if( !fmesh.total_energy_bin ){
+      ebins = fmesh.num_ebin_bounds - 1;
+    }
+    assert( ebins > 0 );
+  }
+
+public:
+  virtual ~MeshTally(){}
+  
+  /**
+   * Print / write results to the AMeshTally's output file.
+   * @param sp_norm The number of source particles, as reported from within mcnp's fortran code.
+   * @param fmesh_fact Multiplication factor from fmesh card.  
+   */
+  virtual void print( double sp_norm, double fmesh_fact) = 0;
+
+  /**
+   * Updates tally information when the history of a particle ends.
+   */
+  virtual void end_history() = 0;
+
+  /**
+   * get_tally_data(), get_error_data(), get_scratch_data() : 
+   * These functions get pointer to tally data arrays, with length as output parameter.
+   * They are used to load and reload tally data by the runtpe and MPI functions.
+   * A subclass need not use these arrays to store its data, but unless it does,
+   * runtpe and MPI features will not work.  
+   */
+
+  virtual double* get_tally_data( int& length ){
+    length = tally_data.size();
+    return &(tally_data[0]);
+  }
+
+  virtual double* get_error_data( int& length ){
+    length = error_data.size();
+    return &(error_data[0]);
+  }
+
+  virtual double* get_scratch_data( int& length ){
+    length = temp_tally_data.size();
+    return &(temp_tally_data[0]);
+  }
+
+  virtual void zero_tally_data( ){
+    std::fill( tally_data.begin(), tally_data.end(), 0 );
+    std::fill( error_data.begin(), error_data.end(), 0 );
+    std::fill( temp_tally_data.begin(), temp_tally_data.end(), 0 );
+  }
+
+  int get_fmesh_index() { return fmesh.fmesh_index; }
+
+protected:
+  /**
+   * Resize data storage arrays to hold a given number of points.
+   * Arrays will be resized to the given size * the number of energy bins
+   */
+  void resize_data_arrays( unsigned int size ){
+    tally_data.resize( size * ebins, 0 );
+    error_data.resize( size * ebins, 0 );
+    temp_tally_data.resize( size * ebins, 0 );
+  }
+
+  unsigned int ent_idx( moab::EntityHandle eh ){
+    
+    unsigned int ret = tally_ents.index( eh );
+    assert( ret < tally_ents.size() );
+    return ret;
+
+  }
+
+  double& data_ref( std::vector<double>& data, moab::EntityHandle eh, unsigned ebin = 0){
+    assert( ebin < ebins );
+    return data[ ent_idx(eh)*ebins + ebin ];
+  }
+
+  moab::ErrorCode setup_tags( moab::Interface* mbi, const char* prefix="" );
+
+  /// User's MCNP input parameters for this mesh tally
+  fmesh_card fmesh;
+
+  /// data arrays
+  std::vector<double> tally_data, error_data, temp_tally_data;
+
+  /// actual number of energy bins implemented in the data arrays
+  unsigned ebins; 
+
+  /// entities on which to compute tally
+  moab::Range tally_ents;
+
+  /// Tag arrays
+  std::vector< moab::Tag > tally_tags, error_tags; 
+
+};
+
+#endif /* DAGMC_MESHTALLY_H */
Index: dagmc/KDEKernel.hpp
===================================================================
--- dagmc/KDEKernel.hpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/KDEKernel.hpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,78 @@
+// KDEKernel.hpp
+
+#ifndef KDEKERNEL_H
+#define KDEKERNEL_H
+
+/**  
+ * A class that represents a one-dimensional kernel function k(u), which is a
+ * function whose integral over the entire domain is equal to one.
+ */
+class KDEKernel {
+
+  public:
+
+    /**
+     * An enumerative type that specifies the kernel function being used by a
+     * Kernel object.
+     */
+    enum KernelType { EPANECHNIKOV = 0, UNIFORM = 1 };
+    static const char* const kernel_names[];
+    
+     /**
+      * Constructs a default kernel based on the Epanechnikov kernel function.
+      */
+    KDEKernel() : type( EPANECHNIKOV ) {}
+    
+     /**
+      * Constructs a kernel based on the kernel function k.
+      */
+    KDEKernel( KernelType k ) : type( k ) {}
+
+    /**
+     * Returns the type of kernel being used by this Kernel object.
+     *
+     * @return the kernel type
+     */
+    KernelType get_type();
+
+    /**
+     * Changes the type of kernel function being used by this Kernel object to
+     * the type specified by the parameter k.
+     *
+     * @param k the kernel type
+     */
+    void change_type( KernelType k );
+
+   /**
+     * Evaluates the kernel function at the parameter u.
+     *
+     * @param u the value at which the kernel is evaluated
+     * @return the kernel function evaluation k(u)
+     */
+    double evaluate( double u );
+  
+  private:
+
+    KernelType type;  // the kernel function being used
+
+    /**
+     * Evaluates the kernel function at the parameter u using the Epanechnikov
+     * kernel. 
+     *
+     * @param u the value at which the kernel is evaluated
+     * @return the epanechnikov kernel function evaluation k(u)
+     */
+    double epanechnikov( double u );
+
+    /**
+     * Evaluates the kernel function at the parameter u using the Uniform
+     * kernel. 
+     *
+     * @param u the value at which the kernel is evaluated
+     * @return the uniform kernel function evaluation k(u)
+     */
+    double uniform( double u );
+
+};
+
+#endif
Index: dagmc/KDECollision.cpp
===================================================================
--- dagmc/KDECollision.cpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/KDECollision.cpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,140 @@
+// KDECollision.cpp
+
+#include <cmath>
+#include <iostream>
+
+#include "moab/CartVect.hpp"
+
+#include "KDECollision.hpp"
+#include "KDEKernel.hpp"
+
+//-----------------------------------------------------------------------------
+KDECollision::KDECollision( const moab::CartVect & collision_loc,
+                            const moab::CartVect & bandwidth,
+                            KDEKernel* k )
+: Xic( collision_loc ), H( bandwidth ), kernel( k )
+{
+
+  // check bandwidth values are valid
+  for ( int i = 0 ; i < 3 ; ++i ) {
+
+    if ( H[i] <= 0 ) {
+
+      if ( H[i] == 0 )
+        H[i] = 1;
+      
+      H[i] = fabs( H[i] );
+      
+      std::cerr << "\nError! KDE bandwidth value h(" << i << ") is invalid:\n";
+      std::cerr << " using h(" << i << ") = " << H[i] << " in the tally. \n\n";
+      
+    }
+
+  }
+  
+  set_neighborhood();
+
+}
+//-----------------------------------------------------------------------------
+moab::CartVect KDECollision::get_collision()
+{
+  
+  return Xic;
+
+}
+//-----------------------------------------------------------------------------
+moab::CartVect KDECollision::get_bandwidth()
+{
+  
+  return H;
+
+}
+//-----------------------------------------------------------------------------
+void KDECollision::get_neighborhood( double box_min[3], double box_max[3] )
+{
+
+  for ( int i = 0 ; i < 3 ; ++i ) {
+
+    box_min[i] = min[i];
+    box_max[i] = max[i];
+
+  }
+
+}
+//-----------------------------------------------------------------------------
+void KDECollision::change_collision( const moab::CartVect & newXic )
+{
+
+  this->Xic = newXic;
+   set_neighborhood();
+
+}
+//-----------------------------------------------------------------------------
+void KDECollision::change_bandwidth( const moab::CartVect & newH )
+{
+
+  this->H = newH;
+
+  // check bandwidth values are valid
+  for ( int i = 0 ; i < 3 ; ++i ) {
+
+    if ( H[i] <= 0 ) {
+
+      if ( H[i] == 0 )
+        H[i] = 1;
+
+      H[i] = fabs( H[i] );
+      
+      std::cerr << "\nError! KDE bandwidth value h(" << i << ") is invalid:\n";
+      std::cerr << " using h(" << i << ") = " << H[i] << " in the tally. \n\n";
+      
+    }
+
+  }
+
+  set_neighborhood();
+
+}
+//-----------------------------------------------------------------------------
+double KDECollision::compute_contribution( const moab::CartVect & X )
+{
+  
+  double u = 0;
+  double h = 1;
+  double k_xyz = 1;
+  
+  // computes the 3D kernel contribution using product of 1D kernels
+  for ( int i = 0 ; i < 3 ; ++i ) {
+    
+    u = ( X[i] - Xic[i] ) / H[i] ;
+    k_xyz *= kernel->evaluate( u );
+    h *= H[i];
+
+  }      
+  
+  k_xyz = k_xyz / h;  
+
+  return k_xyz;
+
+}
+//-----------------------------------------------------------------------------
+double KDECollision::compute_contribution( const double coords[3] )
+{
+  moab::CartVect X( coords );
+  
+  return compute_contribution( X );
+
+}
+//-----------------------------------------------------------------------------
+void KDECollision::set_neighborhood()
+{
+
+  for ( int i = 0 ; i < 3 ; ++i ) { 
+
+    min[i] = Xic[i] - H[i];
+    max[i] = Xic[i] + H[i];
+
+  }
+
+}
+//-----------------------------------------------------------------------------
Index: dagmc/KDECollision.hpp
===================================================================
--- dagmc/KDECollision.hpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/KDECollision.hpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,100 @@
+// KDECollision.hpp
+
+#ifndef KDECOLLISION_H
+#define KDECOLLISION_H
+
+#include "moab/CartVect.hpp"
+
+#include "KDEKernel.hpp"
+
+/** 
+ * A class that represents the kernel density estimator contribution for one 
+ * collision from a particle's history in a Monte Carlo particle transport
+ * simulation. 
+ */
+class KDECollision {
+
+  public:
+
+    /**
+     * Constructs a kernel density estimator object for the collision point
+     * Xic based on the bandwidth H.
+     *
+     * @param collision the collision point (xic, yic, zic)
+     * @param bandwidth the set of bandwidth values (hx, hy, hz)
+     * @param k the kernel function to be used in the computation
+     */
+    KDECollision( const moab::CartVect & collision,
+                  const moab::CartVect & bandwidth,
+                  KDEKernel* k );
+
+    /**
+     * @return the collision point Xic = (xic, yic, zic)
+     */
+    moab::CartVect get_collision();
+    
+    /**
+     * @return the set of bandwidth values H = (hx, hy, hz)
+     */
+    moab::CartVect get_bandwidth();
+
+    /**
+     * Gets the coordinates of the minimum and maximum corners of the
+     * collision neighborhood for which the contribution is non-zero.
+     *
+     * @param box_min gets the minimum corner of the neighborhood
+     * @param box_max gets the maximum corner of the neighborhood
+     */
+    void get_neighborhood( double box_min[3], double box_max[3] );
+    
+    /**
+     * Changes the collision point and updates the neighborhood to reflect
+     * the new values.
+     *
+     * @param newXic the new collision point (xic, yic, zic)
+     */
+    void change_collision( const moab::CartVect & newXic );
+
+    /**
+     * Changes the set of bandwidth values and updates the neighborhood to
+     * reflect the new values.
+     *
+     * @param newH the new set of bandwidth values (hx, hy, hz)
+     */
+    void change_bandwidth( const moab::CartVect & newH );
+
+    /**
+     * Computes the kernel contribution K_xyz for the collision location Xic
+     * using the given calculation point X.
+     *
+     * @param X the calculation point to be evaluated
+     * @return the kernel density estimator contribution at the given point
+     */
+    double compute_contribution( const moab::CartVect & X );
+
+    /**
+     * Computes the kernel contribution K_xyz for the collision location Xic
+     * using the given calculation point coordinates.
+     *
+     * @param coords the calculation point to be evaluated
+     * @return the kernel density estimator contribution at the given point
+     */
+    double compute_contribution( const double coords[3] );
+
+  private:
+    
+    moab::CartVect Xic;   // the collision point (xic, yic, zic)
+    moab::CartVect H;     // the set of bandwidth values (hx, hy, hz)
+    KDEKernel* kernel;    // the kernel to be used in the computation
+    double min[3];        // minimum corner of collision neighborhood
+    double max[3];        // maximum corner of collision neighborhood
+
+    /**
+     * Sets the neighborhood around the collision point for which a non-zero
+     * contribution occurs.
+     */
+    void set_neighborhood();
+
+};
+
+#endif
Index: dagmc/KDEMeshTally.cpp
===================================================================
--- dagmc/KDEMeshTally.cpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/KDEMeshTally.cpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,635 @@
+// KDEMeshTally.cpp
+
+#include <cassert>
+#include <climits>
+#include <cmath>
+#include <iostream>
+#include <sstream>
+#include <fstream>
+#include <string>
+#include <vector>
+
+#include "moab/AdaptiveKDTree.hpp"
+#include "moab/CartVect.hpp"
+#include "moab/Interface.hpp"
+#include "moab/Range.hpp"
+#include "moab/Types.hpp"
+
+#include "KDECollision.hpp"
+#include "KDEKernel.hpp"
+#include "KDETrack.hpp"
+#include "KDEMeshTally.hpp"
+#include "meshtal_funcs.h"
+
+moab::CartVect KDEMeshTally::default_bandwidth( 1, 1, 1 );
+
+
+//-----------------------------------------------------------------------------
+static double parse_bandwidth_param( const std::string& key,
+                                     const std::string& val, 
+                                     double default_value = 1 )
+{
+  char* end;
+  double ret = strtod( val.c_str(), &end );
+  if( val.c_str() == end || ret <= 0 ){
+    // parsing failed or value is invalid
+    std::cerr << "Error parsing bandwidth param " << key << ": '" << val << "' is invalid" << std::endl;
+    std::cerr << "      Using default value " << key << " = " << default_value << std::endl;
+    ret = default_value;
+  }
+  return ret;
+}
+//-----------------------------------------------------------------------------
+static KDEKernel::KernelType set_kernel_type( const std::string& key,
+                                              const std::string& val )
+{
+
+  KDEKernel::KernelType k;
+
+  if ( val == "epanechnikov" || val == "e" )
+    k = KDEKernel::EPANECHNIKOV;
+  else if ( val == "uniform" || val == "u" )
+    k = KDEKernel::UNIFORM;
+  else {
+
+    k = KDEKernel::EPANECHNIKOV;
+    std::cerr << "\nWarning: " << val << " is not a valid kernel function" << std::endl;
+        std::cerr << "      Using default " << key << " = epanechnikov\n" << std::endl;
+
+  }
+
+  return k;
+
+}
+//-----------------------------------------------------------------------------
+KDEMeshTally* KDEMeshTally::setup( const fmesh_card& fmesh, 
+                                   moab::Interface* mbi, TallyType type )
+{
+
+  bool use_dagmc_mesh = true; // true if mesh data should be pulled from DagMC object
+  std::string input_filename, output_filename;
+  moab::CartVect bandwidth = default_bandwidth;
+  KDEKernel::KernelType kernel = KDEKernel::EPANECHNIKOV;
+  unsigned int subtracks = 0;
+
+  const fmesh_card::fc_params_t& params = fmesh.fc_params;
+  int id = fmesh.id;
+
+  for( fmesh_card::fc_params_t::const_iterator i = params.begin(); i != params.end(); ++i )
+  {
+    std::string key = (*i).first, val = (*i).second;
+
+    if( key == "inp" ){ input_filename = val; use_dagmc_mesh = false; }
+    else if( key == "out" ) output_filename = val;
+    else if( key == "hx" ) bandwidth[0] = parse_bandwidth_param( key, val );
+    else if( key == "hy" ) bandwidth[1] = parse_bandwidth_param( key, val );
+    else if( key == "hz" ) bandwidth[2] = parse_bandwidth_param( key, val );
+    else if( key == "kernel" ) kernel = set_kernel_type( key, val );
+    else if( key == "subtracks" && type != COLLISION ) { 
+      subtracks = atoi( val.c_str() );
+      if( subtracks == 0 ) {
+        std::cerr << "\nWarning: number of subtracks requested is invalid" << std::endl;
+        std::cerr << "      Using default value " << key << " = 3\n" << std::endl;
+        subtracks = 3;
+      }
+    }
+    else{
+      std::cerr << "Warning: KDE tally's FC" << id << " card has unknown key '" << key << "'" << std::endl;
+    }
+  }
+  
+  std::stringstream strbuf;
+  if( output_filename.length() == 0 ){
+    strbuf << "meshtal" << id << ".h5m";
+    strbuf >> output_filename;
+    strbuf.clear();
+  }
+
+  std::cout << "Creating KDE ";
+
+  if ( type == COLLISION ) std::cout << "collision ";
+  else if ( type == TRACKLENGTH ) std::cout << "track ";
+  else std::cout << "subtrack ";
+ 
+  std::cout << "fmesh" << id 
+            << ", input: " << (use_dagmc_mesh ? "(pre-loaded DagMC data)" : input_filename.c_str())  
+            << ", output: " << output_filename << std::endl;
+  
+  std::cout << "   using the " << KDEKernel::kernel_names[kernel] << " kernel";
+  std::cout << " with bandwidth = " << bandwidth;
+
+  if ( subtracks != 0 )
+    std::cout << "\n   and splitting tracks into " << subtracks << " subtracks" << std::endl;
+  else
+    std::cout << std::endl;
+
+  moab::EntityHandle moab_set = NULL ; // TODO: this should be queried from DagMC
+  if( !use_dagmc_mesh ){
+   
+    moab::ErrorCode rval;
+    rval = mbi->create_meshset( moab::MESHSET_SET, moab_set );
+    assert( rval == moab::MB_SUCCESS );
+
+    rval = mbi->load_file( input_filename.c_str(), &moab_set );
+
+    if( rval != moab::MB_SUCCESS ){
+      std::cerr << "Error: could not load KDE tally mesh file " << input_filename << std::endl;
+      exit( EXIT_FAILURE );
+    }
+
+  }
+
+  KDEMeshTally *kde = new KDEMeshTally( fmesh, mbi, moab_set, bandwidth,
+                                        type, kernel, subtracks );
+  kde->output_filename = output_filename;
+
+  // create a tally set that contains only the 3D mesh cells (i.e. hexes/tets)
+  moab::ErrorCode rval;
+  rval = mbi->create_meshset( moab::MESHSET_SET, kde->tally_set );
+  assert( rval == moab::MB_SUCCESS );
+
+  moab::Range mesh_cells;
+  rval = mbi->get_entities_by_dimension( moab_set, 3, mesh_cells );
+  assert( rval == moab::MB_SUCCESS );
+   
+  rval = mbi->add_entities( kde->tally_set, mesh_cells );
+  assert( rval == moab::MB_SUCCESS );
+
+  return kde;
+
+}
+//-----------------------------------------------------------------------------
+KDEMeshTally::KDEMeshTally( const fmesh_card& settings,
+                            moab::Interface* moabMesh,
+                            moab::EntityHandle moabSet,
+                            moab::CartVect bandwidth,
+                            KDEMeshTally::TallyType type,
+                            KDEKernel::KernelType k,
+                            unsigned int numSubtracks )
+: MeshTally(settings), mb( moabMesh ), bandwidth( bandwidth ),
+  kde_tally( type ), kernel( new KDEKernel(k) )
+{
+
+  build_tree(moabSet); 
+
+  // initialize running variance variables
+  max_collisions = false;
+  numCollisions = 0;
+  Mn = moab::CartVect( 0, 0, 0 );
+  Sn = moab::CartVect( 0, 0, 0 );
+
+  // check numSubtracks is a valid parameter for SUBTRACK tallies
+  if ( numSubtracks == 0 && kde_tally == SUBTRACK ) {
+
+    std::cerr << "\nWarning: number of subtracks must be non-zero for KDE subtrack tallies" << std::endl;
+    std::cerr << "      Using default value subtracks = 3\n" << std::endl;
+    subtracks = 3;
+
+  }
+  else
+    subtracks = numSubtracks;
+  
+}
+//-----------------------------------------------------------------------------
+KDEMeshTally::~KDEMeshTally()
+{
+
+  delete tree;
+  delete kernel;
+  
+}
+//-----------------------------------------------------------------------------
+void KDEMeshTally::tally_collision( const KDEWeightParam & param,
+                                    const moab::CartVect & collision_loc, 
+                                    int ebin )
+{
+
+  // make sure cross section parameter has been set properly
+  if ( param.total_xs == NULL ) {
+
+    std::cerr << "\nError: cross section parameter set to NULL" << std::endl;
+    exit( EXIT_FAILURE );
+
+  } 
+ 
+  // make a KDECollision object to represent a single collision location
+  KDECollision collision( collision_loc, bandwidth, kernel );
+
+  // get valid neighborhood dimensions for non-zero contributions to tally
+  double min[3];
+  double max[3];
+
+  collision.get_neighborhood( min, max );
+
+  // find all the calculation points within the valid neighborhood
+  std::vector<moab::EntityHandle> calc_points;
+  moab::ErrorCode rval = points_in_box( *tree, tree_root, min, max, calc_points );
+  assert( moab::MB_SUCCESS == rval );  
+
+  // get the tally weighting factor for this collision
+  double weight = get_score_weight( param );
+
+  // compute the contribution for all calculation points in this neighborhood
+  std::vector<moab::EntityHandle>::iterator i;
+  moab::EntityHandle point;
+  double contribution = 0;
+  double coords[3];
+
+  for ( i = calc_points.begin() ; i != calc_points.end() ; ++i ) {
+
+    point = *i;
+    rval = mb->get_coords( &point, 1, coords );
+    assert( moab::MB_SUCCESS == rval );  
+
+    contribution = weight * collision.compute_contribution( coords );
+    
+    // add results to the mesh tally for the current history
+    add_score_to_tally( point, contribution, ebin );
+
+  }
+    
+  // add collision to the running variance used in computing optimal bandwidth
+  update_bandwidth_variance( collision_loc );
+
+}
+//-----------------------------------------------------------------------------
+void KDEMeshTally::tally_track( const KDEWeightParam & param,
+                                const moab::CartVect & start_point,
+                                const moab::CartVect & direction, 
+                                int ebin )
+{
+
+  // make sure track length parameter has been set properly
+  if ( param.tracklength == NULL ) {
+
+    std::cerr << "\nError: track length parameter set to NULL" << std::endl;
+    exit( EXIT_FAILURE );
+
+  } 
+
+  // set the number of subtracks to be tallied only for SUBTRACK tallies
+  unsigned int tally_subtracks = 0;
+
+  if ( kde_tally == SUBTRACK )
+    tally_subtracks = subtracks;
+
+  // make a KDETrack object to represent a single track segment
+  KDETrack track( start_point, direction, bandwidth, *(param.tracklength),
+                  kernel, tally_subtracks );
+    
+  // get valid neighborhood dimensions for non-zero contributions to tally
+  double min[3];
+  double max[3];
+  double radius = 0;
+
+  track.get_neighborhood( min, max, radius );
+
+  // find all the calculation points within the valid neighborhood
+  std::vector<moab::EntityHandle> calc_points;
+  moab::ErrorCode rval = points_in_box( *tree, tree_root, min, max, calc_points );
+  assert( moab::MB_SUCCESS == rval );  
+
+  // get the tally weighting factor for this track
+  double weight = get_score_weight( param );
+
+  // compute the contribution for all calculation points in this neighborhood
+  std::vector<moab::EntityHandle>::iterator i;
+  moab::EntityHandle point;
+  double contribution = 0;
+  double coords[3];
+
+  for ( i = calc_points.begin() ; i != calc_points.end() ; ++i ) {
+
+    point = *i;
+    rval = mb->get_coords( &point, 1, coords );
+    assert( moab::MB_SUCCESS == rval );  
+
+    contribution = weight * track.compute_contribution( coords );
+
+    // add results to the mesh tally for the current history
+    add_score_to_tally( point, contribution, ebin );
+    
+  }
+    
+  // TODO need to determine how to compute an optimal bandwidth with a track
+  // This could be done using the subtracks/choose_points feature for both
+  // SUBTRACK and TRACKLENGTH tallies.  For SUBTRACK tallies, simply would
+  // need access to the subtrack_points vector in KDETrack.  For TRACKLENGTH
+  // tallies, would need to use the choose_points function to get the points.
+  // update_bandwidth_variance( collision_loc );
+
+}
+//-----------------------------------------------------------------------------
+void KDEMeshTally::end_history()
+{
+  
+  std::set<moab::EntityHandle>::iterator i;
+ 
+  // add results from current history to the tally for each calculation point
+  for ( i = visited_this_history.begin() ; i != visited_this_history.end() ; ++i ) {
+    
+    for( unsigned int j = 0; j < ebins; ++j ){
+      double& history = data_ref( temp_tally_data, *i, j );
+      double& tally =   data_ref( tally_data, *i, j );
+      double& error =   data_ref( error_data, *i, j );
+      
+      tally += history;
+      error += ( history * history );
+      
+      // reset temp_tally for the next particle history
+      history = 0;
+      
+    }
+  }
+  visited_this_history.clear();
+
+}
+//-----------------------------------------------------------------------------
+void KDEMeshTally::print( double sp_norm, double fmesh_fact )
+{
+
+  // tags tally/error results to the nodes and writes mesh to output file
+  write_results( sp_norm, fmesh_fact );
+
+}
+//-----------------------------------------------------------------------------
+void KDEMeshTally::write_results( double sp_norm, double fmesh_fact )
+{
+
+  double tally = 0;
+  double error = 0, rel_err = 0;
+  
+  moab::ErrorCode rval = moab::MB_SUCCESS;
+
+  // print the optimal bandwidth if it was computed
+  if ( kde_tally == COLLISION ) {
+  
+    std::cout << std::endl << "optimal bandwidth for " << numCollisions;
+    std::cout  << " collisions is: " << get_optimal_bandwidth() << std::endl;
+
+  }
+
+  // tag tally and relative error results to the mesh for each entity
+  moab::Range::iterator i;
+  
+  for ( i = tally_ents.begin() ; i != tally_ents.end() ; ++i ) {
+
+    moab::EntityHandle point = *i;
+
+    for ( unsigned int j = 0; j < ebins; ++ j){
+
+      tally = data_ref( tally_data, point, j);
+      error = data_ref( error_data, point, j );
+      
+      // compute relative error for the tally
+      // Use 0 as the rel_err value if nothing has been computed for this tally point;
+      // this reflects MCNP's approach to avoiding a divide-by-zero situation.
+      rel_err = 0; 
+      if( error != 0 ){
+        rel_err = sqrt( error / ( tally * tally ) - 1.0 / sp_norm );
+      }
+      
+      // normalizing mesh tally results by the number of source particles
+      tally /= sp_norm;
+      
+      // applying the fmesh multiplication FACTOR to the mesh tally results
+      tally *= fmesh_fact;
+      
+      // set tally and error tag values for this entity
+      rval = mb->tag_set_data( tally_tags[j], &point, 1, &tally );
+      assert( moab::MB_SUCCESS == rval );
+      
+      rval = mb->tag_set_data( error_tags[j], &point, 1, &rel_err );
+      assert( moab::MB_SUCCESS == rval ); 
+      
+    } 
+    
+  }
+
+  // create a global tag to store the bandwidth value
+  moab::Tag bandwidth_tag;
+  rval = mb->tag_get_handle( "BANDWIDTH_TAG", 3, moab::MB_TYPE_DOUBLE, bandwidth_tag,
+                             moab::MB_TAG_MESH|moab::MB_TAG_CREAT );
+  assert( moab::MB_SUCCESS == rval );
+
+  // add bandwidth tag to the root set
+  moab::EntityHandle bandwidth_set = mb->get_root_set();
+  rval = mb->tag_set_data( bandwidth_tag, &bandwidth_set, 1, &bandwidth );
+  assert( moab::MB_SUCCESS == rval );
+
+  // define list of tags to include and write mesh to output file
+  std::vector<moab::Tag> output_tags = tally_tags;
+  output_tags.insert( output_tags.end(), error_tags.begin(), error_tags.end() );
+  output_tags.push_back( bandwidth_tag );  
+
+  rval = mb->write_file( output_filename.c_str(),
+                         NULL, NULL, &tally_set, 1, &(output_tags[0]), output_tags.size() );
+  assert( moab::MB_SUCCESS == rval );
+  
+}
+//-----------------------------------------------------------------------------
+void KDEMeshTally::build_tree( moab::EntityHandle meshset )
+{
+
+  // Obtain all of the calculation points in the mesh and store into tally_ents
+  moab::EntityType type = moab::MBVERTEX;
+  
+  moab::ErrorCode rval = mb->get_entities_by_type( meshset, type, tally_ents );
+  assert( moab::MB_SUCCESS == rval );  
+
+  resize_data_arrays( tally_ents.size() );
+    
+  // Measure the number of divisions in the moab::Range used to represent the tally points
+  // If there are many divisions (for some rather arbitrary definition of "many"), print
+  // a warning about performance compromise
+  int psize = tally_ents.psize();
+  std::cout << "   Tally range has psize: " << psize << std::endl;
+  if( psize > 4 ){
+    std::cerr << "Warning: large tally range psize " << psize 
+              << ", may reduce performance." << std::endl;
+  }
+  // Build a KD-tree using all of the calculation points in the mesh
+  moab::AdaptiveKDTree::Settings settings;
+  settings.maxEntPerLeaf = 10;
+  settings.maxTreeDepth = 30;
+
+  tree = new moab::AdaptiveKDTree( mb );
+  rval = tree->build_tree( tally_ents, tree_root, &settings );
+  assert( moab::MB_SUCCESS == rval );  
+
+  rval = setup_tags( mb, "KDE_" );
+
+}
+//-----------------------------------------------------------------------------
+void KDEMeshTally::update_bandwidth_variance( const moab::CartVect & collision_loc )
+{
+ 
+  if ( numCollisions != LLONG_MAX ) {
+
+    ++numCollisions;
+    
+    // obtain previous value for the mean
+    moab::CartVect Mn_prev = Mn;
+  
+    // compute new values for the mean and variance
+    if ( numCollisions == 1 )
+      Mn = collision_loc;
+    else {
+
+      Mn += ( collision_loc - Mn_prev ) / numCollisions;
+    
+      for ( int i = 0 ; i < 3 ; ++i )
+        Sn[i] += ( collision_loc[i] - Mn_prev[i] ) * ( collision_loc[i] - Mn[i] );
+    
+    }
+
+  }
+  else if ( !max_collisions ) {
+  
+    std::cerr << "/nWarning: number of collisions exceeds maximum/n"
+              << "  optimal bandwidth will be based on " << numCollisions
+              << " collisions./n/n";
+
+    max_collisions = true;
+
+  }
+
+}
+//-----------------------------------------------------------------------------
+moab::CartVect KDEMeshTally::get_optimal_bandwidth()
+{
+  
+  double stdev = 0;
+  moab::CartVect optimal_bandwidth;
+  
+  for ( int i = 0 ; i < 3 ; ++i ) {
+
+    stdev = sqrt( Sn[i] / ( numCollisions - 1 ) );
+    optimal_bandwidth[i] = 0.968625 * stdev * pow( numCollisions, -1.0/7.0 );
+
+  }
+
+  return optimal_bandwidth;
+
+}
+//-----------------------------------------------------------------------------
+double KDEMeshTally::get_score_weight( const KDEWeightParam & param )
+{
+
+  double score_weight = 1;
+  double d = 1;  // track length set to 1 so it does not change weight
+  
+  if ( kde_tally == SUBTRACK )
+    d = *(param.tracklength);  // use actual track length for SUBTRACK tallies
+  
+  // determine the tally weighting factor from MCNP
+  mcnp_weight_calculation( param.fmesh_index, param.energy, param.particle_wgt,
+                           &d, &score_weight );
+  
+  // divide weight by total cross section for COLLISION tallies only
+  if ( kde_tally == COLLISION )
+    score_weight /= *(param.total_xs);
+
+  return score_weight;
+
+}
+//-----------------------------------------------------------------------------
+void KDEMeshTally::add_score_to_tally( moab::EntityHandle mesh_point,
+                                       double score,
+                                       int ebin )
+{
+
+  data_ref( temp_tally_data, mesh_point, ebin ) += score;
+
+  // tally the total energy bin if requested
+  if ( fmesh.total_energy_bin )
+    data_ref( temp_tally_data, mesh_point, (ebins-1) ) += score;
+
+  visited_this_history.insert( mesh_point );
+
+}
+//-----------------------------------------------------------------------------
+moab::ErrorCode
+  KDEMeshTally::points_in_box( moab::AdaptiveKDTree & tree,
+                               moab::EntityHandle tree_root,
+                               const double box_min[3],
+                               const double box_max[3],
+                               std::vector<moab::EntityHandle> & points )
+{
+  
+  // determine the center point of the box
+  double box_center[3];
+  
+  for ( int i = 0 ; i < 3 ; ++i )
+    box_center[i] = 0.5 * ( box_max[i] + box_min[i] );  
+  
+  // set radius equal to distance from the center to the max corner of box
+  moab::CartVect max_corner( box_max );
+  moab::CartVect center( box_center );
+  max_corner -= center;  
+  double radius = max_corner.length();
+  
+  // find all leaves of the tree within the given radius
+  std::vector<moab::EntityHandle> leaves;
+  moab::ErrorCode rval =
+    tree.leaves_within_distance( tree_root, box_center, radius, leaves );
+  
+  if ( moab::MB_SUCCESS != rval )
+    return rval;
+
+  // obtain the set of unique points in the box 
+  std::vector<moab::EntityHandle>::iterator i; 
+  moab::Interface* mb = tree.moab();
+  moab::Range leaf_points;
+  moab::Range::iterator j;
+  moab::EntityHandle point;
+  double coords[3];
+  
+  // iterate through the leaves
+  for ( i = leaves.begin() ; i != leaves.end() ; ++i) {
+
+    leaf_points.clear();
+    rval = mb->get_entities_by_type( *i, moab::MBVERTEX, leaf_points );
+    
+    if ( moab::MB_SUCCESS != rval )
+      return rval;
+  
+    // iterate through the points in each leaf  
+    for ( j = leaf_points.begin() ; j != leaf_points.end() ; ++j ) {
+
+      point = *j;
+      rval = mb->get_coords( &point, 1, coords );
+    
+      if ( moab::MB_SUCCESS != rval )
+        return rval;
+
+      // check point is in the box
+      bool in_box = true;
+      int k = 0;
+
+      do {
+
+        if ( coords[k] < box_min[k] || coords[k] > box_max[k] )
+          in_box = false;
+
+        ++k;
+
+      }
+      while ( true && k < 3 );
+      
+      // add the point to the set if it is in the box
+      if ( in_box )
+        points.push_back( point );
+
+    }
+
+  }
+  
+  // remove duplicates from points vector
+  std::sort( points.begin(), points.end() );
+  points.erase( std::unique( points.begin(), points.end() ), points.end() );
+  
+  return moab::MB_SUCCESS;
+
+}
+//-----------------------------------------------------------------------------
Index: dagmc/KDETrack.cpp
===================================================================
--- dagmc/KDETrack.cpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/KDETrack.cpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,426 @@
+// KDETrack.cpp
+
+#include <cmath>
+#include <cstdlib>
+#include <iostream>
+#include <vector>
+
+#include "moab/CartVect.hpp"
+
+#include "KDETrack.hpp"
+#include "KDEKernel.hpp"
+
+// quadrature points and weights for the integrate_path_kernel function
+const double quad_points[4] = { 0.339981043585, -0.339981043585,
+                                0.861136311594, -0.861136311594 };
+
+const double quad_weights[4] = { 0.652145154863, 0.652145154863,
+                                 0.347854845137, 0.347854845137 };
+
+// initializing static variable
+bool KDETrack::seed_is_set = false;
+ 
+//-----------------------------------------------------------------------------
+KDETrack::KDETrack( KDEKernel* k )
+{
+  
+  // set up the track segment
+  moab::CartVect Xo( 0, 0, 0 );
+  track.Xo = Xo;
+
+  moab::CartVect Uo( 1, 0, 0 );
+  track.Uo = Uo;
+
+  track.length = 1.0;
+  
+  // set the bandwidth, kernel function and neighborhood
+  H = Xo + 0.1;
+
+  kernel = k;
+
+  set_neighborhood();
+
+}
+//-----------------------------------------------------------------------------
+KDETrack::KDETrack( const moab::CartVect & start_point,
+                    const moab::CartVect & direction,
+                    const moab::CartVect & bandwidth,
+                    const double track_length,
+                    KDEKernel* k,
+                    unsigned int numSubtracks )
+: H( bandwidth ), kernel( k )
+{
+  
+  // set up the track segment
+  track.Xo = start_point;
+  track.Uo = direction;
+  track.length = track_length;
+
+  // check bandwidth values are valid
+  for ( int i = 0 ; i < 3 ; ++i ) {
+
+    if ( H[i] <= 0 ) {
+
+      if ( H[i] == 0 )
+        H[i] = 1;
+
+      H[i] = fabs( H[i] );
+      
+      std::cerr << "\nError! KDE bandwidth value h(" << i << ") is invalid:\n";
+      std::cerr << " using h(" << i << ") = " << H[i] << " in the tally. \n\n";
+      
+    }
+
+  }
+  
+  set_neighborhood();
+
+  // store random points along the track if subtrack estimator is requested
+  if ( numSubtracks > 0 )
+    subtrack_points = choose_points( numSubtracks );
+
+}
+//-----------------------------------------------------------------------------
+moab::CartVect KDETrack::get_start_point()
+{
+  
+  return track.Xo;
+
+}
+//-----------------------------------------------------------------------------
+moab::CartVect KDETrack::get_direction()
+{
+  
+  return track.Uo;
+
+}
+//-----------------------------------------------------------------------------
+moab::CartVect KDETrack::get_bandwidth()
+{
+  
+  return H;
+
+}
+//-----------------------------------------------------------------------------
+double KDETrack::get_length()
+{
+  
+  return track.length;
+
+}
+//-----------------------------------------------------------------------------
+void KDETrack::get_neighborhood( double box_min[3],
+                                 double box_max[3],
+                                 double & max_radius )
+{
+
+  for ( int i = 0 ; i < 3 ; ++i ) {
+
+    box_min[i] = min[i];
+    box_max[i] = max[i];
+
+  }
+
+  max_radius = radius;
+  
+}
+//-----------------------------------------------------------------------------
+void KDETrack::change_track_segment( const moab::CartVect & newXo,
+                                     const moab::CartVect & newUo,
+                                     const double newLength )
+{
+
+  track_segment newTrack;
+  newTrack.Xo = newXo;
+  newTrack.Uo = newUo;
+  newTrack.length = newLength;
+
+  this->track = newTrack;
+
+  // update neighborhood to reflect new track segment
+  set_neighborhood();
+
+  // update subtrack_points to reflect new track segment (if non-empty)
+  if ( !subtrack_points.empty() )
+    subtrack_points = choose_points( subtrack_points.size() );
+
+}
+//-----------------------------------------------------------------------------
+void KDETrack::change_bandwidth( const moab::CartVect & newH )
+{
+
+  this->H = newH;
+
+  // check bandwidth values are valid
+  for ( int i = 0 ; i < 3 ; ++i ) {
+
+    if ( H[i] <= 0 ) {
+
+      if ( H[i] == 0 )
+        H[i] = 1;
+
+      H[i] = fabs( H[i] );
+      
+      std::cerr << "\nError! KDE bandwidth value h(" << i << ") is invalid:\n";
+      std::cerr << " using h(" << i << ") = " << H[i] << " in the tally. \n\n";
+      
+    }
+
+  }
+
+  // update neighborhood to reflect new bandwidth
+  set_neighborhood();
+
+}
+//-----------------------------------------------------------------------------
+bool KDETrack::point_within_max_radius( const moab::CartVect & X )
+{
+
+  // create a vector from the point Xo to the point X
+  moab::CartVect B;
+
+  for ( int i = 0 ; i < 3 ; ++i )
+    B[i] = X[i] - track.Xo[i];
+
+  // compute perpendicular distance from X to the line defined by the track
+  double r = ( track.Uo * B ).length();
+  
+  // return true if r is less than max_radius
+  if ( r < radius )
+    return true;
+  else
+    return false;
+
+}
+//-----------------------------------------------------------------------------
+double KDETrack::compute_contribution( const moab::CartVect & X )
+{
+
+  if ( subtrack_points.empty() ) {
+
+    // use integral estimator if subtrack_points is empty
+    return integrate_path_kernel( X );
+
+  }
+  else {
+
+    // otherwise use the subtrack estimator
+    return sum_subtracks( X );
+
+  }
+
+}
+//-----------------------------------------------------------------------------
+double KDETrack::compute_contribution( const double coords[3] )
+{
+
+  moab::CartVect X( coords );
+  
+  return compute_contribution( X );
+
+}
+//-----------------------------------------------------------------------------
+std::vector<moab::CartVect> KDETrack::choose_points( int p )
+{
+
+  // check number of subtrack points is valid
+  if ( p <= 0 ) {
+
+    p = 1;
+    std::cerr << "\nError! Number of subtrack points is invalid:\n";
+    std::cerr << " using p = 1. \n\n";
+
+  }
+
+  std::vector<moab::CartVect> random_points;
+
+  // set random number generator seed if it has not yet been set
+  if ( !seed_is_set ) {
+    srand( time(NULL) );
+    seed_is_set = true;
+  }
+
+  // compute subtrack length, assumed to be equal for all subtracks
+  double subtrack_length = track.length / p;
+
+  // set the starting point to the beginning of the track
+  moab::CartVect start_point = track.Xo;
+ 
+  // choose a random position along each subtrack
+  for ( int i = 0 ; i < p ; ++i ) {
+    
+    double path_length = rand() * subtrack_length / RAND_MAX;
+    
+    // add the coordinates of the corresponding point
+    random_points.push_back( start_point + path_length * track.Uo );
+    
+    // shift starting point to the next subtrack
+    start_point += subtrack_length * track.Uo;
+    
+  }
+  
+  return random_points;
+
+}
+//-----------------------------------------------------------------------------
+void KDETrack::set_neighborhood()
+{
+
+  for ( int i = 0 ; i < 3 ; ++i ) {
+
+    // default case where Uo_coord is zero
+    min[i] = -H[i] + track.Xo[i];
+    max[i] = H[i] + track.Xo[i];
+  
+    // adjust for direction being positive or negative
+    double Uo_coord = track.Uo[i];
+  
+    if ( Uo_coord > 0 )
+      max[i] += track.length * Uo_coord;
+    else if ( Uo_coord < 0 )
+      min[i] += track.length * Uo_coord;
+
+  }
+
+  // set maximum radius around the track
+  radius = H.length();
+
+}
+//-----------------------------------------------------------------------------
+bool KDETrack::set_integral_limits( const moab::CartVect & X,
+                                    double & lower, double & upper )
+{
+  
+  // set initial integral limits to the full track length (default values)
+  lower = 0;
+  upper = track.length;
+  
+  // check limits against the valid path length interval for each dimension
+  for ( int i = 0 ; i < 3 ; ++i ) {
+
+    double Uo_coord = track.Uo[i];
+    double path_min = lower;
+    double path_max = upper;
+  
+    // compute the valid path length interval S = [ path_min, path_max ]
+    if ( Uo_coord > 0 ) {
+    
+      path_min = ( -H[i] + X[i] - track.Xo[i] ) / Uo_coord;
+      path_max = ( H[i] + X[i] - track.Xo[i] ) / Uo_coord;
+
+    }
+    else if ( Uo_coord < 0 ) {
+  
+      path_min = ( H[i] + X[i] - track.Xo[i] ) / Uo_coord;
+      path_max = ( -H[i] + X[i] - track.Xo[i] ) / Uo_coord;
+  
+    }
+
+    // set lower limit to highest minimum
+    if ( path_min > lower )
+      lower = path_min;
+
+    // set upper limit to lowest maximum
+    if ( path_max < upper )
+      upper = path_max;
+
+  }
+  
+  // only add limits if the upper limit is greater than the lower limit
+  if ( lower < upper )
+    return true;
+  else
+    return false;
+    
+}
+//-----------------------------------------------------------------------------
+// NOTE: integrate_path_kernel uses the 4-point gaussian quadrature method
+double KDETrack::integrate_path_kernel( const moab::CartVect & X )
+{
+
+  // determine the limits of integration
+  double lower = 0;
+  double upper = 0;
+  
+  bool limits_set = set_integral_limits( X, lower, upper );
+
+  // compute value of the integral only if valid limits exist
+  if ( limits_set ) {
+
+    // define scaling constants
+    double c1 = 0.5 * ( upper - lower );
+    double c2 = 0.5 * ( upper + lower );
+    
+    // sum contributions for all quadrature points
+    double sum = 0;
+    
+    for ( int i = 0 ; i < 4 ; ++i ) {
+  
+      // define scaled quadrature point
+      double s = c1 * quad_points[i] + c2;
+      
+      // compute the value of the kernel function k(X,s)
+      double h = 1;
+      double k_xyz = 1;
+    
+      for ( int j = 0 ; j < 3 ; ++j ) {
+
+        double u = ( X[j] - track.Xo[j] - s * track.Uo[j] ) / H[j];
+        
+        k_xyz *= kernel->evaluate( u );
+        h *= H[j];
+       
+      }
+      
+      k_xyz = k_xyz / h;
+      
+      // multiply by quadrature weight and add to sum
+      sum += quad_weights[i] * k_xyz;
+
+    }
+
+    // return value of the integral
+    return c1 * sum;
+
+  }
+  else
+    return 0;
+
+}
+//-----------------------------------------------------------------------------
+double KDETrack::sum_subtracks( const moab::CartVect & X )
+{
+
+  double sum = 0;
+
+  std::vector<moab::CartVect>::iterator i;
+
+  for ( i = subtrack_points.begin() ; i != subtrack_points.end() ; ++i ) {
+
+    // compute the value of the kernel function k(X)
+    double h = 1; 
+    double k_xyz = 1;
+
+    for ( int j = 0 ; j < 3 ; ++j ) {
+      
+      double u = ( X[j] - (*i)[j] ) / H[j];
+ 
+      k_xyz *= kernel->evaluate( u );
+      h *= H[j];
+
+    }
+
+    k_xyz = k_xyz / h;
+
+    // add kernel contribution for subtrack point to sum
+    sum += k_xyz;
+
+  }
+  
+  // normalize by the total number of subtrack points
+  sum = sum / subtrack_points.size();
+
+  return sum;
+
+}
+//-----------------------------------------------------------------------------
Index: dagmc/TrackLengthMeshTally.cpp
===================================================================
--- dagmc/TrackLengthMeshTally.cpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/TrackLengthMeshTally.cpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,953 @@
+#include <iostream>
+#include <sstream>
+#include <cmath>
+#include <set>
+
+#include "moab/Range.hpp"
+#include "moab/GeomUtil.hpp"
+#include "moab/AdaptiveKDTree.hpp"
+#include "moab/OrientedBoxTreeTool.hpp"
+#include "moab/Skinner.hpp"
+#include "moab/CN.hpp"
+  
+
+/* Two macros are available: 
+ * MESHTAL_DEBUG: produce much debugging output, with histories of particular particle tracks.
+ *
+ * MESHTAL_FORCE_ASSERTS: force use of assert(), regardless of compile settings.  Useful for 
+ *     testing at scale; asserts do not lead to substantial slowdown at run time.
+ *     MESHTAL_DEBUG implies MESHTAL_FORCE_ASSERTS.
+ */
+
+#ifdef MESHTAL_DEBUG
+#define MESHTAL_FORCE_ASSERTS
+#endif 
+
+#ifdef MESHTAL_FORCE_ASSERTS
+#undef NDEBUG 
+#endif
+
+#include <cassert>
+
+// the header file has at least one assert, so keep this include below the macro checks
+#include "TrackLengthMeshTally.hpp"
+#include "meshtal_funcs.h"
+
+
+// tolerance for ray-triangle intersection tests
+// (note: this paramater is ignored by GeomUtil, so don't bother trying to tune it)
+#define TRIANGLE_INTERSECTION_TOL 1e-6
+
+// If the following is defined, use OBB trees for ray-triangle intersections,
+// otherwise use KD tree
+//#define USE_OBB_TREE_RAY_TRACING
+
+/* Tetrahedron volume code taken from MOAB/tools/measure.cpp */
+inline static double tet_volume( const moab::CartVect& v0,
+                                 const moab::CartVect& v1,
+                                 const moab::CartVect& v2,
+                                 const moab::CartVect& v3 )
+{
+  return 1./6. * ( ((v1 - v0) * (v2 - v0)) % (v3 - v0) );
+}
+
+
+
+// Adapted from MOAB's convert.cpp
+// Parse list of integer ranges, e.g. "1,2,5-10,12"
+static
+bool parse_int_list( const char* string, std::set<int>& results )
+{
+  bool okay = true;
+  char* mystr = strdup( string );
+  for (const char* ptr = strtok(mystr, ", \t"); ptr; ptr = strtok(0,", \t"))
+  {
+    char* endptr;
+    long val = strtol( ptr, &endptr, 0 );
+    if (endptr == ptr) {
+      std::cerr << "Not an integer: \"" << ptr << '"' << std::endl;
+      okay = false;
+      break;
+    }
+    
+    long val2 = val;
+    if (*endptr == '-') {
+      const char* sptr = endptr+1;
+      val2 = strtol( sptr, &endptr, 0 );
+      if (endptr == sptr) {
+        std::cerr << "Not an integer: \"" << sptr << '"' << std::endl;
+        okay = false;
+        break;
+      }
+      if (val2 < val) {
+        std::cerr << "Invalid id range: \"" << ptr << '"' << std::endl;
+        okay = false;
+        break;
+      }
+    }
+    
+    if (*endptr) {
+      okay = false;
+      break;
+    }
+    
+    for (; val <= val2; ++val)
+      results.insert( (int)val );
+
+  }
+  
+  free( mystr );
+  return okay;    
+}
+
+extern "C"{
+extern int namchg_( int*, int* );
+}
+
+static 
+bool map_conformal_names( std::set<int>& input, std::set<int>& output ){
+  
+  for( std::set<int>::iterator i = input.begin(); i!=input.end(); ++i){
+    int x, y, one = 1;
+    x = *i;
+    y = namchg_( &one, &x );
+#ifdef MESHTAL_DEBUG
+    std::cerr << "namchg mapped cell " << *i << " to name " << y << std::endl;
+#endif
+    if( y == 0 ){
+        std::cerr << " conformality cell " << *i << " does not exist." << std::endl;
+        return false;
+    }
+    output.insert( y );
+  }
+  return true;
+}
+
+namespace moab { 
+
+
+
+TrackLengthMeshTally* TrackLengthMeshTally::setup( const fmesh_card& fmesh_params, 
+                                                   Interface* mbi, const int* current_mcnp_cell )
+{
+
+  const fmesh_card::fc_params_t& fc_params = fmesh_params.fc_params;
+
+  std::string input_filename, output_filename, tag_name;
+  std::vector<std::string> tag_values;
+
+  bool convex_flag = false, conformal_flag = false;
+  std::set<int> conf_tmp, *conformality = NULL;
+  bool conformal_surface_source = false;
+
+  int id = fmesh_params.id;
+
+  for( fmesh_card::fc_params_t::const_iterator i = fc_params.begin();
+       i != fc_params.end(); ++i )
+  {
+    std::string key = (*i).first, val = (*i).second;
+    if( key == "inp" ) input_filename = val;
+    else if( key == "out" ) output_filename = val;
+    else if( key == "tag" ) tag_name = val;
+    else if( key == "tagval" ) tag_values.push_back(val);
+    else if( key == "convex" && (val == "t" || val == "true" ) ) convex_flag = true; 
+    else if( key == "conf_surf_src" && (val == "t" || val == "true" ) ) conformal_surface_source = true;
+    else if( key == "conformal" ) { 
+
+      if( !conformality ) conformality = new std::set<int>();
+      if( !parse_int_list( val.c_str(), *conformality ) ){
+        std::cerr << "Error: FC" << id << " card has bad conformality value '" << val << "'" << std::endl;
+        exit(EXIT_FAILURE);
+      }
+      if( !map_conformal_names( *conformality, conf_tmp ) ){
+        std::cerr << "Error: a conformal cell does not exist in the problem!" << std::endl;
+        exit(EXIT_FAILURE);
+      }
+
+    }
+    else{
+      std::cerr << "Warning: FC" << id << " card has unknown key '" << key << "'" << std::endl;
+    }
+  }
+  
+  std::stringstream strbuf;
+  if( input_filename.length() == 0 ){
+    strbuf << "fmesh" << id << ".h5m";
+    strbuf >> input_filename;
+    strbuf.clear();
+  }
+  if( output_filename.length() == 0 ){
+    strbuf << "meshtal" << id << ".h5m";
+    strbuf >> output_filename;
+    strbuf.clear();
+  }
+
+  std::cout << "Creating dagmc fmesh" << id 
+            << ", input: " << input_filename 
+            << ", output: " << output_filename << std::endl;
+
+  if( tag_name != "" ){
+    std::cout << "  using tag name='" << tag_name << "'";
+    if( tag_values.size() > 0 ){
+      std::cout <<", and tag values= " << std::endl;
+      for( unsigned int i = 0; i < tag_values.size(); ++i ){
+        std::cout << "    '" << tag_values[i] << "'" << std::endl;
+      }
+    }
+    std::cout << std::endl;
+  }
+
+  if( convex_flag ){ 
+    std::cout << "  user asserts that this tally mesh has convex geometry." << std::endl;
+  }
+  
+  if( conformality ){
+    std::cout << "  conformal to cells " << std::flush;
+    for( std::set<int>::iterator i = conformality->begin(); i!=conformality->end(); ){
+      std::cout << *i; 
+      if( ++i != conformality->end() ) std::cout << ", ";
+    }
+    std::cout << std::endl; 
+    *conformality = conf_tmp;
+  }
+
+  moab::TrackLengthMeshTally *mt = new moab::TrackLengthMeshTally( fmesh_params, mbi, output_filename );
+  
+  if( convex_flag && conformal_flag ){
+    std::cerr << "Warning: FC" << id << " specifies both conformal and convex logic; using conformal logic." << std::endl;
+  }
+  if( conformality ){
+    mt->mcnp_current_cell = current_mcnp_cell;
+    mt->conformality = conformality;
+    mt->conformal_surface_source = conformal_surface_source;
+  }
+  else mt->set_convex_flag( convex_flag );
+
+  moab::ErrorCode rval;
+  rval = mt->load_mesh( input_filename, tag_name, tag_values );
+  if( rval != moab::MB_SUCCESS ){
+    std::cerr << "** DAGMC TrackLengthMeshTally creation failed!" << std::endl;
+    std::cerr << "** Tally " << id << " failed to initialize." << std::endl;
+    exit( EXIT_FAILURE );
+    
+  }
+  
+  return mt;
+
+}
+
+  
+TrackLengthMeshTally::TrackLengthMeshTally( const fmesh_card& fmesh, Interface* mb_p, 
+                                            const std::string& output_filename_p ) :
+  MeshTally( fmesh ),
+  mb( mb_p ), output_filename(output_filename_p),  
+  obb_tool( new OrientedBoxTreeTool(mb_p) ),
+  last_visited_tet( 0 ), 
+  convex( false ), conformality( NULL ), conformal_surface_source( false ),
+  mcnp_current_cell( NULL ), last_cell( -1 )
+{}
+  
+TrackLengthMeshTally::~TrackLengthMeshTally(){
+  delete obb_tool;
+}
+
+/**
+ * Load the given file as an input mesh
+ * Member variable tally_set will contain the mesh contents
+ */
+ErrorCode TrackLengthMeshTally::load_mesh( const std::string& input_filename, 
+                                           std::string tag_name, std::vector<std::string>& tag_values ){
+  
+  ErrorCode rval;
+
+  EntityHandle loaded_file_set;
+  rval = mb->create_meshset( MESHSET_SET, loaded_file_set );
+  assert( rval == MB_SUCCESS );
+  rval = mb->load_file( input_filename.c_str(), &loaded_file_set );
+  if( rval != MB_SUCCESS ){
+    std::cerr << "Warning: could not load tally mesh " << input_filename << std::endl;
+    return rval;
+  }
+
+
+  rval = mb->create_meshset( MESHSET_SET, tally_set );
+  assert( rval == MB_SUCCESS );
+  
+ 
+
+  if( tag_name.length() > 0 ){
+
+    std::cout << "  User-specified tag to load:  " << tag_name << std::endl;
+
+    /* Until there is more certainty about the type and parameters of the tag the user specified,
+       use MB_TAG_ANY to get access to any tag with the given name */
+    Tag user_spec_tag;
+    rval = mb->tag_get_handle( tag_name.c_str(), 0, MB_TYPE_OPAQUE, user_spec_tag, MB_TAG_ANY );
+    assert( rval == MB_SUCCESS );
+    
+    int user_spec_tag_length = 0;
+    rval = mb->tag_get_bytes( user_spec_tag, user_spec_tag_length );
+    assert( rval == MB_SUCCESS );
+
+    std::cout << "  user tag length: " << user_spec_tag_length << " bytes" << std::endl;
+
+    Range user_sets;
+    rval = mb->get_entities_by_type_and_tag( loaded_file_set, MBENTITYSET, &user_spec_tag, NULL, 1, user_sets );
+    assert( rval == MB_SUCCESS );
+
+    std::cout << "  Found " << user_sets.size() << " sets with this tag." << std::endl;
+
+    for( Range::iterator i = user_sets.begin(); i!=user_sets.end(); ++i){
+      EntityHandle s = *i;
+      char* name = new char[ user_spec_tag_length + 1];
+      
+      rval = mb->tag_get_data( user_spec_tag, &s, 1, name );
+      assert( rval == MB_SUCCESS );
+
+      // if user specified no tag value, list the available ones for informational purposes
+      if( tag_values.size() == 0 ){
+        std::cout << "    available tag value: " << name << std::endl; 
+      }
+      
+      if( std::find( tag_values.begin(), tag_values.end(),std::string(name) ) != tag_values.end() ){
+        std::cout << "  Successfully found a set with tag value " << name << std::endl;
+        rval = mb->unite_meshset( tally_set, s );
+        assert( rval == MB_SUCCESS );
+      }
+      delete[] name;
+    }
+
+  }
+  else{ // no user-specified tag filter
+
+    rval = mb->unite_meshset( tally_set, loaded_file_set );
+    assert( rval == MB_SUCCESS );
+  }
+
+  rval = setup_tags( mb );
+  assert( rval == MB_SUCCESS );
+
+  int num_tets;
+  rval = mb->get_number_entities_by_dimension( tally_set, 3, num_tets );
+  assert( rval == MB_SUCCESS );
+  std::cerr << "  There are " << num_tets << " tetrahedrons in this tally mesh." << std::endl;
+
+
+  tet_baryc_data.resize( num_tets );  
+  resize_data_arrays( num_tets );
+
+  Range all_tets;
+  rval = mb->get_entities_by_dimension( tally_set, 3, all_tets );
+  assert( rval == MB_SUCCESS );
+  assert( all_tets.size() == (unsigned)num_tets );
+
+  // restruct tally_set to contain only 3-dimensional elements
+  rval = mb->clear_meshset( &tally_set, 1  );
+  assert( rval == MB_SUCCESS );
+  rval = mb->add_entities( tally_set, all_tets );
+  assert( rval == MB_SUCCESS );
+
+  tally_ents = all_tets;
+
+  // Measure the number of divisions in the moab::Range used to represent the tally tets
+  // If there are many divisions (for some rather arbitrary definition of "many"), print
+  // a warning about performance compromise
+  int psize = tally_ents.psize();
+  std::cout << "  Tally range has psize: " << psize << std::endl;
+  if( psize > 4 ){
+    std::cerr << "Warning: large tally range psize " << psize << ", may reduce performance." << std::endl;
+  }
+
+  /**
+   * Iterate over all tets and compute barycentric matrices 
+   */
+  for( Range::const_iterator i=all_tets.begin(); i!=all_tets.end(); ++i){
+    EntityHandle tet = *i;
+
+    const EntityHandle* verts;
+    int num_verts;
+    rval = mb->get_connectivity( tet, verts, num_verts );
+    assert( rval == MB_SUCCESS );
+    
+    if( num_verts != 4 ){
+      std::cerr << "Error: DAGMC TrackLengthMeshTally cannot handle non-tetrahedral meshes yet," << std::endl;
+      std::cerr << "       but your mesh has at least one cell with " << num_verts << " vertices." << std::endl;
+      return MB_NOT_IMPLEMENTED;
+    }
+    
+    CartVect p[4];
+    rval = mb->get_coords( verts, 4, p[0].array() );
+    assert( rval == MB_SUCCESS );
+
+    Matrix3 a( p[1]-p[0], p[2]-p[0], p[3]-p[0] );
+    a = a.transpose().inverse();
+    tet_baryc_data.at( ent_idx(tet) ) = a;
+
+  }
+
+  // prepare to build KD tree and OBB tree
+  Range all_tris;
+  Skinner skinner(mb);
+  skinner.find_skin( all_tets, 2, all_tris );
+  std::cout << "  Tally mesh skin has " << all_tris.size() << " triangles." << std::endl;
+
+
+#ifdef USE_OBB_TREE_RAY_TRACING
+  std::cout << " Building OBB tree of size " << all_tris.size() << "... " << std::flush;
+  
+  rval = obb_tool->build( all_tris, obbtree_root );
+  assert( rval == MB_SUCCESS );
+  std::cout << "done." << std::endl;
+
+#else
+
+  // put tris with tets to be rolled into KD tree
+  all_tets.merge( all_tris );
+
+#endif
+
+  // build KD tree of all tetrahedra
+  std::cout << "  Building KD tree of size " << all_tets.size() << "... " << std::flush;
+  kdtree = new AdaptiveKDTree( mb );
+  AdaptiveKDTree::Settings kdtree_settings;
+  //kdtree_settings.candidatePlaneSet = MBAdaptiveKDTree::VERTEX_SAMPLE;
+  kdtree->build_tree( all_tets, kdtree_root, &kdtree_settings );
+  std::cout << "done." << std::endl << std::endl;;
+
+  return MB_SUCCESS;
+
+}
+
+  void TrackLengthMeshTally::print( double sp_norm, double mult_fact ){
+    write_results( sp_norm, mult_fact );
+  }
+
+/**
+ * Write out the mesh with tally and error tags attached
+ * @param sp_norm Tally for each tetrahedron will be divided by sp_norm*volume of tet.
+ * @param mult_fact Tally for each tetrahedron will be multiplied by this parameter.
+ * @param override_output_filename If non-NULL, use this filename for output instead
+ *                                 of this->output_filename
+ */
+ErrorCode TrackLengthMeshTally::write_results( double sp_norm, double mult_fact, 
+                                    const std::string* override_output_filename )
+{
+
+  std::string filename = override_output_filename ? *override_output_filename : output_filename;
+
+  ErrorCode rval;
+
+  Range all_tets;
+  rval = mb->get_entities_by_dimension( tally_set, 3, all_tets );
+  assert( rval == MB_SUCCESS );
+
+
+  for( Range::const_iterator i=all_tets.begin(); i!=all_tets.end(); ++i){
+    EntityHandle t = *i;
+
+    CartVect v[4];
+
+    std::vector<EntityHandle> vtx;    
+    mb->get_connectivity( &t, 1, vtx );
+    assert( vtx.size() == 4);
+
+    int k = 0;
+    for( std::vector<EntityHandle>::iterator j = vtx.begin(); j!=vtx.end(); ++j){
+      EntityHandle vertex = *j;
+      mb->get_coords( &vertex, 1, v[k++].array() );
+    }
+
+    double volume = tet_volume( v[0], v[1], v[2], v[3] );
+
+    for( unsigned j = 0; j < ebins; ++j ){
+
+      double tally = data_ref( tally_data, t, j );
+      double error = data_ref( error_data, t, j );
+      double score = (tally / (volume*sp_norm)) * mult_fact;
+      
+      rval = mb->tag_set_data( tally_tags[j], &t, 1, &score );
+      assert( rval == MB_SUCCESS );
+
+      // Use 0 as the error output value if nothing has been computed for this mesh cell;
+      // this reflects MCNP's approach to avoiding a divide-by-zero situation.
+      double rel_err = 0;
+      if( error != 0 ){
+        rel_err = sqrt( (error / (tally*tally)) - (1./sp_norm) );
+      }        
+
+      rval = mb->tag_set_data( error_tags[j], &t, 1, &rel_err );
+      assert( rval == MB_SUCCESS );
+
+    }
+  }
+
+  std::vector<Tag> output_tags = tally_tags;
+  output_tags.insert( output_tags.end(), error_tags.begin(), error_tags.end() );
+
+  rval = mb->write_file( filename.c_str(), NULL, NULL, &tally_set, 1, &(output_tags[0]), output_tags.size() );
+  assert (rval == MB_SUCCESS );
+ 
+  return MB_SUCCESS;
+}
+
+
+/**
+ * Return true if the point falls inside tet.  Assumes tet is part of this TrackLengthMeshTally.
+ */
+bool TrackLengthMeshTally::point_in_tet( const CartVect& point, const EntityHandle* tet )
+{ 
+  ErrorCode rval;
+                    
+  const EntityHandle* verts;
+  int num_verts;
+  rval = mb->get_connectivity( *tet, verts, num_verts );
+  assert( rval == MB_SUCCESS );
+  
+  CartVect p0;
+  rval = mb->get_coords( verts, 1, p0.array() );
+  assert( rval == MB_SUCCESS );
+
+  Matrix3& Ainverse = tet_baryc_data[ ent_idx(*tet) ];
+
+  CartVect bary = (Ainverse) * (point-p0);
+  
+  bool in_tet = ( bary[0]>= 0 && bary[1] >= 0 && bary[2] >= 0 &&
+                  bary[0]+bary[1]+bary[2] <= 1. );
+
+  return in_tet;
+}
+
+
+/**
+ * Add a score to a given mesh cell
+ */
+void TrackLengthMeshTally::add_score_to_mesh_cell( EntityHandle mesh_cell, double score, int ebin ){
+  
+  visited_this_history.insert( mesh_cell );
+
+  data_ref( temp_tally_data, mesh_cell, ebin ) += score;
+
+  if( fmesh.total_energy_bin ){
+    data_ref( temp_tally_data, mesh_cell, (ebins-1) ) += score;
+  }
+}
+
+/**
+ * Finish adding a set of scores for a particular monte carlo particle track
+ */
+void TrackLengthMeshTally::end_history () {
+
+  for( std::set< EntityHandle >::iterator i=visited_this_history.begin(); i!=visited_this_history.end(); ++i){
+
+    for( unsigned j = 0; j < ebins; ++j ){
+      double& d =     data_ref(temp_tally_data, *i, j );
+      double& tally = data_ref(tally_data, *i, j );
+      double& error = data_ref(error_data, *i, j );
+      
+      tally += d;
+      error += (d * d);
+      d = 0.0;
+    }
+
+  }
+
+  visited_this_history.clear();
+
+  if( conformality ){ last_cell = -1; } 
+}
+
+/**
+ * Given an EntityHandle representing a mesh skin triangle, return the tetrahedron it belongs to
+ * as well as the handles of its vertices.  Calling this function asserts that the triangle 
+ * "belongs" to exaclty one tetrahedron.  This should always be a valid assumption, since this
+ * code only creates explicit triangle entities for skin triangles.
+ * 
+ * @param triangle The input triangle
+ * @param tetrahedron (output) The parent tetrahedron of triangle
+ * @param vertices (output) The vertices of triangle
+ *
+ */
+void
+TrackLengthMeshTally::get_skin_triangle_adjacencies( EntityHandle triangle, 
+                                                     EntityHandle& tetrahedron, EntityHandle vertices[3] ){
+
+  ErrorCode rval;
+  const EntityHandle* tri_conn;
+  int num_verts; 
+  rval = mb->get_connectivity( triangle, tri_conn, num_verts );
+  assert( rval == MB_SUCCESS );
+  assert( num_verts == 3 );
+  memcpy( vertices, tri_conn, sizeof(EntityHandle)*3 );
+  
+  Range tri_sides; 
+  rval = mb->get_adjacencies( &triangle, 1, 3, false, tri_sides );
+  assert( rval == MB_SUCCESS );
+  assert( tri_sides.size() == 1 );
+  tetrahedron = tri_sides[0];
+
+}
+
+/**
+ * Given a ray that starts outside the mesh, find the next tetrahedron (if any) 
+ * that will be intersected by the ray.
+ * @param start Beginning of ray
+ * @param vec Unit vector of ray
+ * @param length Length of ray
+ * @param first_tri If return value is non-zero, will contain the skin triangle that 
+ *                  ray intersects.
+ * @param first_t Value of t along the ray where first_tri is intersected.
+ * @param last_crossing A skin triangle to ignore for this ray fire.  Used if a ray is
+ *                      being fired away from the surface of the mesh.
+ * @return The tetrahedron intersected by this ray fire, or zero if none.
+ */
+EntityHandle 
+TrackLengthMeshTally::find_next_tet_by_ray_fire( CartVect& start, CartVect& vec, double length, 
+                                      EntityHandle first_tri[3], double& first_t, 
+                                      EntityHandle last_crossing )
+{
+  ErrorCode rval;
+  EntityHandle first_tet = 0;
+
+  std::vector< EntityHandle > triangles;
+  std::vector< double > distances;
+
+#ifdef USE_OBB_TREE_RAY_TRACING
+  double vlen = length;
+  rval = obb_tool->ray_intersect_triangles( distances, triangles,
+                                            obbtree_root, TRIANGLE_INTERSECTION_TOL, 
+                                            start.array(), vec.array(), &vlen );
+#else
+  rval = kdtree->ray_intersect_triangles( kdtree_root, TRIANGLE_INTERSECTION_TOL, 
+                                          vec.array(), start.array(),
+                                          triangles, distances, 0, length );  
+#endif
+
+  assert( rval == MB_SUCCESS );
+  
+  if( distances.size() ){
+    // ray goes into mesh
+    int min_idx = 0;
+    for( unsigned i = 1; i < distances.size(); ++i ){
+      if( distances[i] < distances[min_idx] &&
+          triangles[i] != last_crossing )
+        { min_idx = i; }  
+    }
+    
+    if( distances[min_idx] < length && triangles[min_idx] != last_crossing ){ 
+
+#if MESHTAL_DEBUG
+      std::cout << "    ray fire success, d=" << distances[min_idx] << std::endl;
+#endif
+
+      EntityHandle first_tri_eh = triangles[min_idx];
+      first_t   = distances[min_idx];
+
+      get_skin_triangle_adjacencies( first_tri_eh, first_tet, first_tri );
+      
+    }
+  }
+
+  return first_tet;
+}
+
+/**
+ * Find the first tetrahedron intersected by a track segment, using conformal logic.
+ * This is invoked when a surface crossing has just occurred in a conformal mesh tally,
+ * allowing us to assume that one of the surface triangles of this mesh has just been crossed.
+ * Thus the search for the nearest tetrahedron is simply a search for the surface triangle
+ * nearest to the starting point of the ray.
+ *
+ * This function should always successfully return values, but it will print a warning if 
+ * the nearest available result is suspicious.
+ *
+ * @param start Beginning of track 
+ * @param first_tri (output) The vertices of the skin triangle at which track begins
+ * @return The first tetrahedron along the ray.
+ */
+EntityHandle
+TrackLengthMeshTally::get_starting_tet_conformal( CartVect& start, EntityHandle first_tri[3] )
+{
+  ErrorCode rval;
+  CartVect tri_start;
+  EntityHandle first_tri_eh, first_tet=0;
+  
+  rval = kdtree->closest_triangle( kdtree_root, start.array(), tri_start.array(), first_tri_eh );
+  assert( rval == MB_SUCCESS );
+  
+  get_skin_triangle_adjacencies( first_tri_eh, first_tet, first_tri );
+  
+  double distance = (start-tri_start).length();
+
+#ifdef MESHTAL_DEBUG
+  std::cout << "  start: conformal mesh entry, dist =" << distance << std::endl;    
+#endif
+
+  if( distance > 1e-6 ){
+    std::cerr << "Warning: suspicious epsilon distance in conformal tally: " << distance << std::endl;
+  }
+  
+  return first_tet;
+
+}
+
+/**
+ * Find the first tetrahedron intersected by the given track segment.
+ * @param start Beginning of ray
+ * @param vec Unit vector of ray
+ * @param length Length of ray
+ * @param first_tri If return value is non-zero, and a ray fire was performed, 
+ *                  will contain the skin triangle that ray intersects.
+ * @param first_t Value of t along the ray where first_tri is intersected.
+ * @param conformal_begin_track If true, track is known to enter mesh at a conformal 
+ *                              MCNP cell at t=0.  Use simplified logic in this case.
+ * @return The first tetrahedron along the ray, or zero if none found.
+ */
+
+EntityHandle 
+TrackLengthMeshTally::get_starting_tet( CartVect& start, CartVect& vec, double length, 
+                                        EntityHandle first_tri[3], double& first_t )
+{
+  ErrorCode rval;
+  EntityHandle first_tet = 0; 
+
+  
+  // First check last visited tetrahedron
+  if( last_visited_tet && this->point_in_tet( start, &last_visited_tet ) ){
+    first_tet = last_visited_tet; 
+
+#ifdef MESHTAL_DEBUG
+    std::cout << "   start: cached first tet" << std::endl;
+#endif
+
+  }
+  else{ 
+    // Check to see if starting point begins inside a tet
+    AdaptiveKDTreeIter tree_iter;
+    rval = kdtree->leaf_containing_point( kdtree_root, start.array(), tree_iter );
+    if( rval == MB_SUCCESS ){
+      
+      EntityHandle leaf = tree_iter.handle();
+      Range candidate_tets;
+      rval = mb->get_entities_by_dimension( leaf, 3, candidate_tets, false );
+      assert( rval == MB_SUCCESS );
+      
+      for( Range::const_iterator i = candidate_tets.begin(); i!=candidate_tets.end(); ++i){
+        if( this->point_in_tet( start, &(*i) )){
+          first_tet = *i;
+        }
+      }
+    }
+#ifdef MESHTAL_DEBUG
+    if( first_tet ){
+      std::cout << "   start: pt in volume" << std::endl;
+    }
+#endif 
+
+  }
+  
+  if( first_tet == 0 ){
+    // Starting point is outside of the mesh: fire the ray to see if it enters mesh.
+    first_tet = this->find_next_tet_by_ray_fire( start, vec, length, first_tri, first_t );
+
+#ifdef MESHTAL_DEBUG
+    if( first_tet ){
+      std::cout << "   start: ray fire"  << std::endl;
+    }
+    if( conformality ){
+      std::cout << "    WARNING: conformality enabled, but a start was selected by ray fire!" << std::endl;
+    }
+#endif
+
+  }
+  
+  return first_tet;
+}
+
+static inline bool tris_eq( const EntityHandle *t1, const EntityHandle *t2 ){
+  int ignored1, ignored2;
+  return CN::ConnectivityMatch( t1, t2, 3, ignored1, ignored2 );
+}
+
+/**
+ * Score a given particle track on this TrackLengthMeshTally.
+ * @param start Beginning of particle track
+ * @param vec Unit vector of particle track direction
+ * @param length Length of particle track
+ * @param score_params Parameter structure to pass to score callback
+ */
+void TrackLengthMeshTally::add_track_segment( CartVect& start, CartVect& vec, 
+                                              double length, int ebin, MCNPTrackParam* score_params )
+{
+  ErrorCode rval;
+
+  bool conformal_begin_track = false;
+
+  if( conformality ){
+
+    bool cell_change = (last_cell != *mcnp_current_cell);
+    bool newparticle = (last_cell == -1);
+    
+    conformal_begin_track = cell_change;
+    // new particles should only use conformal crossing logic if a conformal surface source was declared
+    if( newparticle )
+        conformal_begin_track = conformal_surface_source; 
+
+#ifdef MESHTAL_DEBUG
+    if( newparticle ){ std::cout << "Started new particle in cell " << *mcnp_current_cell << std::endl; } 
+    else if( cell_change ){ 
+        std::cout << "Crossed surface from " << last_cell 
+                  << " into " << *mcnp_current_cell<< std::endl; }
+#endif
+
+    last_cell = *mcnp_current_cell;
+
+    // if the new cell is not part of this tally, return immediately
+    if( conformality->find( *mcnp_current_cell ) == conformality->end() ) {
+      return;
+    }
+  }
+
+  EntityHandle last_crossed_tri[3] = {0,0,0};
+  double last_t = 0;
+  EntityHandle first_tet;
+
+  if( conformal_begin_track ){
+    first_tet = get_starting_tet_conformal( start, last_crossed_tri );
+  }
+  else{
+    first_tet = get_starting_tet( start, vec, length, last_crossed_tri, last_t );
+  }
+
+  if( first_tet == 0 ){
+    // this ray never touches the tally mesh
+    return;
+  }
+
+  EntityHandle next_tet = first_tet;
+  //double first_t = last_t; //useful as a debugging var
+  int tet_count = 0;
+
+  while( next_tet != 0 ){
+
+    EntityHandle tet = next_tet; // the tetrahedron being currently handled
+    tet_count++;
+
+    const EntityHandle* tet_verts; 
+    int num_tet_verts; 
+    rval = mb->get_connectivity( tet, tet_verts, num_tet_verts );
+    assert( rval == MB_SUCCESS );
+    assert( num_tet_verts == 4 );
+
+    bool found_crossing = false;
+
+
+    for( int i = 0; i < 4 && !found_crossing; ++i ){
+
+      EntityHandle tri[3]; 
+      int three;
+
+      CN::SubEntityConn( tet_verts, MBTET, 2, i, tri, three );
+      assert( three == 3 );
+
+      if( tris_eq( tri, last_crossed_tri ) ) continue;
+
+      CartVect tri_pts[3];
+      rval = mb->get_coords( tri, 3, tri_pts[0].array() );
+      assert( rval == MB_SUCCESS );
+
+      double t;
+      if( GeomUtil::ray_tri_intersect( tri_pts, start, vec, TRIANGLE_INTERSECTION_TOL, t ) ){
+
+        double track_length;
+
+        if( t >= length ){
+          // track ends in this tetrahedron
+          track_length = length - last_t;
+          next_tet = 0;
+          this->last_visited_tet = tet;
+
+#ifdef MESHTAL_DEBUG
+          std::cout << " track ends in mesh" << std::endl;
+#endif
+
+        }
+        else{ 
+          // t < length, track proceeds to next tetrahedron
+          track_length = t - last_t;
+          last_t = t;
+          
+          Range tri_sides; 
+          rval = mb->get_adjacencies( tri, 3, 3, false, tri_sides );
+          assert( rval == MB_SUCCESS );
+          assert( tri_sides.size() <= 2 );
+          assert( tri_sides[0] == tet || tri_sides[1] == tet );
+          assert( tri_sides.size() == 1 || (tri_sides[0] != tet || tri_sides[1] != tet) );
+
+          if( tri_sides.size() == 1 ){
+            // the mesh ends here
+            CartVect crossing = start + (vec*t);
+#ifdef MESHTAL_DEBUG
+            std::cout << "  Ray departs from mesh at t = " << t << ", "  << crossing  << std::endl;
+#endif
+      
+
+            if( convex || conformality ) {
+              // input file made assertion that this mesh tally is convex, 
+              // or conformality assures that no single track will reenter tally mesh
+            next_tet = 0;
+            }
+            else{
+              Range last_tri_eh;
+              rval = mb->get_adjacencies( tri, 3, 2, false, last_tri_eh );
+              assert( rval == MB_SUCCESS );
+              assert( last_tri_eh.size() == 1 );
+              next_tet = find_next_tet_by_ray_fire( crossing, vec, length - t, last_crossed_tri, last_t, last_tri_eh[0] );
+            }
+
+#ifdef MESHTAL_DEBUG
+            if( next_tet ){
+              std::cout << "  Ray enters mesh again at t = " << last_t << std::endl;
+            }
+            else{
+              std::cout << " track ends." << std::endl;
+            }
+#endif
+            last_t += t;
+            this->last_visited_tet = 0;
+          }
+          else{ 
+#ifdef MESHTAL_DEBUG
+            std::cout << "  track proceeds, t = " << last_t << std::endl;
+#endif
+            next_tet = (tri_sides[0]==tet) ? tri_sides[1] : tri_sides[0];
+            memcpy( last_crossed_tri, tri, sizeof(last_crossed_tri) );
+          }
+
+        }
+        if( track_length < 0 ){
+          std::cerr << "Warning-- negative track length.   Dubious continuation.." << std::endl;
+          track_length = -track_length; 
+          //return;
+        }
+        
+        double score;
+        mcnp_weight_calculation( score_params->fmesh_index, score_params->erg, score_params->wgt,
+                                 &track_length, &score );
+        add_score_to_mesh_cell( tet, score, ebin );
+        found_crossing = true;
+      }
+
+    }
+    if( !found_crossing ){
+      std::cerr << "ERROR: No triangle crossings found.  Ending a meshtal track early." << std::endl;
+      return;
+    }
+    assert( found_crossing );
+
+  }
+
+  return;
+
+}
+
+} // namespace moab
Index: dagmc/KDEMeshTally.hpp
===================================================================
--- dagmc/KDEMeshTally.hpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/KDEMeshTally.hpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,242 @@
+// KDEMeshTally.hpp
+
+#ifndef KDEMESHTALLY_H
+#define KDEMESHTALLY_H
+
+#include <iosfwd>
+#include <set>
+#include <string>
+
+#include "moab/CartVect.hpp"
+#include "moab/Interface.hpp"
+
+#include "KDEKernel.hpp"
+#include "MeshTally.hpp"
+
+// forward declarations
+class AdaptiveKDTree;
+
+/**
+ * A struct that contains all the parameters needed to compute the tally
+ * weighting factor of a KDEMeshTally score.
+ *
+ * @param fmesh_index the index of the KDE mesh tally
+ * @param particle_wgt the current weight of the particle
+ * @param energy the current energy of the particle
+ * @param tracklength (optional) the track length the particle has traveled
+ * @param total_xs (optional) the total macroscopic cross section
+ */
+struct KDEWeightParam {
+
+  // parameters needed for all KDE tally types
+  int* fmesh_index;
+  double* particle_wgt;
+  double* energy;
+
+  // optional parameters, default to NULL
+  double* tracklength;  // only needed for TRACKLENGTH/SUBTRACK tallies
+  double* total_xs;     // only needed for COLLISION tallies
+
+  KDEWeightParam( int* index, double* wgt, double* erg ):
+    fmesh_index( index ), particle_wgt( wgt ), energy( erg ),
+    tracklength( NULL ), total_xs( NULL ) {}
+
+};
+
+/** 
+ * A class that represents a mesh tally based on a kernel density estimator
+ * approach for use in a Monte Carlo particle transport simulation.
+ */
+class KDEMeshTally : public MeshTally {
+
+  public:
+
+     static moab::CartVect default_bandwidth;  // bandwidth choice for KDE tallies
+
+    /**
+     * An enumerative type that specifies the type of tally being used by this
+     * KDEMeshTally object.
+     *
+     *  - COLLISION tallies are based on the KDE collision estimator
+     *  - TRACKLENGTH tallies are based on the KDE integral track estimator
+     *  - SUBTRACK tallies are based on the KDE subtrack estimator
+     */
+    enum TallyType { COLLISION = 0, TRACKLENGTH = 1, SUBTRACK = 2 };
+
+    /**
+     * Allocate and return the specified tally object
+     * @param settings The FC card parameters
+     * @param mbi The associated MOAB interface
+     * @param type The tally type
+     * @return A newly allocated object, ready to receive collisions or tracks 
+     */
+    static KDEMeshTally* setup( const fmesh_card& settings, 
+                                moab::Interface* mbi,
+                                TallyType type = COLLISION );
+
+    /**
+     * Constructs a mesh tally object based on a kernel density estimator
+     * approach.  The tally type cannot be changed once a KDEMeshTally object
+     * has been created.
+     *
+     * NOTE: the parameter "numSubtracks" is required for SUBTRACK tallies,
+     * but it is optional for TRACKLENGTH tallies for computing an optimal
+     * bandwidth.  It has no meaning for COLLISION tallies.
+     *
+     * @param settings the FC card parameters 
+     * @param moabMesh the MOAB instance containing the mesh information
+     * @param moabSet the MOAB set of entities used in the tally
+     * @param bandwidth the set of bandwidth values (hx, hy, hz)
+     * @param type (optional) the type of tally to be used
+     * @param k (optional) the KernelType function to be used in the computation
+     * @param numSubtracks (optional) the number of subtracks to be used
+     */
+    KDEMeshTally( const fmesh_card& settings,
+                  moab::Interface* moabMesh,
+                  moab::EntityHandle moabSet,
+                  moab::CartVect bandwidth,
+                  TallyType type = COLLISION,
+                  KDEKernel::KernelType k = KDEKernel::EPANECHNIKOV,
+                  unsigned int numSubtracks = 0 );
+
+    /**
+     * Destructor.
+     */
+    ~KDEMeshTally();
+
+    /**
+     * Computes the contribution for the given collision location and adds the
+     * results to the current mesh tally.  Note that the total cross section
+     * parameter in the KDEWeightParam object must be set to a non-NULL value.
+     *
+     * @param param the parameters needed to compute the tally weighting factor
+     * @param collision_loc a point where a collision has occurred
+     * @param ebin the energy bin to tally this collision into (calculated by fortran)
+     */
+    void tally_collision( const KDEWeightParam & param,
+                          const moab::CartVect & collision_loc, 
+                          int ebin );
+
+    /**
+     * Computes the contribution for the given track segment and adds the
+     * results to the current mesh tally.  Note that the track length parameter
+     * in the KDEWeightParam object must be set to a non-NULL value.
+     *
+     * @param param the parameters needed to compute the tally weighting factor
+     * @param start_point the starting location of the track (xo, yo, zo)
+     * @param direction the direction the particle is traveling (uo, vo, wo)
+     * @param ebin the energy bin to tally this track into (calculated by fortran)
+     */
+    void tally_track( const KDEWeightParam & param,
+                      const moab::CartVect & start_point,
+                      const moab::CartVect & direction, 
+                      int ebin );
+
+    /** 
+     * Implement MeshTally end_history interface 
+     */ 
+    virtual void end_history();
+
+    /** 
+     * Implement MeshTally print interface 
+     */ 
+    virtual void print( double sp_norm, double fmesh_fact );
+
+    /**
+     * Write mesh with tags for current tally and error results attached.
+     *
+     * @param sp_norm the number of source particles
+     * @param mult_fact the multiplication factor from the FMESH card
+     */
+    void write_results( double sp_norm, double fmesh_fact );
+
+  private:
+
+    moab::Interface* mb;           // the MOAB instance
+    
+    moab::CartVect bandwidth;      // the set of bandwidth values (hx, hy, hz)
+    TallyType kde_tally;           // specifies type of KDE tally 
+    KDEKernel* kernel;             // kernel function tally is based on
+    unsigned int subtracks;        // number of subtracks used in tally       
+    
+    std::string output_filename;
+    moab::EntityHandle tally_set;  // the MOAB set of entities used in tally
+
+    moab::AdaptiveKDTree* tree;    
+    moab::EntityHandle tree_root;
+    
+    // The entityhandles updated in the current particle history; cleared by end_history()
+    std::set<moab::EntityHandle> visited_this_history;
+
+    /**
+     * Variables needed to compute a running variance for calculating the
+     * optimal bandwidth during runtime.
+     */
+    bool max_collisions;
+    long long int numCollisions;       
+    moab::CartVect Mn;  // mean
+    moab::CartVect Sn;  // variance       
+    
+    /**
+     * Builds a KD-Tree from all the mesh node entities in the specified meshset,
+     * or if the set is 0, from all mesh nodes in MOAB.
+     */
+    void build_tree( moab::EntityHandle meshset );
+
+    /**
+     * Adds the given collision coordinates to the running variance formula
+     * used to compute the optimal bandwidth.
+     */
+    void update_bandwidth_variance( const moab::CartVect & collision_loc );
+
+    /**
+     * Computes and returns the optimal bandwidth to achieve the best results
+     * in the kernel density approximation.
+     */
+    moab::CartVect get_optimal_bandwidth();
+
+    /**
+     * Determines the tally weighting factor for a collision or track
+     * contribution.  This weight includes the particle weight and any tally
+     * multipliers that were used for both tally types.
+     * 
+     * @param param the parameters needed to compute the tally weighting factor
+     * @return the tally weighting factor for a collision or track
+     */
+    double get_score_weight( const KDEWeightParam & param );
+
+    /**
+     * Adds a tally contribution to one calculation point on the mesh.
+     *
+     * @param mesh_point the calculation point on the mesh
+     * @param score the tally contribution to add
+     * @param ebin the energy bin for the tally contribution
+     */
+    void add_score_to_tally( moab::EntityHandle mesh_point,
+                             double score,
+                             int ebin );
+
+    /**
+     * Gets a unique set of all of the vertices that lie within the given box.
+     *
+     * @param tree a KD-Tree containing all vertices
+     * @param tree_root the root of the KD-Tree
+     * @param box_min the minimum corner of the box
+     * @param box_max the maximum corner of the box
+     * @param points  the unique set of vertices in the box
+     * @return the MOAB ErrorCode value
+     */
+    moab::ErrorCode points_in_box( moab::AdaptiveKDTree & tree,
+                                   moab::EntityHandle tree_root,
+                                   const double box_min[3],
+                                   const double box_max[3],
+                                   std::vector<moab::EntityHandle> & points );
+
+    /// unimplemented 
+    KDEMeshTally( const KDEMeshTally & obj );
+    /// unimplemented
+    KDEMeshTally & operator=( const KDEMeshTally & obj );
+
+};
+
+#endif
Index: dagmc/mcnp_funcs.cpp
===================================================================
--- dagmc/mcnp_funcs.cpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/mcnp_funcs.cpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,892 @@
+#include "mcnp_funcs.h"
+
+#include "MBInterface.hpp"
+#include "MBCartVect.hpp"
+
+#include "DagMC.hpp"
+using moab::DagMC;
+
+#include <limits>
+#include <iostream>
+#include <fstream>
+#include <sstream>
+#include <algorithm>
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#ifdef CUBIT_LIBS_PRESENT
+#include <fenv.h>
+#endif
+
+  // globals
+
+#define DAG DagMC::instance()
+
+#define DGFM_SEQ   0
+#define DGFM_READ  1
+#define DGFM_BCAST 2
+
+#ifdef ENABLE_RAYSTAT_DUMPS
+
+#include <fstream>
+#include <numeric>
+
+static std::ostream* raystat_dump = NULL;
+
+#endif 
+
+
+/* Static values used by dagmctrack_ */
+
+static DagMC::RayHistory history;
+static int last_nps = 0;
+static double last_uvw[3] = {0,0,0};
+static std::vector< DagMC::RayHistory > history_bank;
+static std::vector< DagMC::RayHistory > pblcm_history_stack;
+static bool visited_surface = false;
+
+static bool use_dist_limit = false;
+static double dist_limit; // needs to be thread-local
+
+
+void dagmcinit_(char *cfile, int *clen,  // geom
+                char *ftol,  int *ftlen, // faceting tolerance
+                int *parallel_file_mode, // parallel read mode
+                double* dagmc_version, int* moab_version, int* max_pbl )
+{
+ 
+  MBErrorCode rval;
+
+#ifdef ENABLE_RAYSTAT_DUMPS
+  // the file to which ray statistics dumps will be written
+  raystat_dump = new std::ofstream("dagmc_raystat_dump.csv");
+#endif 
+  
+  *dagmc_version = DAG->version();
+  *moab_version = DAG->interface_revision();
+  
+    // terminate all filenames with null char
+  cfile[*clen] = ftol[*ftlen] = '\0';
+
+    // initialize this as -1 so that DAGMC internal defaults are preserved
+    // user doesn't set this
+  double arg_facet_tolerance = -1;
+                                                                        
+  if ( *ftlen > 0 ) arg_facet_tolerance = atof(ftol);
+  
+  // read geometry
+  rval = DAG->load_file(cfile, arg_facet_tolerance );
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC failed to read input file: " << cfile << std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+#ifdef CUBIT_LIBS_PRESENT
+  // The Cubit 10.2 libraries enable floating point exceptions.  
+  // This is bad because MOAB may divide by zero and expect to continue executing.
+  // See MOAB mailing list discussion on April 28 2010.
+  // As a workaround, put a hold exceptions when Cubit is present.
+
+  fenv_t old_fenv;
+  if ( feholdexcept( &old_fenv ) ){
+    std::cerr << "Warning: could not hold floating-point exceptions!" << std::endl;
+  }
+#endif
+
+ 
+  // initialize geometry
+  rval = DAG->init_OBBTree();
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC failed to initialize geometry and create OBB tree" <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  pblcm_history_stack.resize( *max_pbl+1 ); // fortran will index from 1
+
+}
+
+void dagmcwritefacets_(char *ffile, int *flen)  // facet file
+{
+    // terminate all filenames with null char
+  ffile[*flen]  = '\0';
+
+  MBErrorCode rval = DAG->write_mesh(ffile,*flen);
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC failed to write mesh file: " << ffile <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  return;
+
+}
+
+/**
+ * Helper function for parsing DagMC properties that are integers.
+ * Returns true on success, false if property does not exist on the volume,
+ * in which case the result is unmodified.
+ * If DagMC throws an error, calls exit().
+ */
+static bool get_int_prop( MBEntityHandle vol, int cell_id, const std::string& property, int& result ){
+
+  MBErrorCode rval;
+  if( DAG->has_prop( vol, property ) ){
+    std::string propval;
+    rval = DAG->prop_value( vol, property, propval );
+    if( MB_SUCCESS != rval ){ 
+      std::cerr << "DagMC failed to get expected property " << property << " on cell " << cell_id << std::endl;
+      std::cerr << "Error code: " << rval << std::endl;
+      exit( EXIT_FAILURE );
+    }
+    const char* valst = propval.c_str();
+    char* valend;
+    result = strtol( valst, &valend, 10 );
+    if( valend[0] != '\0' ){
+      // strtol did not consume whole string
+      std::cerr << "DagMC: trouble parsing '" << property <<"' value (" << propval << ") for cell " << cell_id << std::endl;
+      std::cerr << "       the parsed value is " << result << ", using that." << std::endl;
+    }
+    return true;
+  }
+  else return false;
+
+}
+
+/**
+ * Helper function for parsing DagMC properties that are doubles.
+ * Returns true on success, false if property does not exist on the volume,
+ * in which case the result is unmodified.
+ * If DagMC throws an error, calls exit().
+ */
+static bool get_real_prop( MBEntityHandle vol, int cell_id, const std::string& property, double& result ){
+
+  MBErrorCode rval;
+  if( DAG->has_prop( vol, property ) ){
+    std::string propval;
+    rval = DAG->prop_value( vol, property, propval );
+    if( MB_SUCCESS != rval ){ 
+      std::cerr << "DagMC failed to get expected property " << property << " on cell " << cell_id << std::endl;
+      std::cerr << "Error code: " << rval << std::endl;
+      exit( EXIT_FAILURE );
+    }
+    const char* valst = propval.c_str();
+    char* valend;
+    result = strtod( valst, &valend );
+    if( valend[0] != '\0' ){
+      // strtod did not consume whole string
+      std::cerr << "DagMC: trouble parsing '" << property <<"' value (" << propval << ") for cell " << cell_id << std::endl;
+      std::cerr << "       the parsed value is " << result << ", using that." << std::endl;
+    }
+    return true;
+  }
+  else return false;
+
+}
+
+// take a string like "surf.flux.n", a key like "surf.flux", and a number like 2,
+// If the first part of the string matches the key, remove the key from the string (leaving, e.g. ".n")
+// and return the number.
+static int tallytype( std::string& str, const char* key, int ret )
+{
+  if( str.find(key) == 0 ){
+    str.erase( 0, strlen(key) );
+    return ret;
+  }
+  return 0;
+}
+
+// given a tally specifier like "1.surf.flux.n", return a printable card for the specifier
+// and set 'dim' to 2 or 3 depending on whether its a surf or volume tally
+static char* get_tallyspec( std::string spec, int& dim ){
+
+  if( spec.length() < 2 ) return NULL;
+  const char* str = spec.c_str();
+  char* p;
+
+  int ID = strtol( str, &p, 10 );
+  if( p == str ) return NULL; // did not find a number at the beginning of the string
+  if( *p != '.' ) return NULL; // did not find required separator
+  str = p + 1;
+
+  if( strlen(str) < 1 ) return NULL;
+
+  std::string tmod;
+  if( str[0] == 'q' ){
+    tmod = "+"; 
+    str++;
+  }
+  else if( str[0] == 'e' ){
+    tmod = "*";
+    str++;
+  }
+  
+  std::string remainder(str);
+  int type = 0;
+  type = tallytype( remainder, "surf.current", 1 );
+  if(!type) type = tallytype( remainder, "surf.flux", 2 );
+  if(!type) type = tallytype( remainder, "cell.flux", 4 );
+  if(!type) type = tallytype( remainder, "cell.heating", 6 );
+  if(!type) type = tallytype( remainder, "cell.fission", 7 );
+  if(!type) type = tallytype( remainder, "pulse.height", 8 );
+  if( type == 0 ) return NULL;
+
+  std::string particle = "n";
+  if( remainder.length() >= 2 ){
+    if(remainder[0] != '.') return NULL;
+    particle = remainder.substr(1);
+  }
+  
+  char* ret = new char[80];
+  sprintf( ret, "%sf%d:%s", tmod.c_str(), (10*ID+type), particle.c_str() );
+
+  dim = 3;
+  if( type == 1 || type == 2 ) dim = 2;
+  return ret;
+
+}
+
+void dagmcwritemcnp_(char *lfile, int *llen)  // file with cell/surface cards
+                     
+{
+  MBErrorCode rval;
+
+  lfile[*llen]  = '\0';
+
+  std::vector< std::string > mcnp5_keywords;
+  std::map< std::string, std::string > mcnp5_keyword_synonyms;
+
+  mcnp5_keywords.push_back( "mat" );
+  mcnp5_keywords.push_back( "rho" );
+  mcnp5_keywords.push_back( "comp" );
+  mcnp5_keywords.push_back( "imp.n" );
+  mcnp5_keywords.push_back( "imp.p" );
+  mcnp5_keywords.push_back( "imp.e" );
+  mcnp5_keywords.push_back( "tally" );
+  mcnp5_keywords.push_back( "spec.reflect" );
+  mcnp5_keywords.push_back( "white.reflect" );
+  mcnp5_keywords.push_back( "graveyard" );
+  
+  mcnp5_keyword_synonyms[ "rest.of.world" ] = "graveyard";
+  mcnp5_keyword_synonyms[ "outside.world" ] = "graveyard";
+
+  // parse data from geometry
+  rval = DAG->parse_properties( mcnp5_keywords, mcnp5_keyword_synonyms );
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC failed to parse metadata properties" <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  std::string lfname(lfile, *llen);
+  std::cerr << "Going to write an lcad file = " << lfname << std::endl;
+  // Before opening file for writing, check for an existing file
+  if( lfname != "lcad" ){
+    // Do not overwrite a lcad file if it already exists, except if it has the default name "lcad"
+    if( access( lfname.c_str(), R_OK ) == 0 ){
+      std::cout << "DagMC: reading from existing lcad file " << lfname << std::endl;
+      return; 
+    }
+  }
+
+  std::ofstream lcadfile( lfname.c_str() );
+
+  int num_cells = DAG->num_entities( 3 );
+  int num_surfs = DAG->num_entities( 2 );
+
+  int cmat = 0;
+  double crho, cimp = 1.0;
+
+  // write the cell cards
+  for( int i = 1; i <= num_cells; ++i ){
+
+    MBEntityHandle vol = DAG->entity_by_index( 3, i );
+    int cellid = DAG->id_by_index( 3, i );
+    // set default importances for p and e to negative, indicating no card should be printed.
+    double imp_n = 1, imp_p = -1, imp_e = -1;
+
+    if( DAG->has_prop( vol, "imp.n" )){
+      get_real_prop( vol, cellid, "imp.n", imp_n );
+    }
+
+    if( DAG->has_prop( vol, "imp.p" )){
+      get_real_prop( vol, cellid, "imp.p", imp_p );
+    }
+
+    if( DAG->has_prop( vol, "imp.e" )){
+      get_real_prop( vol, cellid, "imp.e", imp_e );
+    }
+
+    lcadfile << cellid << " ";
+
+    bool graveyard = DAG->has_prop( vol, "graveyard" );
+
+    if( graveyard ){
+      lcadfile << " 0 imp:n=0";
+      if( DAG->has_prop(vol, "comp") ){
+        // material for the implicit complement has been specified.
+        get_int_prop( vol, cellid, "mat", cmat );
+        get_real_prop( vol, cellid, "rho", crho );
+        std::cout << "Detected material and density specified for implicit complement: " << cmat <<", " << crho << std::endl;
+        cimp = imp_n;
+      }
+    }
+    else if( DAG->is_implicit_complement(vol) ){
+      lcadfile << cmat;
+      if( cmat != 0 ) lcadfile << " " << crho;
+      lcadfile << " imp:n=" << cimp << " $ implicit complement";
+    }
+    else{
+      int mat = 0;
+      get_int_prop( vol, cellid, "mat", mat );
+
+      if( mat == 0 ){
+        lcadfile << "0";
+      }
+      else{
+        double rho = 1.0;
+        get_real_prop( vol, cellid, "rho", rho );
+        lcadfile << mat << " " << rho;
+      }
+      lcadfile << " imp:n=" << imp_n;
+      if( imp_p > 0 ) lcadfile << " imp:p=" << imp_p;
+      if( imp_e > 0 ) lcadfile << " imp:e=" << imp_e;
+    }
+
+    lcadfile << std::endl;
+  }
+
+  // cells finished, skip a line
+  lcadfile << std::endl;
+  
+  // write the surface cards
+  for( int i = 1; i <= num_surfs; ++i ){
+    MBEntityHandle surf = DAG->entity_by_index( 2, i );
+    int surfid = DAG->id_by_index( 2, i );
+
+    if( DAG->has_prop( surf, "spec.reflect" ) ){
+      lcadfile << "*";
+    }
+    else if ( DAG->has_prop( surf, "white.reflect" ) ){
+      lcadfile << "+";
+    }
+    lcadfile << surfid << std::endl;
+  }
+
+  // surfaces finished, skip a line
+  lcadfile << std::endl;
+
+  // write the tally cards
+  std::vector<std::string> tally_specifiers;
+  rval = DAG->get_all_prop_values( "tally", tally_specifiers );
+  if( rval != MB_SUCCESS ) exit(EXIT_FAILURE);
+
+  for( std::vector<std::string>::iterator i = tally_specifiers.begin();
+       i != tally_specifiers.end(); ++i )
+  {
+    int dim = 0;
+    char* card = get_tallyspec( *i, dim );
+    if( card == NULL ){
+      std::cerr << "Invalid dag-mcnp tally specifier: " << *i << std::endl;
+      std::cerr << "This tally will not appear in the problem." << std::endl;
+      continue;
+    }
+    std::stringstream tally_card;
+
+    tally_card << card;
+    std::vector<MBEntityHandle> handles;
+    std::string s = *i;
+    rval = DAG->entities_by_property( "tally", handles, dim, &s );
+    if( rval != MB_SUCCESS ) exit (EXIT_FAILURE);
+
+    for( std::vector<MBEntityHandle>::iterator j = handles.begin();
+         j != handles.end(); ++j )
+    {
+      tally_card << " " << DAG->get_entity_id(*j);
+    }
+
+    tally_card  << " T";
+    delete[] card;
+
+    // write the contents of the the tally_card without exceeding 80 chars
+    std::string cardstr = tally_card.str();
+    while( cardstr.length() > 72 ){
+        size_t pos = cardstr.rfind(' ',72);
+        lcadfile << cardstr.substr(0,pos) << " &" << std::endl;
+        lcadfile << "     ";
+        cardstr.erase(0,pos);
+    }
+    lcadfile << cardstr << std::endl;
+  }
+  
+}
+
+void dagmcangl_(int *jsu, double *xxx, double *yyy, double *zzz, double *ang)
+{
+  MBEntityHandle surf = DAG->entity_by_index( 2, *jsu );
+  double xyz[3] = {*xxx, *yyy, *zzz};
+  MBErrorCode rval = DAG->get_angle(surf, xyz, ang, &history );
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC: failed in calling get_angle" <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "angl: " << *xxx << ", " << *yyy << ", " << *zzz << " --> " 
+            << ang[0] <<", " << ang[1] << ", " << ang[2] << std::endl;
+  MBCartVect uvw(last_uvw);
+  MBCartVect norm(ang);
+  double aa = angle(uvw,norm) * (180.0/M_PI);
+  std::cout << "    : " << aa << " deg to uvw" << (aa>90.0? " (!)":"")  << std::endl;
+#endif
+  
+}
+
+void dagmcchkcel_by_angle_( double *uuu, double *vvv, double *www, 
+                            double *xxx, double *yyy, double *zzz,
+                            int *jsu, int *i1, int *j)
+{
+
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout<< " " << std::endl;
+  std::cout<< "chkcel_by_angle: vol=" << DAG->id_by_index(3,*i1) << " surf=" << DAG->id_by_index(2,*jsu)
+           << " xyz=" << *xxx  << " " << *yyy << " " << *zzz << std::endl;
+  std::cout<< "               : uvw = " << *uuu << " " << *vvv << " " << *www << std::endl;
+#endif
+
+  double xyz[3] = {*xxx, *yyy, *zzz};
+  double uvw[3] = {*uuu, *vvv, *www};
+
+  MBEntityHandle surf = DAG->entity_by_index( 2, *jsu );
+  MBEntityHandle vol  = DAG->entity_by_index( 3, *i1 );
+
+  int result;
+  MBErrorCode rval = DAG->test_volume_boundary( vol, surf, xyz, uvw, result, &history );
+  if( MB_SUCCESS != rval ){
+    std::cerr << "DAGMC: failed calling test_volume_boundary" << std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  switch (result)
+      {
+      case 1: 
+        *j = 0; // inside==  1 -> inside volume -> j=0
+        break;
+      case 0:
+        *j = 1; // inside== 0  -> outside volume -> j=1
+        break;
+      default:
+        std::cerr << "Impossible result in dagmcchkcel_by_angle" << std::endl;
+        exit(EXIT_FAILURE);
+      }
+ 
+#ifdef TRACE_DAGMC_CALLS
+  std::cout<< "chkcel_by_angle: j=" << *j << std::endl;
+#endif
+
+}
+
+void dagmcchkcel_(double *uuu,double *vvv,double *www,double *xxx,
+                  double *yyy,double *zzz, int *i1, int *j)
+{
+
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout<< " " << std::endl;
+  std::cout<< "chkcel: vol=" << DAG->id_by_index(3,*i1) << " xyz=" << *xxx 
+           << " " << *yyy << " " << *zzz << std::endl;
+  std::cout<< "      : uvw = " << *uuu << " " << *vvv << " " << *www << std::endl;
+#endif
+
+  int inside;
+  MBEntityHandle vol = DAG->entity_by_index( 3, *i1 );
+  double xyz[3] = {*xxx, *yyy, *zzz};
+  double uvw[3] = {*uuu, *vvv, *www};
+  MBErrorCode rval = DAG->point_in_volume( vol, xyz, inside, uvw );
+
+  if (MB_SUCCESS != rval) {
+    std::cerr << "DAGMC: failed in point_in_volume" <<  std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  if (MB_SUCCESS != rval) *j = -2;
+  else
+    switch (inside)
+      {
+      case 1: 
+        *j = 0; // inside==  1 -> inside volume -> j=0
+        break;
+      case 0:
+        *j = 1; // inside== 0  -> outside volume -> j=1
+        break;
+      case -1:
+        *j = 1; // inside== -1 -> on boundary -> j=1 (assume leaving volume)
+        break;
+      default:
+        std::cerr << "Impossible result in dagmcchkcel" << std::endl;
+        exit(EXIT_FAILURE);
+      }
+  
+#ifdef TRACE_DAGMC_CALLS
+  std::cout<< "chkcel: j=" << *j << std::endl;
+#endif
+
+}
+
+
+void dagmcdbmin_( int *ih, double *xxx, double *yyy, double *zzz, double *huge, double* dbmin)
+{
+  double point[3] = {*xxx, *yyy, *zzz};
+
+  // get handle for this volume (*ih)
+  MBEntityHandle vol  = DAG->entity_by_index( 3, *ih );
+
+  // get distance to closest surface
+  MBErrorCode rval = DAG->closest_to_location(vol,point,*dbmin);
+
+  // if failed, return 'huge'
+  if (MB_SUCCESS != rval) {
+    *dbmin = *huge;
+    std::cerr << "DAGMC: error in closest_to_location, returning huge value from dbmin_" <<  std::endl;
+  }
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "dbmin " << DAG->id_by_index( 3, *ih ) << " dist = " << *dbmin << std::endl;
+#endif
+
+}
+
+void dagmcnewcel_( int *jsu, int *icl, int *iap )
+{
+
+  MBEntityHandle surf = DAG->entity_by_index( 2, *jsu );
+  MBEntityHandle vol  = DAG->entity_by_index( 3, *icl );
+  MBEntityHandle newvol = 0;
+
+  MBErrorCode rval = DAG->next_vol( surf, vol, newvol );
+  if( MB_SUCCESS != rval ){
+    *iap = -1;
+    std::cerr << "DAGMC: error calling next_vol, newcel_ returning -1" << std::endl;
+  }
+  
+  *iap = DAG->index_by_handle( newvol );
+
+  visited_surface = true;
+  
+#ifdef TRACE_DAGMC_CALLS
+  std::cout<< "newcel: prev_vol=" << DAG->id_by_index(3,*icl) << " surf= " 
+           << DAG->id_by_index(2,*jsu) << " next_vol= " << DAG->id_by_index(3,*iap) <<std::endl;
+
+#endif
+}
+
+void dagmc_surf_reflection_( double *uuu, double *vvv, double *www, int* verify_dir_change )
+{
+
+
+#ifdef TRACE_DAGMC_CALLS
+  // compute and report the angle between old and new
+  MBCartVect oldv(last_uvw);
+  MBCartVect newv( *uuu, *vvv, *www );
+  
+  std::cout << "surf_reflection: " << angle(oldv,newv)*(180.0/M_PI) << std::endl;;
+#endif
+
+  // a surface was visited
+  visited_surface = true;
+
+  bool update = true;
+  if( *verify_dir_change ){
+    if( last_uvw[0] == *uuu && last_uvw[1] == *vvv && last_uvw[2] == *www  )
+      update = false;
+  }
+
+  if( update ){
+    last_uvw[0] = *uuu;
+    last_uvw[1] = *vvv;
+    last_uvw[2] = *www;
+    history.reset_to_last_intersection();  
+  }
+
+#ifdef TRACE_DAGMC_CALLS
+  else{
+    // mark it in the log if nothing happened
+    std::cout << "(noop)";
+  }
+
+  std::cout << std::endl;
+#endif 
+
+}
+
+void dagmc_particle_terminate_( )
+{
+  history.reset();
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "particle_terminate:" << std::endl;
+#endif
+}
+
+// *ih              - volue index
+// *uuu, *vvv, *www - ray direction
+// *xxx, *yyy, *zzz - ray point
+// *huge            - passed to ray_fire as 'huge'
+// *dls             - output from ray_fire as 'dist_traveled'
+// *jap             - intersected surface index, or zero if none
+// *jsu             - previous surface index
+void dagmctrack_(int *ih, double *uuu,double *vvv,double *www,double *xxx,
+                 double *yyy,double *zzz,double *huge,double *dls,int *jap,int *jsu,
+                 int *nps )
+{
+    // Get data from IDs
+  MBEntityHandle vol = DAG->entity_by_index( 3, *ih );
+  MBEntityHandle prev = DAG->entity_by_index( 2, *jsu );
+  MBEntityHandle next_surf = 0;
+  double next_surf_dist;
+
+#ifdef ENABLE_RAYSTAT_DUMPS
+  moab::OrientedBoxTreeTool::TrvStats trv;
+#endif 
+
+  double point[3] = {*xxx,*yyy,*zzz};
+  double dir[3]   = {*uuu,*vvv,*www};  
+
+  /* detect streaming or reflecting situations */
+  if( last_nps != *nps || prev == 0 ){
+    // not streaming or reflecting: reset history
+    history.reset(); 
+#ifdef TRACE_DAGMC_CALLS
+    std::cout << "track: new history" << std::endl;
+#endif
+
+  }
+  else if( last_uvw[0] == *uuu && last_uvw[1] == *vvv && last_uvw[2] == *www ){
+    // streaming -- use history without change 
+    // unless a surface was not visited
+    if( !visited_surface ){ 
+      history.rollback_last_intersection();
+#ifdef TRACE_DAGMC_CALLS
+      std::cout << "     : (rbl)" << std::endl;
+#endif
+    }
+#ifdef TRACE_DAGMC_CALLS
+    std::cout << "track: streaming " << history.size() << std::endl;
+#endif
+  }
+  else{
+    // not streaming or reflecting
+    history.reset();
+
+#ifdef TRACE_DAGMC_CALLS
+    std::cout << "track: reset" << std::endl;
+#endif
+
+  }
+
+  MBErrorCode result = DAG->ray_fire(vol, point, dir, 
+                                     next_surf, next_surf_dist, &history, 
+                                     (use_dist_limit ? dist_limit : 0 )
+#ifdef ENABLE_RAYSTAT_DUMPS
+                                     , raystat_dump ? &trv : NULL 
+#endif
+                                     );
+
+  
+  if(MB_SUCCESS != result){
+    std::cerr << "DAGMC: failed in ray_fire" << std::endl;
+    exit( EXIT_FAILURE );
+  }
+
+  
+  for( int i = 0; i < 3; ++i ){ last_uvw[i] = dir[i]; } 
+  last_nps = *nps;
+
+  // Return results: if next_surf exists, then next_surf_dist will be nearer than dist_limit (if any)
+  if( next_surf != 0 ){
+    *jap = DAG->index_by_handle( next_surf ); 
+    *dls = next_surf_dist; 
+  }
+  else{
+    // no next surface 
+    *jap = 0;
+    if( use_dist_limit ){
+      // Dist limit on: return a number bigger than dist_limit
+      *dls = dist_limit * 2.0;
+    }
+    else{
+      // Dist limit off: return huge value, triggering lost particle
+      *dls = *huge;
+    }
+  }
+
+  visited_surface = false;
+  
+#ifdef ENABLE_RAYSTAT_DUMPS
+  if( raystat_dump ){
+
+    *raystat_dump << *ih << ",";
+    *raystat_dump << trv.ray_tri_tests() << ",";
+    *raystat_dump << std::accumulate( trv.nodes_visited().begin(), trv.nodes_visited().end(), 0 ) << ",";
+    *raystat_dump << std::accumulate( trv.leaves_visited().begin(), trv.leaves_visited().end(), 0 ) << std::endl;
+
+  }
+#endif 
+
+#ifdef TRACE_DAGMC_CALLS
+
+  std::cout<< "track: vol=" << DAG->id_by_index(3,*ih) << " prev_surf=" << DAG->id_by_index(2,*jsu) 
+           << " next_surf=" << DAG->id_by_index(2,*jap) << " nps=" << *nps <<std::endl;
+  std::cout<< "     : xyz=" << *xxx << " " << *yyy << " "<< *zzz << " dist = " << *dls << std::flush;
+  if( use_dist_limit && *jap == 0 ) std::cout << " > distlimit" << std::flush;
+  std::cout << std::endl;
+  std::cout<< "     : uvw=" << *uuu << " " << *vvv << " "<< *www << std::endl;
+#endif
+
+}
+
+void dagmc_bank_push_( int* nbnk )
+{
+  if( ((unsigned)*nbnk) != history_bank.size() ){
+    std::cerr << "bank push size mismatch: F" << *nbnk << " C" << history_bank.size() << std::endl;
+  }
+  history_bank.push_back( history );
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "bank_push (" << *nbnk+1 << ")" << std::endl;
+#endif
+}
+
+void dagmc_bank_usetop_( ) 
+{
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "bank_usetop" << std::endl;
+#endif
+
+  if( history_bank.size() ){
+    history = history_bank.back();
+  }
+  else{
+    std::cerr << "dagmc_bank_usetop_() called without bank history!" << std::endl;
+  }
+}
+
+void dagmc_bank_pop_( int* nbnk )
+{
+
+  if( ((unsigned)*nbnk) != history_bank.size() ){
+    std::cerr << "bank pop size mismatch: F" << *nbnk << " C" << history_bank.size() << std::endl;
+  }
+
+  if( history_bank.size() ){
+    history_bank.pop_back( ); 
+  }
+
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "bank_pop (" << *nbnk-1 << ")" << std::endl;
+#endif
+
+}
+
+void dagmc_bank_clear_( )
+{
+  history_bank.clear();
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "bank_clear" << std::endl;
+#endif
+}
+
+void dagmc_savpar_( int* n )
+{
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "savpar: " << *n << " ("<< history.size() << ")" << std::endl;
+#endif
+  pblcm_history_stack[*n] = history;
+}
+
+void dagmc_getpar_( int* n )
+{
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "getpar: " << *n << " (" << pblcm_history_stack[*n].size() << ")" << std::endl;
+#endif
+  history = pblcm_history_stack[*n];
+}
+
+
+void dagmcvolume_(int* mxa, double* vols, int* mxj, double* aras)
+{
+  MBErrorCode rval;
+  
+    // get size of each volume
+  int num_vols = DAG->num_entities(3);
+  for (int i = 0; i < num_vols; ++i) {
+    rval = DAG->measure_volume( DAG->entity_by_index(3, i+1), vols[i*2] );
+    if( MB_SUCCESS != rval ){
+      std::cerr << "DAGMC: could not measure volume " << i+1 << std::endl;
+      exit( EXIT_FAILURE );
+    }
+  }
+  
+    // get size of each surface
+  int num_surfs = DAG->num_entities(2);
+  for (int i = 0; i < num_surfs; ++i) {
+    rval = DAG->measure_area( DAG->entity_by_index(2, i+1), aras[i*2] );
+    if( MB_SUCCESS != rval ){
+      std::cerr << "DAGMC: could not measure surface " << i+1 << std::endl;
+      exit( EXIT_FAILURE );
+    }
+  }
+
+}
+
+void dagmc_setdis_(double *d)
+{
+  dist_limit = *d;
+#ifdef TRACE_DAGMC_CALLS
+  std::cout << "setdis: " << *d << std::endl;
+#endif
+}
+
+void dagmc_set_settings_(int* fort_use_dist_limit, int* use_cad, double* overlap_thickness, int* srccell_mode )
+{
+
+  if( *fort_use_dist_limit ){
+    std::cout << "DAGMC distance limit optimization is ENABLED" << std::endl;
+    use_dist_limit = true;
+  }
+
+  if( *srccell_mode ){
+    std::cout << "DAGMC source cell optimization is ENABLED (warning: experimental!)" << std::endl;
+  }
+
+  DAG->set_use_CAD( *use_cad );
+
+  DAG->set_overlap_thickness( *overlap_thickness );
+
+}
+
+void dagmc_init_settings_(int* fort_use_dist_limit, int* use_cad,    
+                          double* overlap_thickness, double* facet_tol, int* srccell_mode )
+{
+
+  *fort_use_dist_limit = use_dist_limit ? 1 : 0;
+
+  *use_cad = DAG->use_CAD() ? 1 : 0;
+
+  *overlap_thickness = DAG->overlap_thickness();
+  
+  *facet_tol = DAG->faceting_tolerance();
+
+
+  if( *srccell_mode ){
+    std::cout << "DAGMC source cell optimization is ENABLED (warning: experimental!)" << std::endl;
+  }
+
+}
+
+void dagmc_version_(double* dagmcVersion)
+{
+  *dagmcVersion = DAG->version();
+}
+

Property changes on: dagmc/mcnp_funcs.cpp
___________________________________________________________________
Added: svn:executable
   + *

Index: dagmc/meshtal_funcs.cpp
===================================================================
--- dagmc/meshtal_funcs.cpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/meshtal_funcs.cpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,460 @@
+#include "meshtal_funcs.h"
+
+#include <iostream>
+#include <sstream>
+#include <cstdlib>
+#include <fstream>
+
+#include "moab/Core.hpp"
+#include "MeshTally.hpp"
+#include "TrackLengthMeshTally.hpp"
+
+using moab::TrackLengthMeshTally;
+
+#include "KDEMeshTally.hpp"
+
+/********************************************************************
+ * File statics defining global meshtal data
+ ********************************************************************/ 
+
+
+/// number of source particle histories - used for debugging only
+static int history_count = 0; 
+
+/// number of calls to dagmc_fmesh_score - used for debugging only
+static int score_count = 0;
+
+/// The following four lists are indexed by the fmesh_index values
+/// used to index fmesh tallies in the fortran code.  Entries in 
+/// these lists may be NULL.
+
+/// List of all track length tallies that have been created.
+/// These tallies respond to fmesh mesh_score calls
+static std::vector< TrackLengthMeshTally* > tracklen_tallies;
+
+/// List of all KDE collision tallies that have been created.
+/// These tallies respond to dagmc_kde_tally calls
+static std::vector< KDEMeshTally* > kde_coll_tallies;
+
+/// List of all KDE track/subtrack tallies that have been created.
+/// These tallies respond to fmesh mesh_score calls
+static std::vector< KDEMeshTally* > kde_track_tallies;
+
+/// List of all dagmc-typed fmesh tallies: the entries are duplicates
+/// of the above lists with the same indexing.
+/// All our tallies are stored here, and respond to fmesh_print commands.
+static std::vector< MeshTally* > all_tallies;
+
+/// pointer to MCNP5's current cell ID variable (icl) 
+static const int* current_mcnp_cell;
+
+void mcnp_weight_calculation( int* index, double* erg, double* wgt, 
+                              double* dist, double* score_result )
+{
+    FMESH_FUNC(dagmc_mesh_score)( index, erg, wgt, dist, score_result );
+}
+
+
+
+/********************************************************************
+ * Initialization and setup functions
+ ********************************************************************/ 
+
+
+static bool initialized = false;
+
+/** 
+ * Called at least once from fmesh_mod on program initialization;
+ * in runtpe or MPI modes may be called multiple times.  
+ */
+void dagmc_fmesh_initialize_( const int* mcnp_icl ){
+
+  if( initialized ) return;
+
+  //std::cerr << "Executed DAGMC fmesh initialize." << std::endl;
+
+  current_mcnp_cell = mcnp_icl;
+
+  initialized = true;
+}
+
+/**
+ * Convert the contents of an FC card to an fmesh_params_t (i.e. a multimap<string,string>)
+ * @param fc_content The FC card's comment content as a string
+ * @param results The output data
+ * @param fcid The tally ID of the FC card
+ * @return true on success, or false if the input has serious enough formatting problems
+ *         to make parameter parsing impossible.
+ */
+static bool parse_fc_card( std::string& fc_content, fmesh_card::fc_params_t& results, int fcid ){
+
+  // convert '=' chars to spaces 
+  size_t found;
+   
+  found = fc_content.find_first_of('=');
+  while (found!= fc_content.npos )
+  {
+    fc_content[found] = ' ';
+    found = fc_content.find_first_of('=',found+1);
+  }
+
+  std::stringstream tokenizer(fc_content);
+
+  // skip tokens until 'dagmc' found
+  bool found_dagmc = false;
+  while( tokenizer ){
+    std::string dagmc; 
+    tokenizer >> dagmc;
+    if( dagmc == "dagmc" ){
+      found_dagmc = true;
+      break;
+    }
+  }
+
+  if( !found_dagmc ){
+    std::cerr << "Error: FC" << fcid << " card is incorrectly formatted" << std::endl;
+    return false;
+  }
+
+  std::string last_key;
+  while(tokenizer){
+    std::string token;
+    tokenizer >> token;
+
+    if( token == "" ) continue;
+    if( token == "-dagmc") break; // stop parsing if -dagmc encountered
+
+    if( last_key == "" ){ last_key = token; }
+    else{ 
+      results.insert(std::make_pair(last_key,token));
+      last_key = "";
+    }
+
+  }
+
+  if( last_key != "" ){
+    std::cerr << "Warning: FC" << fcid << " card has unused key '" << last_key << "'" << std::endl;
+  }
+
+  return true;
+
+}
+
+
+
+void dagmc_fmesh_setup_mesh_( int* /*ipt*/, int* id, int* fmesh_index, 
+                              double* energy_mesh, int* n_energy_mesh, int* tot_energy_bin, 
+                              char* fort_comment, int* n_comment_lines, int* is_collision_tally  )
+{
+
+  std::cerr << "Mesh tally " << *id << " has these " << *n_energy_mesh << " energy bins: " << std::endl;
+  for( int i = 0; i < *n_energy_mesh; ++i ){
+    std::cerr << "     " << energy_mesh[i] << std::endl;
+  }
+  std::cerr << "tot bin: " << (*tot_energy_bin ? "yes" : "no") << std::endl;
+  
+  if( *n_comment_lines <= 0 ){
+    std::cerr << "FMESH" << *id << " has geom=dag without matching FC card" << std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  std::string comment_str; 
+
+  
+  {
+    // Copy comment string out of fortran's data structure, and get it into comment_str
+    // Need to turn it into a c-style string first
+
+    const unsigned int fort_line_len = 75;
+    unsigned int comment_len = fort_line_len * *n_comment_lines;
+    char* c_comment = new char[(comment_len+1)];
+    
+    memcpy(c_comment,fort_comment,comment_len);
+    c_comment[comment_len]='\0';
+    
+    comment_str = c_comment;
+    delete[] c_comment;
+
+  }
+  
+  fmesh_card fmesh_settings;
+  fmesh_settings.id = *id;
+  fmesh_settings.fmesh_index = *fmesh_index;
+  fmesh_settings.num_ebin_bounds = *n_energy_mesh;
+  fmesh_settings.energy_bin_bounds = energy_mesh;
+  fmesh_settings.total_energy_bin = (*tot_energy_bin == 1);
+
+  fmesh_card::fc_params_t& fc_settings = fmesh_settings.fc_params;
+
+  bool success = parse_fc_card( comment_str, fc_settings, *id );
+  if( !success ){
+    exit(EXIT_FAILURE);
+  }
+
+  // pad all tally lists with nulls up to a max of (*fmesh_index)
+  while( all_tallies.size() <= (unsigned)(*fmesh_index) ){
+    tracklen_tallies.push_back(NULL);
+    kde_coll_tallies.push_back(NULL);
+    kde_track_tallies.push_back(NULL);
+    all_tallies.push_back(NULL);
+    
+  }
+
+  // determine the user-specified tally type
+  std::string type = "tracklen";
+  *is_collision_tally = 0;
+
+  if( fc_settings.find("type") != fc_settings.end() ){
+
+    type = (*fc_settings.find("type")).second;
+    if( fc_settings.count("type") > 1 ){
+      std::cerr << "Warning: FC" << *id << " has multiple 'type' keywords, using " << type << std::endl;
+    }
+    
+    // remove the type keywords
+    fc_settings.erase("type"); 
+  }
+  
+  moab::Interface* mbi = new moab::Core();
+
+  MeshTally *new_tally;
+
+  if( type == "tracklen" ){
+
+    TrackLengthMeshTally* t = TrackLengthMeshTally::setup( fmesh_settings, mbi, current_mcnp_cell );
+    new_tally = tracklen_tallies[*fmesh_index] = t;
+
+  }
+  else if( type == "kde_coll" ){
+  
+    *is_collision_tally = 1; 
+
+    KDEMeshTally* kde = KDEMeshTally::setup( fmesh_settings, mbi );
+    new_tally = kde_coll_tallies[*fmesh_index] = kde;
+
+  }
+  else if( type == "kde_track" || type == "kde_subtrack" ){
+
+    KDEMeshTally::TallyType kde_type = KDEMeshTally::TRACKLENGTH;
+
+    if ( type == "kde_subtrack" )
+      kde_type = KDEMeshTally::SUBTRACK;
+
+    KDEMeshTally* kde = KDEMeshTally::setup( fmesh_settings, mbi, kde_type );
+    new_tally = kde_track_tallies[*fmesh_index] = kde;
+
+  }
+  else{
+    std::cerr << "FC" << *id << " error: cannot make mesh tally of type " << type << std::endl;
+    exit( EXIT_FAILURE );
+  }
+
+  all_tallies[*fmesh_index] = new_tally;
+  
+}
+
+/********************************************************************
+ * Runtape and MPI calls
+ ********************************************************************/ 
+
+/**
+ * Get a fortran pointer to the tally array for the specified mesh tally.
+ * Called when this data needs to be written or read from a runtpe file or 
+ * an MPI stream.
+ */
+void dagmc_fmesh_get_tally_data_( int* fmesh_index, void* fortran_data_pointer ){
+  double* data; 
+  int length;
+ 
+  data = all_tallies[*fmesh_index]->get_tally_data( length );
+  FMESH_FUNC( dagmc_make_fortran_pointer )( fortran_data_pointer, data, &length );
+}
+
+/**
+ * Get a fortran pointer to the error array for the specified mesh tally.
+ * Called when this data needs to be written or read from a runtpe file or 
+ * an MPI stream.
+ */
+
+void dagmc_fmesh_get_error_data_( int* fmesh_index, void* fortran_data_pointer ){
+  double* data; 
+  int length;
+ 
+  data = all_tallies[*fmesh_index]->get_error_data( length );
+  FMESH_FUNC( dagmc_make_fortran_pointer )( fortran_data_pointer, data, &length );
+}
+
+/**
+ * Get a fortran pointer to the scratch array for the specified mesh tally.
+ * Called when this data needs to be written or read from a runtpe file or 
+ * an MPI stream.
+ */
+void dagmc_fmesh_get_scratch_data_( int* fmesh_index, void* fortran_data_pointer ){
+  double* data; 
+  int length;
+  
+  data = all_tallies[*fmesh_index]->get_scratch_data( length );
+  FMESH_FUNC( dagmc_make_fortran_pointer )( fortran_data_pointer, data, &length );
+}
+
+/**
+ * Set the tally and error arrays of the specified mesh tally to all zeros.
+ * Called when an MPI subtask has just sent all its tally and error values
+ * back to the master task.
+ */
+void dagmc_fmesh_clear_data_( int* fmesh_index ){
+
+  all_tallies[*fmesh_index]->zero_tally_data( );
+
+}
+
+/**
+ * Add the values in this mesh's scratch array to its tally array.
+ * Called when merging together values from MPI subtasks at the master task.
+ */
+void dagmc_fmesh_add_scratch_to_tally_( int* fmesh_index ){
+  double* data, *scratch;
+  int length, scratchlength;
+
+  data = all_tallies[*fmesh_index]->get_tally_data( length );
+  scratch = all_tallies[*fmesh_index]->get_scratch_data( scratchlength );
+  
+  assert( scratchlength >= length );
+
+  for( int i = 0; i < length; ++i ){
+    data[i] += scratch[i];
+  }
+}
+
+/**
+ * Add the values in this mesh's scratch array to its error array.
+ * Called when merging together values from MPI subtasks at the master task.
+ */
+void dagmc_fmesh_add_scratch_to_error_( int* fmesh_index ){
+  double* data, *scratch;
+  int length, scratchlength;
+
+  data = all_tallies[*fmesh_index]->get_error_data( length );
+  scratch = all_tallies[*fmesh_index]->get_scratch_data( scratchlength );
+  
+  assert( scratchlength >= length );
+
+  for( int i = 0; i < length; ++i ){
+    data[i] += scratch[i];
+  }
+}
+
+/********************************************************************
+ * Routine calls from fmesh_mod: track length reports and print commands
+ ********************************************************************/ 
+
+/**
+ * Called from fortran when a source particle history ends
+ */
+void dagmc_fmesh_end_history_(){
+  history_count += 1;
+
+  for( std::vector< MeshTally* >::iterator i = all_tallies.begin();
+       i != all_tallies.end(); ++i )
+  {
+    if( *i ){
+      (*i)->end_history( );
+    }
+  }
+
+#ifdef MESHTAL_DEBUG
+  std::cout << "* History ends *" << std::endl;
+#endif
+
+}
+
+/**
+ * Called from fortran to score a particular track length on fmesh with fmesh_index 
+ * @param fmesh_index index of mesh tally
+ * @param x, y, z - particle location
+ * @param u, v, w - particle direction
+ * @param erg particle energy
+ * @param wgt particle weight
+ * @param d track length
+ */
+void dagmc_fmesh_score_( int *fmesh_index, double *x, double *y, double *z,
+                         double *u, double *v, double *w, double *erg,double *wgt,double *d, int* ien )
+{
+
+  if( tracklen_tallies[*fmesh_index] ){
+    score_count += 1;
+    
+    moab::CartVect ray = moab::CartVect(*x,*y,*z);
+    moab::CartVect vec = moab::CartVect(*u,*v,*w);
+    
+    MCNPTrackParam param( fmesh_index, erg, wgt );
+    
+#ifdef MESHTAL_DEBUG
+    std::cout << "meshtal particle: " << ray << " " << vec << " " << *d << std::endl;
+#endif
+    
+    tracklen_tallies[*fmesh_index]->add_track_segment( ray, vec, *d, (*ien)-1, &param );
+
+  }
+  else if ( kde_track_tallies[*fmesh_index] ) {
+
+    moab::CartVect loc( *x, *y, *z );
+    moab::CartVect dir( *u, *v, *w );
+    
+    KDEWeightParam param( fmesh_index, wgt, erg );
+    param.tracklength = d;    
+    
+    kde_track_tallies[*fmesh_index]->tally_track( param, loc, dir, (*ien)-1 ); 
+
+  }
+
+}
+
+/**
+ * Called from fortan to instruct a particular tally to print its data to the appropriate file
+ * @param fmesh_index The mesh to be printed right now
+ * @param sp_norm "Source Particle Normalization" - the number of source particles so far
+ * @param fmesh_fact Multiplication factor for this tally, as recorded in fmesh_mod
+ */
+void dagmc_fmesh_print_( int* fmesh_index, double* sp_norm, double* fmesh_fact ){
+
+  if( all_tallies[*fmesh_index] ){
+    all_tallies[*fmesh_index]->print( *sp_norm, *fmesh_fact );
+  }
+
+}
+
+/**  
+ *   Obtains the collision position (x,y,z), the particle weight (wgt), the
+ *   total macroscopic cross section of the current cell (ple), and the
+ *   particle energy (erg) from MCNP for use in the KDE collision tally.
+ *
+ *   called from hstory.F90
+ */
+void dagmc_kde_tally_( double* x, double* y, double* z, double* wgt,
+                       double* ple, double* erg )
+{
+  // Record collision on all valid KDE tallies
+  for( std::vector<KDEMeshTally*>::iterator i = kde_coll_tallies.begin(); i!=kde_coll_tallies.end(); ++i ){
+    if( *i ){
+
+      int ien; // index of the energy bin for this collision 
+      int idx = (*i)->get_fmesh_index();
+      
+      // ask Fortran to pick the energy bin for this collision
+      FMESH_FUNC( dagmc_mesh_choose_ebin )( &idx, erg, &ien );
+
+      if( ien == -1 ) continue; // erg falls outside of requested energy bins for this mesh
+
+      ien -= 1; // convert fortran array index to C index
+
+      moab::CartVect collision_loc( *x, *y, *z );
+
+      KDEWeightParam param( &idx, wgt, erg );
+      param.total_xs = ple;
+
+      (*i)->tally_collision( param, collision_loc, ien );
+    }
+  }
+}
+
Index: dagmc/Matrix3.hpp
===================================================================
--- dagmc/Matrix3.hpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/Matrix3.hpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,289 @@
+/*
+ * MOAB, a Mesh-Oriented datABase, is a software component for creating,
+ * storing and accessing finite element mesh data.
+ * 
+ * Copyright 2004 Sandia Corporation.  Under the terms of Contract
+ * DE-AC04-94AL85000 with Sandia Coroporation, the U.S. Government
+ * retains certain rights in this software.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ */
+
+/**\file Matrix3.hpp
+ *\author Jason Kraftcheck (kraftche@cae.wisc.edu)
+ *\date 2006-07-18
+ */
+
+#ifndef MB_MATRIX_3_HPP
+#define MB_MATRIX_3_HPP
+
+#include "moab/CartVect.hpp"
+#include "moab/Types.hpp"
+#include <iosfwd>
+#include <limits>
+
+#ifdef _MSC_VER
+# define finite _finite
+#endif
+
+namespace moab {
+
+class Matrix3 
+{
+  double d[9];
+public:
+
+  inline Matrix3() 
+    {}
+  
+  inline Matrix3( double diagonal )
+    { 
+      d[0] = d[4] = d[8] = diagonal;
+      d[1] = d[2] = d[3] = 0;
+      d[5] = d[6] = d[7] = 0;
+    }
+    
+  inline Matrix3( const CartVect& diagonal )
+    { 
+      d[0] = diagonal[0];
+      d[4] = diagonal[1],
+      d[8] = diagonal[2];
+      d[1] = d[2] = d[3] = 0;
+      d[5] = d[6] = d[7] = 0;
+    }
+  
+  
+  inline Matrix3( const CartVect& row0,
+                    const CartVect& row1,
+                    const CartVect& row2 )
+    {
+      row0.get( d );
+      row1.get( d+3 );
+      row2.get( d+6 );
+    }
+  
+  inline Matrix3( const double* v )
+    { 
+      d[0] = v[0]; d[1] = v[1]; d[2] = v[2];
+      d[3] = v[3]; d[4] = v[4]; d[5] = v[5]; 
+      d[6] = v[6]; d[7] = v[7]; d[8] = v[8];
+    }
+  
+  inline Matrix3( double v00, double v01, double v02,
+                    double v10, double v11, double v12,
+                    double v20, double v21, double v22 )
+    {
+      d[0] = v00; d[1] = v01; d[2] = v02;
+      d[3] = v10; d[4] = v11; d[5] = v12;
+      d[6] = v20; d[7] = v21; d[8] = v22;
+    }
+  
+  inline Matrix3( const Matrix3& m )
+    {
+      d[0] = m.d[0]; d[1] = m.d[1]; d[2] = m.d[2];
+      d[3] = m.d[3]; d[4] = m.d[4]; d[5] = m.d[5];
+      d[6] = m.d[6]; d[7] = m.d[7]; d[8] = m.d[8];
+    }
+   
+  inline Matrix3& operator=( const Matrix3& m )
+    {
+      d[0] = m.d[0]; d[1] = m.d[1]; d[2] = m.d[2];
+      d[3] = m.d[3]; d[4] = m.d[4]; d[5] = m.d[5];
+      d[6] = m.d[6]; d[7] = m.d[7]; d[8] = m.d[8];
+      return *this;
+    }
+  
+  inline Matrix3& operator=( const double* v )
+    { 
+      d[0] = v[0]; d[1] = v[1]; d[2] = v[2];
+      d[3] = v[3]; d[4] = v[4]; d[5] = v[5]; 
+      d[6] = v[6]; d[7] = v[7]; d[8] = v[8];
+      return *this;
+    }
+
+  inline double* operator[]( unsigned i )
+    { return d + 3*i; }
+  inline const double* operator[]( unsigned i ) const
+    { return d + 3*i; }
+  inline double& operator()(unsigned r, unsigned c)
+    { return d[3*r+c]; }
+  inline double operator()(unsigned r, unsigned c) const
+    { return d[3*r+c]; }
+  
+  inline Matrix3& operator+=( const Matrix3& m )
+    {
+      d[0] += m.d[0]; d[1] += m.d[1]; d[2] += m.d[2];
+      d[3] += m.d[3]; d[4] += m.d[4]; d[5] += m.d[5];
+      d[6] += m.d[6]; d[7] += m.d[7]; d[8] += m.d[8];
+      return *this;
+    }
+  
+  inline Matrix3& operator-=( const Matrix3& m )
+    {
+      d[0] -= m.d[0]; d[1] -= m.d[1]; d[2] -= m.d[2];
+      d[3] -= m.d[3]; d[4] -= m.d[4]; d[5] -= m.d[5];
+      d[6] -= m.d[6]; d[7] -= m.d[7]; d[8] -= m.d[8];
+      return *this;
+    }
+  
+  inline Matrix3& operator*=( double s )
+    {
+      d[0] *= s; d[1] *= s; d[2] *= s;
+      d[3] *= s; d[4] *= s; d[5] *= s;
+      d[6] *= s; d[7] *= s; d[8] *= s;
+      return *this;
+    }
+  
+  inline Matrix3& operator/=( double s )
+    {
+      d[0] /= s; d[1] /= s; d[2] /= s;
+      d[3] /= s; d[4] /= s; d[5] /= s;
+      d[6] /= s; d[7] /= s; d[8] /= s;
+      return *this;
+    }
+  
+  inline Matrix3& operator*=( const Matrix3& m );
+  
+  inline double determinant() const;
+  
+  inline Matrix3 inverse() const;
+  
+    // invert matrix without re-calculating the
+    // reciprocal of the determinant.
+  inline Matrix3 inverse( double inverse_det ) const;
+  
+  inline bool positive_definite() const;
+  inline bool positive_definite( double& determinant_out ) const;
+  
+  inline Matrix3 transpose() const;
+  
+  inline bool invert();
+  
+    // Calculate determinant of 2x2 submatrix composed of the
+    // elements not in the passed row or column.
+  inline double subdet( int r, int c ) const;
+};
+
+inline Matrix3 operator+( const Matrix3& a, const Matrix3& b )
+  { return Matrix3(a) += b; }
+
+inline Matrix3 operator-( const Matrix3& a, const Matrix3& b )
+  { return Matrix3(a) -= b; }
+
+inline Matrix3 operator*( const Matrix3& a, const Matrix3& b )
+{
+  return Matrix3( a(0,0) * b(0,0) + a(0,1) * b(1,0) + a(0,2) * b(2,0),
+                    a(0,0) * b(0,1) + a(0,1) * b(1,1) + a(0,2) * b(2,1),
+                    a(0,0) * b(0,2) + a(0,1) * b(1,2) + a(0,2) * b(2,2),
+                    a(1,0) * b(0,0) + a(1,1) * b(1,0) + a(1,2) * b(2,0),
+                    a(1,0) * b(0,1) + a(1,1) * b(1,1) + a(1,2) * b(2,1),
+                    a(1,0) * b(0,2) + a(1,1) * b(1,2) + a(1,2) * b(2,2),
+                    a(2,0) * b(0,0) + a(2,1) * b(1,0) + a(2,2) * b(2,0),
+                    a(2,0) * b(0,1) + a(2,1) * b(1,1) + a(2,2) * b(2,1),
+                    a(2,0) * b(0,2) + a(2,1) * b(1,2) + a(2,2) * b(2,2) );
+}
+
+inline Matrix3& Matrix3::operator*=( const Matrix3& m )
+  { return *this = Matrix3(*this) * m; }
+
+inline Matrix3 outer_product( const CartVect& u,
+                                const CartVect& v )
+{
+  return Matrix3( u[0] * v[0], u[0] * v[1], u[0] * v[2],
+                    u[1] * v[0], u[1] * v[1], u[1] * v[2],
+                    u[2] * v[0], u[2] * v[1], u[2] * v[2] );
+}
+
+inline CartVect operator*( const CartVect& v, const Matrix3& m )
+{
+  return CartVect( v[0] * m(0,0) + v[1] * m(1,0) + v[2] * m(2,0),
+                     v[0] * m(0,1) + v[1] * m(1,1) + v[2] * m(2,1),
+                     v[0] * m(0,2) + v[1] * m(1,2) + v[2] * m(2,2) );
+}
+
+inline CartVect operator*( const Matrix3& m, const CartVect& v )
+{
+  return CartVect( v[0] * m(0,0) + v[1] * m(0,1) + v[2] * m(0,2),
+                     v[0] * m(1,0) + v[1] * m(1,1) + v[2] * m(1,2),
+                     v[0] * m(2,0) + v[1] * m(2,1) + v[2] * m(2,2) );
+} 
+
+inline double Matrix3::determinant() const
+{
+  return d[0] * d[4] * d[8] 
+       + d[1] * d[5] * d[6]
+       + d[2] * d[3] * d[7]
+       - d[0] * d[5] * d[7]
+       - d[1] * d[3] * d[8]
+       - d[2] * d[4] * d[6];
+}
+
+inline bool Matrix3::positive_definite( double& det ) const
+{
+  double subdet6 = d[1]*d[5]-d[2]*d[4];
+  double subdet7 = d[2]*d[3]-d[0]*d[5];
+  double subdet8 = d[0]*d[4]-d[1]*d[3];
+  det = d[6]*subdet6 + d[7]*subdet7 + d[8]*subdet8;
+  return d[0] > 0 && subdet8 > 0 && det > 0;
+}
+
+inline bool Matrix3::positive_definite() const
+{
+  double d;
+  return positive_definite(d);
+}
+
+inline Matrix3 Matrix3::inverse( double i ) const
+{
+  return Matrix3( i * (d[4] * d[8] - d[5] * d[7]),
+                    i * (d[2] * d[7] - d[8] * d[1]),
+                    i * (d[1] * d[5] - d[4] * d[2]),
+                    i * (d[5] * d[6] - d[8] * d[3]),
+                    i * (d[0] * d[8] - d[6] * d[2]),
+                    i * (d[2] * d[3] - d[5] * d[0]),
+                    i * (d[3] * d[7] - d[6] * d[4]),
+                    i * (d[1] * d[6] - d[7] * d[0]),
+                    i * (d[0] * d[4] - d[3] * d[1]) );
+}  
+
+inline Matrix3 Matrix3::inverse() const
+{
+  return inverse( 1.0 / determinant() );
+}
+
+inline bool Matrix3::invert()
+{
+  double i = 1.0 / determinant();
+  if (!finite(i) || fabs(i) < std::numeric_limits<double>::epsilon())
+    return false;
+  *this = inverse( i );
+  return true;
+}
+
+inline Matrix3 Matrix3::transpose() const
+{
+  return Matrix3( d[0], d[3], d[6],
+                    d[1], d[4], d[7],
+                    d[2], d[5], d[8] );
+}
+
+inline double Matrix3::subdet( int r, int c ) const
+{
+  const int r1 = (r+1)%3, r2 = (r+2)%3;
+  const int c1 = (c+1)%3, c2 = (c+2)%3;
+  return d[3*r1+c1]*d[3*r2+c2] - d[3*r1+c2]*d[3*r2+c1];
+}
+                         
+ErrorCode EigenDecomp( const Matrix3& a, 
+                         double Eigenvalues[3],
+                         CartVect Eigenvectors[3] );
+
+std::ostream& operator<<( std::ostream&, const Matrix3& );
+  
+} // namespace moab
+
+#endif
Index: dagmc/KDETrack.hpp
===================================================================
--- dagmc/KDETrack.hpp	(.../vendor/5.1.60/Source)	(revision 0)
+++ dagmc/KDETrack.hpp	(.../5.1.60/trunk/Source)	(revision 424)
@@ -0,0 +1,228 @@
+// KDETrack.hpp
+
+#ifndef KDETRACK_H
+#define KDETRACK_H
+
+#include <vector>
+
+#include "moab/CartVect.hpp"
+
+#include "KDEKernel.hpp"
+
+/** 
+ * A class that represents the kernel density estimator contribution for one 
+ * track segment from a particle's history in a Monte Carlo particle transport
+ * simulation. 
+ */
+class KDETrack {
+
+  public:
+
+    /**
+     * Default constructor.  Constructs a kernel density estimator object for a
+     * track segment of length 1.0 beginning at (0,0,0) with direction (1,0,0)
+     * and bandwidth (0.1,0.1,0.1).  All contributions are computed using the
+     * integral estimator.
+     */
+    KDETrack( KDEKernel* k );
+
+    /**
+     * Constructs a kernel density estimator object for a track segment based
+     * on the bandwidth H.  The default mode for this function is to compute
+     * all contributions using the integral estimator.
+     *
+     * NOTE: To use the subtrack estimator instead of the integral estimator,
+     * simply add a non-zero value for the "numSubtracks" parameter.
+     *
+     * @param start_point the starting location of the track (xo, yo, zo)
+     * @param direction the direction the particle is traveling (uo, vo, wo)
+     * @param bandwidth the set of bandwidth values (hx, hy, hz)
+     * @param track_length the length of the track segment
+     * @param k the kernel function to be used in the computation
+     * @param numSubtracks (optional) the number of subtracks to be used
+     */
+    KDETrack( const moab::CartVect & start_point,
+              const moab::CartVect & direction,
+              const moab::CartVect & bandwidth,
+              const double track_length,
+              KDEKernel* k,
+              unsigned int numSubtracks = 0 );
+
+    /**
+     * @return the starting point Xo = (xo, yo, zo)
+     */
+    moab::CartVect get_start_point();
+    
+    /**
+     * @return the direction Uo = (uo, vo, wo)
+     */
+    moab::CartVect get_direction();
+
+    /**
+     * @return the set of bandwidth values H = (hx, hy, hz)
+     */
+    moab::CartVect get_bandwidth();
+
+    /**
+     * @return the length of the track segment
+     */
+    double get_length();
+
+    /**
+     * Gets the parameters of the neighborhood for which the contribution
+     * may be non-zero.  This includes the coordinates of the minimum and
+     * maximum corners, in addition to the maximum radius around the track.
+     *
+     * @param box_min returns the minimum corner of the neighborhood
+     * @param box_max returns the maximum corner of the neighborhood
+     * @param max_radius returns the maximum radius around the track
+     */
+    void get_neighborhood( double box_min[3],
+                           double box_max[3],
+                           double & max_radius );
+    
+    /**
+     * Changes the starting point, direction and track length of the track
+     * segment.  Also updates the neighborhood and stored subtrack points
+     * (if non-empty) to reflect the new track values.
+     *
+     * @param newXo the new starting point (xo, yo, zo)
+     * @param newUo the new direction (uo, vo, wo)
+     * @param newLength the new track lenth
+     */
+    void change_track_segment( const moab::CartVect & newXo,
+                               const moab::CartVect & newUo,
+                               const double newLength );
+
+    /**
+     * Changes the set of bandwidth values and updates the neighborhood to
+     * reflect the new values.
+     *
+     * @param newH the new set of bandwidth values (hx, hy, hz)
+     */
+    void change_bandwidth( const moab::CartVect & newH );
+
+    /**
+     * Tests if the perpendicular distance from the calculation point X to
+     * the line defined by the track segment is less than the maximum radius
+     * of the neighborhood around the track.  Any point that fails this test
+     * is guaranteed to have a zero contribution.
+     *
+     * @param X the calculation point to be tested
+     * @return true if the calculation point lies within the maximum radius
+     */
+    bool point_within_max_radius( const moab::CartVect & X );
+
+    /**
+     * Computes the kernel contribution K_xyz for the track segment using
+     * the given calculation point X.
+     *
+     * @param X the calculation point to be evaluated
+     * @return the kernel density estimator contribution at the given point
+     */
+    double compute_contribution( const moab::CartVect & X );
+
+    /**
+     * Computes the kernel contribution K_xyz for the track segment using
+     * the given calculation point coordinates.
+     *
+     * @param coords the calculation point to be evaluated
+     * @return the kernel density estimator contribution at the given point
+     */
+    double compute_contribution( const double coords[3] );
+
+    /**
+     * Subdivides the track segment into p subtracks of equal length and
+     * randomly choses the coordinates of a point from each subtrack.  This
+     * function is called in the constructor if the subtrack estimator is
+     * requested (i.e. numSubtracks > 0 ) and the results are stored in the
+     * vector subtrack_points.  However, it may also be used to obtain a
+     * set of p random locations along the track for computing an optimal
+     * bandwidth value for either subtrack or track tallies.
+     *
+     * @param p the number of subtracks to be used
+     * @return the vector containing p randomly chosen points along the track
+     */
+    std::vector<moab::CartVect> choose_points( int p );
+
+  private:
+
+    /**
+     * A struct that represents a track segment.
+     */
+    struct track_segment {
+
+      moab::CartVect Xo;  
+      moab::CartVect Uo;    
+      double length;
+
+    };
+ 
+    track_segment track;  // stores information about the track segment
+    moab::CartVect H;     // the set of bandwidth values (hx, hy, hz)
+    KDEKernel* kernel;    // the kernel to be used in the computation
+
+    // neighborhood parameters
+    double min[3];        // minimum corner
+    double max[3];        // maximum corner
+    double radius;    // maximum radius around the track
+
+    /**
+     * Sets the neighborhood around the track segment for which a non-zero
+     * contribution may occur.
+     */
+    void set_neighborhood();
+
+    // subtrack estimator parameters
+    static bool seed_is_set;
+    std::vector<moab::CartVect> subtrack_points;  // random points along track
+
+    /**
+     * The set_integral_limits function determines the limits of integration
+     * for the integral of the 3D path-length dependent kernel function k(X,s)
+     * with respect to path length s for the given calculation point X.
+     *
+     * @param X the calculation point to be evaluated
+     * @param lower returns the lower limit of integration
+     * @param upper returns the upper limit of integration
+     * @return true if valid limits of integration exist
+     *
+     * NOTE: if this function returns false, that means there are no valid
+     * limits of integration within the range from 0 to total track length.
+     * This essentially means that the resulting integrand over this range
+     * would have been zero.
+     */
+    bool set_integral_limits( const moab::CartVect & X,
+                              double & lower, double & upper );
+
+    /**
+     * The integrate_path_kernel function computes the integral of the 3D
+     * path-length dependent kernel function k(X,s) with respect to s for
+     * the given calculation point X, using the limits of integration as
+     * determined by the set_integral_limits function.
+     *
+     * NOTE: this function is only called by the compute_contribution function
+     * if numSubtracks is set to zero in the KDETrack constructor.
+     *
+     * @param X the calculation point to be evaluated
+     * @return the value of the path-length dependent kernel integral
+     */
+    double integrate_path_kernel( const moab::CartVect & X );
+
+    /**
+     * The sum_subtracks function computes the average 3D kernel contribution
+     * for the number of subtracks requested for the given calculation point X,
+     * using the randomly chosen points along the track that were computed by
+     * the choose_points function.
+     *
+     * NOTE: this function is only called by the compute_contribution function
+     * if numSubtracks is set to a non-zero value in the KDETrack constructor.
+     *
+     * @param X the calculation point to be evaluated
+     * @return the average kernel contribution along a subtrack
+     */
+    double sum_subtracks( const moab::CartVect & X );
+
+};
+
+#endif

Property changes on: dagmc
___________________________________________________________________
Added: svn:mergeinfo
   Merged /5.1.51/trunk/Source/dagmc:r376-423

Index: Makefile
===================================================================
--- Makefile	(.../vendor/5.1.60/Source)	(revision 424)
+++ Makefile	(.../5.1.60/trunk/Source)	(revision 424)
@@ -20 +20 @@
-  CONFIG = $(menup) $(menuproc) $(menub) $(debug) $(menuf90) $(menucc) $(MPI)
+  CONFIG = $(menup) $(menudag) $(menuproc) $(menub) $(debug) $(menuf90) $(menucc) $(MPI)
@@ -92 +92 @@
-	@ [ -d $(TEST_DIR) ] && $(MAKE) -s -C $(TEST_DIR) clean
+	#@ [ -d $(TEST_DIR) ] && $(MAKE) -s -C $(TEST_DIR) clean

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /5.1.51/trunk/Source:r403-423

