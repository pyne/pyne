###################
###  WARNING!!! ###
###################
# This file has been autogenerated

# Cython imports
from libcpp.set cimport set as cpp_set
from libcpp.vector cimport vector as cpp_vector
from cython.operator cimport dereference as deref
from cython.operator cimport preincrement as inc
from libc.stdlib cimport malloc, free

# Python Imports
import collections

cimport numpy as np
import numpy as np

np.import_array()

# Local imports
include "include/cython_version.pxi"
IF CYTHON_VERSION_MAJOR == 0 and CYTHON_VERSION_MINOR >= 17:
    from libcpp.string cimport string as std_string
    from libcpp.utility cimport pair
    from libcpp.map cimport map as cpp_map
    from libcpp.vector cimport vector as cpp_vector
ELSE:
    from pyne._includes.libcpp.string cimport string as std_string
    from pyne._includes.libcpp.utility cimport pair
    from pyne._includes.libcpp.map cimport map as cpp_map
    from pyne._includes.libcpp.vector cimport vector as cpp_vector
cimport extra_types

cdef extra_types.complex_t py2c_complex(object pyv):
    cdef extra_types.complex_t cv
    pyv = complex(pyv)
    cv = extra_types.complex_t()
    cv.re = pyv.real
    cv.im = pyv.imag
    return cv

cdef np.ndarray c2py_vector_dbl(cpp_vector[double] * v):
    cdef np.ndarray vview
    cdef np.ndarray pyv
    cdef np.npy_intp v_shape[1]
    v_shape[0] = <np.npy_intp> v.size()
    vview = np.PyArray_SimpleNewFromData(1, v_shape, np.NPY_FLOAT64, &v[0][0])
    pyv = np.PyArray_Copy(vview)
    return pyv

cdef cpp_vector[double] py2c_vector_dbl(object v):
    cdef int i
    cdef int v_size = len(v)
    cdef double * v_data
    cdef cpp_vector[double] vec
    if isinstance(v, np.ndarray) and (<np.ndarray> v).descr.type_num == np.NPY_FLOAT64:
        v_data = <double *> np.PyArray_DATA(<np.ndarray> v)
        vec = cpp_vector[double](<size_t> v_size)
        for i in range(v_size):
            vec[i] = v_data[i]
    else:
        vec = cpp_vector[double](<size_t> v_size)
        for i in range(v_size):
            vec[i] = <double> v[i]
    return vec

# integer sets
cdef cpp_set[int] py_to_cpp_set_int(set pyset):
    cdef int v
    cdef cpp_set[int] cppset = cpp_set[int]()
    for value in pyset:
        v = value
        cppset.insert(v)
    return cppset

cdef set cpp_to_py_set_int(cpp_set[int] cppset):
    pyset = set()
    cdef cpp_set[int].iterator setiter = cppset.begin()
    while setiter != cppset.end():
        pyset.add(int(deref(setiter)))
        inc(setiter)
    return pyset


# string sets
cdef cpp_set[std_string] py_to_cpp_set_str(set pyset):
    cdef std_string v
    cdef cpp_set[std_string] cppset = cpp_set[std_string]()
    for value in pyset:
        v = std_string(<char *> value)
        cppset.insert(v)
    return cppset

cdef set cpp_to_py_set_str(cpp_set[std_string] cppset):
    pyset = set()
    cdef cpp_set[std_string].iterator setiter = cppset.begin()
    while setiter != cppset.end():
        pyset.add(str(<char *> deref(setiter).c_str()))
        inc(setiter)
    return pyset


# <integer, integer> conversions
cdef cpp_map[int, int] dict_to_map_int_int(dict pydict):
    cdef cpp_map[int, int] cppmap = cpp_map[int, int]()
    for key, value in pydict.items():
        cppmap[key] = value
    return cppmap

cdef dict map_to_dict_int_int(cpp_map[int, int] cppmap):
    pydict = {}
    cdef cpp_map[int, int].iterator mapiter = cppmap.begin()
    while mapiter != cppmap.end():
        pydict[int(deref(mapiter).first)] = int(deref(mapiter).second)
        inc(mapiter)
    return pydict


# <integer, double> conversions
cdef cpp_map[int, double] dict_to_map_int_dbl(dict pydict):
    cdef cpp_map[int, double] cppmap = cpp_map[int, double]()
    for key, value in pydict.items():
        cppmap[key] = <double> value
    return cppmap

cdef dict map_to_dict_int_dbl(cpp_map[int, double] cppmap):
    pydict = {}
    cdef cpp_map[int, double].iterator mapiter = cppmap.begin()
    while mapiter != cppmap.end():
        pydict[int(deref(mapiter).first)] = float(deref(mapiter).second)
        inc(mapiter)
    return pydict


# <string, integer> conversions
cdef cpp_map[std_string, int] dict_to_map_str_int(dict pydict):
    cdef cpp_map[std_string, int] cppmap = cpp_map[std_string, int]()
    for key, value in pydict.items():
        cppmap[std_string(<char *> key)] = value
    return cppmap

cdef dict map_to_dict_str_int(cpp_map[std_string, int] cppmap):
    pydict = {}
    cdef cpp_map[std_string, int].iterator mapiter = cppmap.begin()
    while mapiter != cppmap.end():
        pydict[str(<char *> deref(mapiter).first.c_str())] = int(deref(mapiter).second)
        inc(mapiter)
    return pydict


# <integer, string> conversions
cdef cpp_map[int, std_string] dict_to_map_int_str(dict pydict):
    cdef cpp_map[int, std_string] cppmap = cpp_map[int, std_string]()
    for key, value in pydict.items():
        cppmap[key] = std_string(<char *> value)
    return cppmap

cdef dict map_to_dict_int_str(cpp_map[int, std_string] cppmap):
    pydict = {}
    cdef cpp_map[int, std_string].iterator mapiter = cppmap.begin()
    while mapiter != cppmap.end():
        pydict[int(deref(mapiter).first)] = str(<char *> deref(mapiter).second.c_str())
        inc(mapiter)
    return pydict


# <string, double> conversions
cdef cpp_map[std_string, double] dict_to_map_str_dbl(dict pydict):
    cdef cpp_map[std_string, double] cppmap = cpp_map[std_string, double]()
    for key, value in pydict.items():
        cppmap[std_string(<char *> key)] = <double> value
    return cppmap

cdef dict map_to_dict_str_dbl(cpp_map[std_string, double] cppmap):
    pydict = {}
    cdef cpp_map[std_string, double].iterator mapiter = cppmap.begin()
    while mapiter != cppmap.end():
        pydict[str(<char *> deref(mapiter).first.c_str())] = float(deref(mapiter).second)
        inc(mapiter)
    return pydict


# SetInt
cdef class SetIterInt(object):
    cdef void init(self, cpp_set[int] * set_ptr):
        cdef cpp_set[int].iterator * itn = <cpp_set[int].iterator *> malloc(sizeof(set_ptr.begin()))
        itn[0] = set_ptr.begin()
        self.iter_now = itn

        cdef cpp_set[int].iterator * ite = <cpp_set[int].iterator *> malloc(sizeof(set_ptr.end()))
        ite[0] = set_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_set[int].iterator inow = deref(self.iter_now)
        cdef cpp_set[int].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = int(deref(inow))
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval


cdef class _SetInt:
    def __cinit__(self, new_set=True, bint free_set=True):
        cdef int s

        # Decide how to init set, if at all
        if isinstance(new_set, _SetInt):
            self.set_ptr = (<_SetInt> new_set).set_ptr
        elif hasattr(new_set, '__iter__') or \
                (hasattr(new_set, '__len__') and
                hasattr(new_set, '__getitem__')):
            self.set_ptr = new cpp_set[int]()
            for value in new_set:
                s = value
                self.set_ptr.insert(s)
        elif bool(new_set):
            self.set_ptr = new cpp_set[int]()

        # Store free_set
        self._free_set = free_set

    def __dealloc__(self):
        if self._free_set:
            del self.set_ptr

    def __contains__(self, value):
        cdef int s
        if isinstance(value, int):
            s = value
        else:
            return False

        if 0 < self.set_ptr.count(s):
            return True
        else:
            return False

    def __len__(self):
        return self.set_ptr.size()

    def __iter__(self):
        cdef SetIterInt si = SetIterInt()
        si.init(self.set_ptr)
        return si

    def add(self, int value):
        cdef int v
        v = value
        self.set_ptr.insert(v)
        return

    def discard(self, value):
        cdef int v
        if value in self:
            v = value
            self.set_ptr.erase(v)
        return


class SetInt(_SetInt, collections.Set):
    """Wrapper class for C++ standard library sets of type <integer>.
    Provides set like interface on the Python level.

    Parameters
    ----------
    new_set : bool or set-like
        Boolean on whether to make a new set or not, or set-like object
        with values which are castable to the appropriate type.
    free_set : bool
        Flag for whether the pointer to the C++ set should be deallocated
        when the wrapper is dereferenced.

    """
    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "set([" + ", ".join([repr(i) for i in self]) + "])"



# SetStr
cdef class SetIterStr(object):
    cdef void init(self, cpp_set[std_string] * set_ptr):
        cdef cpp_set[std_string].iterator * itn = <cpp_set[std_string].iterator *> malloc(sizeof(set_ptr.begin()))
        itn[0] = set_ptr.begin()
        self.iter_now = itn

        cdef cpp_set[std_string].iterator * ite = <cpp_set[std_string].iterator *> malloc(sizeof(set_ptr.end()))
        ite[0] = set_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_set[std_string].iterator inow = deref(self.iter_now)
        cdef cpp_set[std_string].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = str(<char *> deref(inow).c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval


cdef class _SetStr:
    def __cinit__(self, new_set=True, bint free_set=True):
        cdef std_string s

        # Decide how to init set, if at all
        if isinstance(new_set, _SetStr):
            self.set_ptr = (<_SetStr> new_set).set_ptr
        elif hasattr(new_set, '__iter__') or \
                (hasattr(new_set, '__len__') and
                hasattr(new_set, '__getitem__')):
            self.set_ptr = new cpp_set[std_string]()
            for value in new_set:
                s = std_string(<char *> value)
                self.set_ptr.insert(s)
        elif bool(new_set):
            self.set_ptr = new cpp_set[std_string]()

        # Store free_set
        self._free_set = free_set

    def __dealloc__(self):
        if self._free_set:
            del self.set_ptr

    def __contains__(self, value):
        cdef std_string s
        if isinstance(value, basestring):
            s = std_string(<char *> value)
        else:
            return False

        if 0 < self.set_ptr.count(s):
            return True
        else:
            return False

    def __len__(self):
        return self.set_ptr.size()

    def __iter__(self):
        cdef SetIterStr si = SetIterStr()
        si.init(self.set_ptr)
        return si

    def add(self, char * value):
        cdef std_string v
        v = std_string(<char *> value)
        self.set_ptr.insert(v)
        return

    def discard(self, value):
        cdef std_string v
        if value in self:
            v = std_string(<char *> value)
            self.set_ptr.erase(v)
        return


class SetStr(_SetStr, collections.Set):
    """Wrapper class for C++ standard library sets of type <string>.
    Provides set like interface on the Python level.

    Parameters
    ----------
    new_set : bool or set-like
        Boolean on whether to make a new set or not, or set-like object
        with values which are castable to the appropriate type.
    free_set : bool
        Flag for whether the pointer to the C++ set should be deallocated
        when the wrapper is dereferenced.

    """
    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "set([" + ", ".join([repr(i) for i in self]) + "])"



# Map(Str, Str)
cdef class MapIterStrStr(object):
    cdef void init(self, cpp_map[std_string, std_string] * map_ptr):
        cdef cpp_map[std_string, std_string].iterator * itn = <cpp_map[std_string, std_string].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[std_string, std_string].iterator * ite = <cpp_map[std_string, std_string].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[std_string, std_string].iterator inow = deref(self.iter_now)
        cdef cpp_map[std_string, std_string].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = str(<char *> deref(inow).first.c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapStrStr:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[std_string, std_string] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapStrStr):
            self.map_ptr = (<_MapStrStr> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[std_string, std_string]()
            for key, value in new_map.items():
                item = pair[std_string, std_string](std_string(<char *> key), std_string(<char *> value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[std_string, std_string]()
            for key, value in new_map:
                item = pair[std_string, std_string](std_string(<char *> key), std_string(<char *> value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[std_string, std_string]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef std_string k
        if not isinstance(key, basestring):
            return False
        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterStrStr mi = MapIterStrStr()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef std_string k
        cdef std_string v

        if not isinstance(key, basestring):
            raise TypeError("Only string keys are valid.")
        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return str(<char *> v.c_str())
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[std_string, std_string] item = pair[std_string, std_string](std_string(<char *> key), std_string(<char *> value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef std_string k
        if key in self:
            k = std_string(<char *> key)
            self.map_ptr.erase(k)


class MapStrStr(_MapStrStr, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <string, string>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Str, Int)
cdef class MapIterStrInt(object):
    cdef void init(self, cpp_map[std_string, int] * map_ptr):
        cdef cpp_map[std_string, int].iterator * itn = <cpp_map[std_string, int].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[std_string, int].iterator * ite = <cpp_map[std_string, int].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[std_string, int].iterator inow = deref(self.iter_now)
        cdef cpp_map[std_string, int].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = str(<char *> deref(inow).first.c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapStrInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[std_string, int] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapStrInt):
            self.map_ptr = (<_MapStrInt> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[std_string, int]()
            for key, value in new_map.items():
                item = pair[std_string, int](std_string(<char *> key), value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[std_string, int]()
            for key, value in new_map:
                item = pair[std_string, int](std_string(<char *> key), value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[std_string, int]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef std_string k
        if not isinstance(key, basestring):
            return False
        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterStrInt mi = MapIterStrInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef std_string k
        cdef int v

        if not isinstance(key, basestring):
            raise TypeError("Only string keys are valid.")
        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return int(v)
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[std_string, int] item = pair[std_string, int](std_string(<char *> key), value)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef std_string k
        if key in self:
            k = std_string(<char *> key)
            self.map_ptr.erase(k)


class MapStrInt(_MapStrInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <string, integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Str)
cdef class MapIterIntStr(object):
    cdef void init(self, cpp_map[int, std_string] * map_ptr):
        cdef cpp_map[int, std_string].iterator * itn = <cpp_map[int, std_string].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, std_string].iterator * ite = <cpp_map[int, std_string].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, std_string].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, std_string].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntStr:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, std_string] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntStr):
            self.map_ptr = (<_MapIntStr> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, std_string]()
            for key, value in new_map.items():
                item = pair[int, std_string](key, std_string(<char *> value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, std_string]()
            for key, value in new_map:
                item = pair[int, std_string](key, std_string(<char *> value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, std_string]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k
        if not isinstance(key, int):
            return False
        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterIntStr mi = MapIterIntStr()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef std_string v

        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")
        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return str(<char *> v.c_str())
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[int, std_string] item = pair[int, std_string](key, std_string(<char *> value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k
        if key in self:
            k = key
            self.map_ptr.erase(k)


class MapIntStr(_MapIntStr, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, string>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Str, UInt)
cdef class MapIterStrUInt(object):
    cdef void init(self, cpp_map[std_string, extra_types.uint] * map_ptr):
        cdef cpp_map[std_string, extra_types.uint].iterator * itn = <cpp_map[std_string, extra_types.uint].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[std_string, extra_types.uint].iterator * ite = <cpp_map[std_string, extra_types.uint].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[std_string, extra_types.uint].iterator inow = deref(self.iter_now)
        cdef cpp_map[std_string, extra_types.uint].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = str(<char *> deref(inow).first.c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapStrUInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[std_string, extra_types.uint] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapStrUInt):
            self.map_ptr = (<_MapStrUInt> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[std_string, extra_types.uint]()
            for key, value in new_map.items():
                item = pair[std_string, extra_types.uint](std_string(<char *> key), <extra_types.uint> long(value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[std_string, extra_types.uint]()
            for key, value in new_map:
                item = pair[std_string, extra_types.uint](std_string(<char *> key), <extra_types.uint> long(value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[std_string, extra_types.uint]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef std_string k
        if not isinstance(key, basestring):
            return False
        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterStrUInt mi = MapIterStrUInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef std_string k
        cdef extra_types.uint v

        if not isinstance(key, basestring):
            raise TypeError("Only string keys are valid.")
        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return int(v)
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[std_string, extra_types.uint] item = pair[std_string, extra_types.uint](std_string(<char *> key), <extra_types.uint> long(value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef std_string k
        if key in self:
            k = std_string(<char *> key)
            self.map_ptr.erase(k)


class MapStrUInt(_MapStrUInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <string, unsigned integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(UInt, Str)
cdef class MapIterUIntStr(object):
    cdef void init(self, cpp_map[extra_types.uint, std_string] * map_ptr):
        cdef cpp_map[extra_types.uint, std_string].iterator * itn = <cpp_map[extra_types.uint, std_string].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[extra_types.uint, std_string].iterator * ite = <cpp_map[extra_types.uint, std_string].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[extra_types.uint, std_string].iterator inow = deref(self.iter_now)
        cdef cpp_map[extra_types.uint, std_string].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapUIntStr:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[extra_types.uint, std_string] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapUIntStr):
            self.map_ptr = (<_MapUIntStr> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[extra_types.uint, std_string]()
            for key, value in new_map.items():
                item = pair[extra_types.uint, std_string](<extra_types.uint> long(key), std_string(<char *> value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[extra_types.uint, std_string]()
            for key, value in new_map:
                item = pair[extra_types.uint, std_string](<extra_types.uint> long(key), std_string(<char *> value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[extra_types.uint, std_string]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef extra_types.uint k
        if not isinstance(key, int) and not isinstance(key, long):
            return False
        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterUIntStr mi = MapIterUIntStr()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef extra_types.uint k
        cdef std_string v

        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only unsigned integer keys are valid.")
        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return str(<char *> v.c_str())
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[extra_types.uint, std_string] item = pair[extra_types.uint, std_string](<extra_types.uint> long(key), std_string(<char *> value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef extra_types.uint k
        if key in self:
            k = <extra_types.uint> long(key)
            self.map_ptr.erase(k)


class MapUIntStr(_MapUIntStr, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <unsigned integer, string>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(UInt, UInt)
cdef class MapIterUIntUInt(object):
    cdef void init(self, cpp_map[extra_types.uint, extra_types.uint] * map_ptr):
        cdef cpp_map[extra_types.uint, extra_types.uint].iterator * itn = <cpp_map[extra_types.uint, extra_types.uint].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[extra_types.uint, extra_types.uint].iterator * ite = <cpp_map[extra_types.uint, extra_types.uint].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[extra_types.uint, extra_types.uint].iterator inow = deref(self.iter_now)
        cdef cpp_map[extra_types.uint, extra_types.uint].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapUIntUInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[extra_types.uint, extra_types.uint] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapUIntUInt):
            self.map_ptr = (<_MapUIntUInt> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[extra_types.uint, extra_types.uint]()
            for key, value in new_map.items():
                item = pair[extra_types.uint, extra_types.uint](<extra_types.uint> long(key), <extra_types.uint> long(value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[extra_types.uint, extra_types.uint]()
            for key, value in new_map:
                item = pair[extra_types.uint, extra_types.uint](<extra_types.uint> long(key), <extra_types.uint> long(value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[extra_types.uint, extra_types.uint]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef extra_types.uint k
        if not isinstance(key, int) and not isinstance(key, long):
            return False
        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterUIntUInt mi = MapIterUIntUInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef extra_types.uint k
        cdef extra_types.uint v

        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only unsigned integer keys are valid.")
        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return int(v)
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[extra_types.uint, extra_types.uint] item = pair[extra_types.uint, extra_types.uint](<extra_types.uint> long(key), <extra_types.uint> long(value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef extra_types.uint k
        if key in self:
            k = <extra_types.uint> long(key)
            self.map_ptr.erase(k)


class MapUIntUInt(_MapUIntUInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <unsigned integer, unsigned integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Str, Double)
cdef class MapIterStrDouble(object):
    cdef void init(self, cpp_map[std_string, double] * map_ptr):
        cdef cpp_map[std_string, double].iterator * itn = <cpp_map[std_string, double].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[std_string, double].iterator * ite = <cpp_map[std_string, double].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[std_string, double].iterator inow = deref(self.iter_now)
        cdef cpp_map[std_string, double].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = str(<char *> deref(inow).first.c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapStrDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[std_string, double] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapStrDouble):
            self.map_ptr = (<_MapStrDouble> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[std_string, double]()
            for key, value in new_map.items():
                item = pair[std_string, double](std_string(<char *> key), <double> value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[std_string, double]()
            for key, value in new_map:
                item = pair[std_string, double](std_string(<char *> key), <double> value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[std_string, double]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef std_string k
        if not isinstance(key, basestring):
            return False
        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterStrDouble mi = MapIterStrDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef std_string k
        cdef double v

        if not isinstance(key, basestring):
            raise TypeError("Only string keys are valid.")
        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return float(v)
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[std_string, double] item = pair[std_string, double](std_string(<char *> key), <double> value)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef std_string k
        if key in self:
            k = std_string(<char *> key)
            self.map_ptr.erase(k)


class MapStrDouble(_MapStrDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <string, double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Int)
cdef class MapIterIntInt(object):
    cdef void init(self, cpp_map[int, int] * map_ptr):
        cdef cpp_map[int, int].iterator * itn = <cpp_map[int, int].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, int].iterator * ite = <cpp_map[int, int].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, int].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, int].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, int] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntInt):
            self.map_ptr = (<_MapIntInt> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, int]()
            for key, value in new_map.items():
                item = pair[int, int](key, value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, int]()
            for key, value in new_map:
                item = pair[int, int](key, value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, int]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k
        if not isinstance(key, int):
            return False
        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterIntInt mi = MapIterIntInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef int v

        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")
        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return int(v)
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[int, int] item = pair[int, int](key, value)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k
        if key in self:
            k = key
            self.map_ptr.erase(k)


class MapIntInt(_MapIntInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Double)
cdef class MapIterIntDouble(object):
    cdef void init(self, cpp_map[int, double] * map_ptr):
        cdef cpp_map[int, double].iterator * itn = <cpp_map[int, double].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, double].iterator * ite = <cpp_map[int, double].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, double].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, double].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, double] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntDouble):
            self.map_ptr = (<_MapIntDouble> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, double]()
            for key, value in new_map.items():
                item = pair[int, double](key, <double> value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, double]()
            for key, value in new_map:
                item = pair[int, double](key, <double> value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, double]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k
        if not isinstance(key, int):
            return False
        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterIntDouble mi = MapIterIntDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef double v

        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")
        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return float(v)
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[int, double] item = pair[int, double](key, <double> value)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k
        if key in self:
            k = key
            self.map_ptr.erase(k)


class MapIntDouble(_MapIntDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Complex)
cdef class MapIterIntComplex(object):
    cdef void init(self, cpp_map[int, extra_types.complex_t] * map_ptr):
        cdef cpp_map[int, extra_types.complex_t].iterator * itn = <cpp_map[int, extra_types.complex_t].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, extra_types.complex_t].iterator * ite = <cpp_map[int, extra_types.complex_t].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, extra_types.complex_t].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, extra_types.complex_t].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntComplex:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, extra_types.complex_t] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntComplex):
            self.map_ptr = (<_MapIntComplex> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, extra_types.complex_t]()
            for key, value in new_map.items():
                item = pair[int, extra_types.complex_t](key, py2c_complex(value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, extra_types.complex_t]()
            for key, value in new_map:
                item = pair[int, extra_types.complex_t](key, py2c_complex(value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, extra_types.complex_t]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k
        if not isinstance(key, int):
            return False
        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterIntComplex mi = MapIterIntComplex()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef extra_types.complex_t v

        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")
        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return complex(float(v.re), float(v.im))
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[int, extra_types.complex_t] item = pair[int, extra_types.complex_t](key, py2c_complex(value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k
        if key in self:
            k = key
            self.map_ptr.erase(k)


class MapIntComplex(_MapIntComplex, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, complex>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, VectorDouble)
cdef class MapIterIntVectorDouble(object):
    cdef void init(self, cpp_map[int, cpp_vector[double]] * map_ptr):
        cdef cpp_map[int, cpp_vector[double]].iterator * itn = <cpp_map[int, cpp_vector[double]].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, cpp_vector[double]].iterator * ite = <cpp_map[int, cpp_vector[double]].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, cpp_vector[double]].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, cpp_vector[double]].iterator iend = deref(self.iter_end)

        if inow != iend:
            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntVectorDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, cpp_vector[double]] item

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntVectorDouble):
            self.map_ptr = (<_MapIntVectorDouble> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, cpp_vector[double]]()
            for key, value in new_map.items():
                item = pair[int, cpp_vector[double]](key, py2c_vector_dbl(value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, cpp_vector[double]]()
            for key, value in new_map:
                item = pair[int, cpp_vector[double]](key, py2c_vector_dbl(value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, cpp_vector[double]]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k
        if not isinstance(key, int):
            return False
        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef MapIterIntVectorDouble mi = MapIterIntVectorDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef cpp_vector[double] v

        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")
        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            return c2py_vector_dbl(&v)
        else:
            raise KeyError

    def __setitem__(self, key, value):
        cdef pair[int, cpp_vector[double]] item = pair[int, cpp_vector[double]](key, py2c_vector_dbl(value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k
        if key in self:
            k = key
            self.map_ptr.erase(k)


class MapIntVectorDouble(_MapIntVectorDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, vector [ndarray] of doubles>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



