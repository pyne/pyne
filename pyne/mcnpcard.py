#!/usr/bin/env python

"""This module contains a Card class for each MCNP card. The user is not
expected to interact with this module; it is loaded by pyne.mcnp and used by
pyne.mcnp.Inp.

"""

import numpy as np

class Card(object):
    """Superclass for all MCNP cards. The methods that all cards have is a
    comment() method that describes the input in human-readable text and a
    card() method that prints the proper card to the input file. Some of the
    subclasses are Cell, Surface, and Material. Surface has plenty of its own
    sublcasses.

    The user is not expected to interact with objects of this class. All
    objects are expected to be instantiated by the mcnp.Inp class; the user
    creates Card objects through methods in mcnp.Inp.

    Having this class inherit from object makes this a new-style class, so that
    the super() builtin method can be used.

    """
    # The column at which to start in-line comments (card descriptions).
    dollarcol = 55
    # Conversion from Kelvin to "kT" temperatures in units of eV.
    kelvin2energy = 8.6173423e-11


    def __init__(self, card_no, name):
        """No objects of this superclass should exist.

        Parameters
        ----------
        name : str
            Each card has a human-readable name assigned by the user by
            pyne.mcnp.Inp's interpretation of the user's input.
        card_no : int
            Most cards have a number that starts the card.

        """
        self.name = name
        self.card_no = card_no
    
    def get_density_prefix(self, density_units):
        """In MCNPX, mass densities are represented by prepending a minus sign.
        This converts this notation in something sensible as far as user input
        goes.

        Parameters
        ----------
        density_units : str
            Must be either 'g/cm^3' or 'atoms/b/cm'.

        Returns
        -------
        prefix : str
            Returns a minus sign for mass densities and an empty string for
            number densities.

        """
        if density_units == 'g/cm^3':
            return '-'
        elif density_units == 'atoms/b/cm':
            return ''
        else:
            raise Exception("Invalid string to specify density units: "
                    + density_units)

    def comment(self):
        """ "Virtual". 

        Returns
        -------
        comment : str
            A comment string is generated by the Card object and is usually
            printed on the same line as the card after the $ comment symbol.
        TODO make sure this is working properly

        """
        #raise Exception("Tried to run the virtual method Card.comment()")
        return self.name

    def card(self):
        """virtual. returns string
        TODO take advantage of leading zeros syntax %5f etc

        """
        raise Exception("Tried to run the virtual method Card.card()")


class Cell(Card):
    """Cell cards represent discrete physical regions in space containing a
    single material and bounded by any number of surfaces. The card
    requires material and surface numbers.

    TODO none of the logic for universes and lattices is implemented. I find
    this task to the be the most difficult input parsing task.
    TODO only the IMP, TMP, and VOL keywords are allowed.

    """
    def __init__(self, card_no, name, material, density, density_units,
            neg_surfs, pos_surfs, imp, temp, vol):
        super(Cell, self).__init__(card_no, name)
        self.material = material
        self.density = density
        self.dens_prefix = self.get_density_prefix(density_units)
        self.neg_surfs = neg_surfs
        self.pos_surfs = pos_surfs
        self.imp = imp
        self.temp = temp
        self.vol = vol

    def card(self):
        # TODO No hardcoded numbers like 35
        string2write = str(self.card_no)
        string2write += (" " * (4 - len(string2write)) +
                str(self.material.card_no))
        string2write += (" " * (8 - len(string2write + self.dens_prefix)) + 
                self.dens_prefix + "%.4e" % self.density)
        string2write += (" " * (18 - len(string2write)))
        for surface in self.pos_surfs:
            string2write += "  {0}".format(surface.card_no)
        for surface in self.neg_surfs:
            string2write += " -{0}".format(surface.card_no)
        string2write += (" " * (25 - len(string2write)) + 
                "IMP:N={0}".format(self.imp))
        if self.temp is not None:
            string2write += " TMP=%.4e" % (self.temp * Card.kelvin2energy)
        if self.vol is not None:
            string2write += " VOL=%.4e" % self.vol
        return (string2write + " " * (Card.dollarcol - len(string2write)) + 
                "$ " + self.comment())


class CellVoid(Card):
    """Creates a cell that is a void or vacuum (i.e. no associated material card).

    """
    def __init__(self, card_no, name, neg_surfs, pos_surfs, imp):
        """Constructor.

        Parameters
        ----------
        card_no : int
            Provided by the cell card counter in mcnp.Inp.
        name : str
            The user's human-readable name for this card.
        neg_surfs : list
            The surface card numbers for which this cell is located in the
            negative sense.
        pos_surfs : list
            Surfaces that have a positive sense for this cell.
        imp : int
            Neutron importance. TODO should allow any particle importance.

        """
        super(CellVoid, self).__init__(card_no, name)
        self.neg_surfs = neg_surfs
        self.pos_surfs = pos_surfs
        self.imp = imp

    def card(self):
        string2write = str(self.card_no)
        string2write += (" " * (4 - len(string2write)) + "0")
        string2write += (" " * (18 - len(string2write)))
        for surface in self.pos_surfs:
            string2write += "  {0}".format(surface.card_no)
        for surface in self.neg_surfs:
            string2write += " -{0}".format(surface.card_no)
        string2write += (" " * (25 - len(string2write)) + 
                "IMP:N={0}".format(self.imp))
        return (string2write + " " * (Card.dollarcol - len(string2write)) + 
                "$ " + self.comment())


class Surface(Card):
    """A surface can be one of many types; see subclasses. This class only
    contains one method: the printing of the card number.

    """
    # TODO placement of comment should be more intelligent.
    dollarcol = 30

    def __init__(self, card_no, name, reflecting, white):
        """Constructor.

        Parameters
        ----------
        card_no : int
            Card number.
        name : str
            Human-readable name given by user.
        reflecting : bool, optional
            Places an asterisk before the card number if the surface is
            reflecting.
        white : bool, optional
            Places an addition symbol before the card number if the surface
            gives white reflection. TODO cosine distribution?

        """
        super(Surface, self).__init__(card_no, name)
        self.reflecting = reflecting
        self.white = white
    def card_no_string(self):
        if not self.reflecting and not self.white:
            return "%i" % self.card_no
        elif self.reflecting and not self.white:
            return "*%i" % self.card_no
        elif self.white and not self.reflecting:
            return "+%i" % self.card_no
        else:
            raise Exception("The surface is set as reflecting and white. The "
                    "surface can be neither or either, but not both.")


class Cylinder(Surface):
    """An axis-aligned and axis-centered cylinder (C*). MCNPX also allows for more
    general cylinders.

    """
    def __init__(self, card_no, name, dirstr, radius,
                 reflecting=False, white=False):
        """Constructor.

        Parameters
        ----------
        card_no : int
            Card number.
        name : str
            Human-readable name given by user.
        dirstr : str
            The axis with which the cylinder is aligned. Lower or uppercase
            'x', 'y', or 'z'.
        radius : float
            Radius of the cylinder.
            Units of centimeters.
        reflecting : bool, optional
            Places an asterisk before the card number if the surface is
            reflecting.
        white : bool, optional
            Places an addition symbol before the card number if the surface
            gives white reflection. TODO cosine distribution?

        """
        super(Cylinder, self).__init__(card_no, name, reflecting, white)
        self.radius = radius
        assert(dirstr.upper() == 'X' or 
               dirstr.upper() == 'Y' or
               dirstr.upper() == 'Z')
        self.dirstr = dirstr

    def comment(self):
        return "Infinite cylinder along {0} axis, radius " \
                "{1} cm".format(self.dirstr, self.radius)

    def card(self):
        string2write = self.card_no_string()
        string2write += (" " * (4 - len(string2write)) + "C" +
                self.dirstr.upper() + "  " + "%.4f" % self.radius)
        return (string2write + " " * (Surface.dollarcol - len(string2write)) +
                "$ " + self.comment())


class Plane(Surface):
    """An axis-aligned plane (P*).
    
    """
    def __init__(self, card_no, name, dirstr, pos,
                 reflecting=False, white=False):
        """Constructor.

        Parameters
        ----------
        card_no : int
            Card number.
        name : str
            Human-readable name given by user.
        dirstr : str
            The axis with which the plane is parallel. Lower or uppercase
            'x', 'y', or 'z'.
        pos : float
            Distance from the axis with which the plane is aligned.
            Units of centimeters.
        reflecting : bool, optional
            Places an asterisk before the card number if the surface is
            reflecting.
        white : bool, optional
            Places an addition symbol before the card number if the surface
            gives white reflection. TODO cosine distribution?

        """
        super(Plane, self).__init__(card_no, name, reflecting, white)
        self.pos = pos
        self.dirstr = dirstr

    def comment(self):
        return "Plane normal to {0} axis, at {0} = " \
                "{1} cm".format(self.dirstr, self.pos)

    def card(self):
        nspaces = 1
        if self.pos >= 0:
            nspaces += 1
        string2write = self.card_no_string()
        string2write += (" " * (4 - len(string2write)) + "P" +
                self.dirstr.upper() + " " * nspaces + "%.4f" % self.pos)
        return (string2write + " " * (Surface.dollarcol - len(string2write)) +
                "$ " + self.comment())


class Sphere(Surface):
    """A sphere (SO). Or horse; whatever. TODO 
    
    """
    def __init__(self, card_no, name, radius, center=False,
                 reflecting=False, white=False):
        """Constructor.

        Parameters
        ----------
        card_no : int
            Card number.
        name : str
            Human-readable name given by user.
        dirstr : str
            The axis with which the plane is parallel. Lower or uppercase
            'x', 'y', or 'z'.
        radius : float
            Radius of the sphere.
            Units of centimeters.
        center : None or list float
            If None, circle is centered at the origin. Otherwise, it is at the
            location specified this list, as [x y z].
        reflecting : bool, optional
            Places an asterisk before the card number if the surface is
            reflecting.
        white : bool, optional
            Places an addition symbol before the card number if the surface
            gives white reflection. TODO cosine distribution?

        TODO only the origin sphere is implemented.

        """
        super(Sphere, self).__init__(card_no, name, reflecting, white)
        self.radius = radius
        self.center = center

    def comment(self):
        if self.center is not False:
            return "Sphere of radius {0} cm centered at " \
                    "({1},{2},{3}) cm".format(self.radius, self.center[0],
                            self.center[1], self.center[2])
        else:
            return "Sphere of radius {0} cm centered at " \
                    "origin".format(self.radius)

    def card(self):
        nspaces = 1
        string2write = self.card_no_string()
        if self.center is not False:
            raise Exception("unimplemented.")
        else:
            string2write += (" " * (4 - len(string2write)) + "SO" +
                    " %.4f" % self.radius)
        return (string2write + " " * (Surface.dollarcol - len(string2write)) +
                "$ " + self.comment())


class RectangularParallelepiped(Surface):
    """Rectangular parallelepiped (RPP). As can be done with direct MCNPX input, set
    both values for a given dimension to zero to make the surface infinite in
    that dirction.

    """
    def __init__(self, card_no, name, xmin, xmax, ymin, ymax, zmin, zmax,
                 reflecting=False, white=False):
        """Constructor.

        Parameters
        ----------
        card_no : int
            Card number.
        name : str
            Human-readable name given by user.
        xmin, xmax, ymin, ymax, zmin, zmax : float
            Bound of the parallelepiped in the given direction.
        reflecting : bool, optional
            Places an asterisk before the card number if the surface is
            reflecting.
        white : bool, optional
            Places an addition symbol before the card number if the surface
            gives white reflection. TODO cosine distribution?
            
        TODO Get rid of the 0 for infinite notation; it makes sense because 0
        for both values doesn't make sense, but it's not intuitive.

        """
        super(RectangularParallelepiped, self).__init__(
                card_no, name, reflecting, white)
        self.xmin = xmin
        self.xmax = xmax
        self.ymin = ymin
        self.ymax = ymax
        self.zmin = zmin
        self.zmax = zmax

    def comment(self):
        return "Rectangular parallelepiped: [{0}, {1}] x [{2}, {3}] x " \
               "[{4}, {5}] cm".format(self.xmin, self.xmax, self.ymin, self.ymax,
                       self.zmin, self.zmax)

    def card(self):
        string2write = self.card_no_string()
        string2write += (" " * (4 - len(string2write)) + "RPP" +
                " %.4f %.4f %.4f %.4f %.4f %.4f" % (
                        self.xmin, self.xmax, self.ymin, self.ymax,
                        self.zmin, self.zmax))
        dollarcol = max(Surface.dollarcol - len(string2write), 2)
        return (string2write + " " * dollarcol +
                "$ " + self.comment())


class Material(Card):
    """A material card (M).
    
    """

    def __init__(self, card_no, name, comment, ZAIDs, density_units, densities,
            temp=None):
        """Constructor.

        Parameters
        ----------
        card_no : int
            Card number.
        name : str
            Short human-readable name given by user (e.g. "UO2").
        comment : str
            User-provided description of the material (e.g. "My grandfather
            worked hard to make this mineral.").
        ZAIDs : list, int
            The nuclides that make up the material.
        density_units : str
            Either 'atoms/b/cm' or 'g/cm^3'
            TODO descriptive is more important than short
        densities : list, float
            Density or atom/weight fraction of the nuclides, given in the same
            order as the ZAIDs.
        temp : float
            Temperature of the material. This is relevant for Doppler
            broadening.

        TODO the user should, instead of providing ZAIDs, have the option of
        building these materials from the pyne.materials class.
        TODO management of library tables needs to be done in a clear way.

        """
        # TODO temp management is really messy.
        if type(ZAIDs) == int:
            raise Exception("ZAIDs input must be a list.")
        if type(densities) == int or type(densities) == float:
            raise Exception("densities input must be a list.")
        if len(ZAIDs) != len(densities):
            raise Exception("Number of ZAIDs does not match number of " \
            "densities.")
        super(Material, self).__init__(card_no, name)
        self.comment_tuple = comment
        if check_ZAIDs(ZAIDs):
            self.ZAIDs = ZAIDs
        else:
            raise Exception("Error in ZAID input.")
        if len(ZAIDs) == 1:
            self.dens_prefix = ''
        else:
            self.dens_prefix = self.get_density_prefix(density_units)
        if check_densities(densities):
            self.densities = densities
        else:
            raise Exception("Error in density input.")
        self.temp = temp

    def check_ZAIDs(self, ZAIDs):
        # TODO error check, make sure they are ZAIDs
        pass

    def check_densities(self, densities):
        # TODO error check densities
        pass

    def comment(self):
        return self.comment_tuple

    def card(self):
        nspaces = 15
        string2write = "M" + str(self.card_no)
        string2write += " " * (nspaces - len(string2write) -
                len(str(self.ZAIDs[0])))
        string2write += "%s" % self.ZAIDs[0]
        if self.temp is not None:
            string2write += self._table_id(self.temp)
        string2write += " " * (1 + int(self.dens_prefix != '-'))
        string2write += "%e\n" % self.densities[0]
        if len(self.ZAIDs) > 1:
            for i in range(1, len(self.ZAIDs)):
                string2write += " " * (nspaces - len(str(self.ZAIDs[i])))
                string2write += "%s" % self.ZAIDs[i]
                if self.temp is not None:
                    string2write += self._table_id(self.temp)
                string2write += " " * (1 + int(self.dens_prefix != '-'))
                string2write += "%e\n" % self.densities[i]
        return string2write

    def _table_id(self, temp, lwtr=False):
        """ TODO is NOT general!

        """
        temps = np.array([293.6, 600, 900, 1200, 2500])
        table_ids = ['.70c', '.71c', '.72c', '.73c', '.74c']
        indices = np.nonzero(temps > temp)[0]
        if len(indices) == 0:
            return table_ids[-1]
        else:
            return table_ids[max(0, indices[0] - 1)]


class ScatteringLaw(Card):
    """Scattering Law card (MT).
    
    """

    def __init__(self, material_no, libraries, temp=None):
        """Constructor.

        Parameters
        ----------
        material_no : int
            The material card number for which the scattering law should be
            applied.
        libraries : list, str
            The scattering law library name, such as 'lwtr'. See MCNPX manual.
            More than may be specified, but if only one is specified it must
            still be specified as a length-1 list.
        temp : float
            If a specific table is desired, specify the temperature for Doppler
            broadening and the proper table is selected.

        """
        super(ScatteringLaw, self).__init__(material_no, "MT")
        if type(libraries) is not list:
            raise Exception("Libriares are not provided as a list, and they "
                    "must be provided as a list.")
        self.libraries = libraries
        self.temp = temp

    def card(self):
        string2write = "MT{0}".format(self.card_no)
        for library in self.libraries:
            string2write += " " + library
            if self.temp is not None:
                string2write += self._table_id(self.temp, library)
        return string2write

    def _table_id(self, temp, library):
        """ TODO is NOT general!

        """
        if library == "lwtr":
            temps = np.array([293.6, 350, 400, 450, 500, 550, 600, 650, 800])
            table_ids = ['.10t', '.11t', '.12t', '.13t', '.14t', '.15t',
                         '.16t', '.17t', '.18t']
        else:
            raise Exception("TODO")
        indices = np.nonzero(temps > temp)[0]
        if len(indices) == 0:
            return table_ids[-1]
        else:
            return table_ids[max(0, indices[0] - 1)]

class Tally(Card):
    """Tally card superclass.

    """

    def __init__(self, card_no, name, particle):
        """Constructor.

        Parameters
        ----------

        """
        super(Tally, self).__init__(card_no, name)
        self.particle = particle

    def card(self):
        pass


class TallyCellFlux(Tally):
    """Cell flux tally card (F4).
    
    """

    def __init__(self, card_no, name, particle, cell_nos):
        """Constructor.

        Parameters
        ----------

        """
        super(TallyCellFlux, self).__init__(card_no, name, particle)
        self.cell_nos = cell_nos

    def card(self):
        string2write = "F%i:%s" % (self.card_no, self.particle)
        for cell_no in self.cell_nos:
            string2write += " " + str(cell_no)
        return string2write


class Source(Card):
    """Source card superclass.
    
    """
    def __init__(self, name):
        """Constructor.

        Parameters
        ----------

        """
        super(Source, self).__init__(None, name)

    def card(self):
        pass


class Criticality(Source):
    """Criticality source card (KCODE).
    
    """

    def __init__(self, n_histories, keff_guess, n_skip_cycles, n_cycles):
        """Constructor.

        Parameters
        ----------

        """
        # TODO this is not exactly the same as what MCNPX uses by default. I
        # also left out 5 other options for this card.
        super(Criticality, self).__init__("KCODE")
        self.n_histories = n_histories
        self.keff_guess = keff_guess
        self.n_skip_cycles = n_skip_cycles
        self.n_cycles = n_cycles

    def card(self):
        string2write = "KCODE  {0}  {1}  {2}  {3}".format(self.n_histories,
                self.keff_guess, self.n_skip_cycles, self.n_cycles)
        return string2write


class CriticalitySourcePoints(Source):
    """Criticality source points card (KSRC).
    
    """

    def __init__(self, points):
        """Constructor.

        Parameters
        ----------

        """
        super(CriticalitySourcePoints, self).__init__("KSRC")
        self.points = points

    def card(self):
        string2write = "KSRC"
        for point in self.points:
            string2write += "  {0} {1} {2}".format(point[0], point[1],
                    point[2])
        return string2write


class TallyEnergy(Card):
    """Tally energy card (E*).
    
    """
    def __init__(self, tally_no, energies):
        """Constructor.

        Parameters
        ----------

        """
        super(TallyEnergy, self).__init__(tally_no, "En")
        self.energies = energies

    def card(self):
        string2write = "E{0} ".format(self.card_no)
        for energy in self.energies:
            string2write += "  %.5e" % energy
        return string2write


class TallyMultiplier(Card):
    """Tally multiplier card (FM*).
    
    """

    def __init__(self, tally_no, multsets):
        """Constructor.

        Parameters
        ----------

        """
        super(TallyMultiplier, self).__init__(tally_no, "FMn")
        self.multsets = multsets

    def card(self):
        string2write = "FM%i  " % self.card_no
        first_line = True
        for multset in self.multsets:
            # return after each set
            if first_line:
                next_line = ""
                first_line = False
            else:
                next_line = "\n" + 5 * " "
            if len(multset) == 1:
                if type(multset[0]) is int:
                    string2write += next_line + "(%i)" % multset[0]
                elif type(multset[0]) is float:
                    string2write += next_line + "(%.4f)" % multset[0]
                else:
                    raise Exception("TODO")
            elif len(multset) == 3:
                # TODO clean up duplicate code.
                if type(multset[0]) is int:
                    string2write += next_line + "(%i %i" % (multset[0], multset[1])
                elif type(multset[0]) is float:
                    string2write += next_line + "(%.4f %i" % (multset[0], multset[1])
                for mt in multset[2]:
                    string2write += " (%i)" % mt
                string2write += ")"
            else:
                raise Exception("TODO")
        return string2write


class PrintDump(Card):
    """Print dump card (PRDMP).
    
    """
    def __init__(self):
        """Constructor.

        Parameters
        ----------

        """
        pass

    def card(self):
        return "PRDMP 0 0 1"




