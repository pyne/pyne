###################
###  WARNING!!! ###
###################
# This file has been autogenerated

# Cython imports
from libcpp.set cimport set as cpp_set
from libcpp.vector cimport vector as cpp_vector
from cython.operator cimport dereference as deref
from cython.operator cimport preincrement as inc
from libc.stdlib cimport malloc, free
from libcpp.string cimport string as std_string
from libcpp.utility cimport pair
from libcpp.map cimport map as cpp_map
from libcpp.vector cimport vector as cpp_vector

# Python Imports
import collections

cimport numpy as np
import numpy as np

np.import_array()

cimport extra_types

# SetStr
cdef class _SetIterStr(object):
    cdef void init(self, cpp_set[std_string] * set_ptr):
        cdef cpp_set[std_string].iterator * itn = <cpp_set[std_string].iterator *> malloc(sizeof(set_ptr.begin()))
        itn[0] = set_ptr.begin()
        self.iter_now = itn

        cdef cpp_set[std_string].iterator * ite = <cpp_set[std_string].iterator *> malloc(sizeof(set_ptr.end()))
        ite[0] = set_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_set[std_string].iterator inow = deref(self.iter_now)
        cdef cpp_set[std_string].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = str(<char *> deref(inow).c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval


cdef class _SetStr:
    def __cinit__(self, new_set=True, bint free_set=True):
        cdef std_string s


        # Decide how to init set, if at all
        if isinstance(new_set, _SetStr):
            self.set_ptr = (<_SetStr> new_set).set_ptr
        elif hasattr(new_set, '__iter__') or \
                (hasattr(new_set, '__len__') and
                hasattr(new_set, '__getitem__')):
            self.set_ptr = new cpp_set[std_string]()
            for value in new_set:

                s = std_string(<char *> value)
                self.set_ptr.insert(s)
        elif bool(new_set):
            self.set_ptr = new cpp_set[std_string]()

        # Store free_set
        self._free_set = free_set

    def __dealloc__(self):
        if self._free_set:
            del self.set_ptr

    def __contains__(self, value):
        cdef std_string s

        if isinstance(value, basestring):

            s = std_string(<char *> value)
        else:
            return False

        if 0 < self.set_ptr.count(s):
            return True
        else:
            return False

    def __len__(self):
        return self.set_ptr.size()

    def __iter__(self):
        cdef _SetIterStr si = _SetIterStr()
        si.init(self.set_ptr)
        return si

    def add(self, char * value):
        cdef std_string v


        v = std_string(<char *> value)
        self.set_ptr.insert(v)
        return

    def discard(self, value):
        cdef std_string v

        if value in self:

            v = std_string(<char *> value)
            self.set_ptr.erase(v)
        return


class SetStr(_SetStr, collections.Set):
    """Wrapper class for C++ standard library sets of type <string>.
    Provides set like interface on the Python level.

    Parameters
    ----------
    new_set : bool or set-like
        Boolean on whether to make a new set or not, or set-like object
        with values which are castable to the appropriate type.
    free_set : bool
        Flag for whether the pointer to the C++ set should be deallocated
        when the wrapper is dereferenced.

    """
    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "set([" + ", ".join([repr(i) for i in self]) + "])"



# SetInt
cdef class _SetIterInt(object):
    cdef void init(self, cpp_set[int] * set_ptr):
        cdef cpp_set[int].iterator * itn = <cpp_set[int].iterator *> malloc(sizeof(set_ptr.begin()))
        itn[0] = set_ptr.begin()
        self.iter_now = itn

        cdef cpp_set[int].iterator * ite = <cpp_set[int].iterator *> malloc(sizeof(set_ptr.end()))
        ite[0] = set_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_set[int].iterator inow = deref(self.iter_now)
        cdef cpp_set[int].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow))
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval


cdef class _SetInt:
    def __cinit__(self, new_set=True, bint free_set=True):
        cdef int s


        # Decide how to init set, if at all
        if isinstance(new_set, _SetInt):
            self.set_ptr = (<_SetInt> new_set).set_ptr
        elif hasattr(new_set, '__iter__') or \
                (hasattr(new_set, '__len__') and
                hasattr(new_set, '__getitem__')):
            self.set_ptr = new cpp_set[int]()
            for value in new_set:

                s = value
                self.set_ptr.insert(s)
        elif bool(new_set):
            self.set_ptr = new cpp_set[int]()

        # Store free_set
        self._free_set = free_set

    def __dealloc__(self):
        if self._free_set:
            del self.set_ptr

    def __contains__(self, value):
        cdef int s

        if isinstance(value, int) or isinstance(value, long):

            s = value
        else:
            return False

        if 0 < self.set_ptr.count(s):
            return True
        else:
            return False

    def __len__(self):
        return self.set_ptr.size()

    def __iter__(self):
        cdef _SetIterInt si = _SetIterInt()
        si.init(self.set_ptr)
        return si

    def add(self, int value):
        cdef int v


        v = value
        self.set_ptr.insert(v)
        return

    def discard(self, value):
        cdef int v

        if value in self:

            v = value
            self.set_ptr.erase(v)
        return


class SetInt(_SetInt, collections.Set):
    """Wrapper class for C++ standard library sets of type <integer>.
    Provides set like interface on the Python level.

    Parameters
    ----------
    new_set : bool or set-like
        Boolean on whether to make a new set or not, or set-like object
        with values which are castable to the appropriate type.
    free_set : bool
        Flag for whether the pointer to the C++ set should be deallocated
        when the wrapper is dereferenced.

    """
    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "set([" + ", ".join([repr(i) for i in self]) + "])"



# Map(Str, Str)
cdef class _MapIterStrStr(object):
    cdef void init(self, cpp_map[std_string, std_string] * map_ptr):
        cdef cpp_map[std_string, std_string].iterator * itn = <cpp_map[std_string, std_string].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[std_string, std_string].iterator * ite = <cpp_map[std_string, std_string].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[std_string, std_string].iterator inow = deref(self.iter_now)
        cdef cpp_map[std_string, std_string].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = str(<char *> deref(inow).first.c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapStrStr:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[std_string, std_string] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapStrStr):
            self.map_ptr = (<_MapStrStr> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[std_string, std_string]()
            for key, value in new_map.items():


                item = pair[std_string, std_string](std_string(<char *> key), std_string(<char *> value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[std_string, std_string]()
            for key, value in new_map:


                item = pair[std_string, std_string](std_string(<char *> key), std_string(<char *> value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[std_string, std_string]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef std_string k

        if not isinstance(key, basestring):
            return False

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterStrStr mi = _MapIterStrStr()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef std_string k
        cdef std_string v


        if not isinstance(key, basestring):
            raise TypeError("Only string keys are valid.")

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return str(<char *> deref(self.map_ptr)[k].c_str())
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[std_string, std_string] item


        item = pair[std_string, std_string](std_string(<char *> key), std_string(<char *> value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef std_string k

        if key in self:

            k = std_string(<char *> key)
            self.map_ptr.erase(k)


class MapStrStr(_MapStrStr, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <string, string>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Str, Int)
cdef class _MapIterStrInt(object):
    cdef void init(self, cpp_map[std_string, int] * map_ptr):
        cdef cpp_map[std_string, int].iterator * itn = <cpp_map[std_string, int].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[std_string, int].iterator * ite = <cpp_map[std_string, int].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[std_string, int].iterator inow = deref(self.iter_now)
        cdef cpp_map[std_string, int].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = str(<char *> deref(inow).first.c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapStrInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[std_string, int] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapStrInt):
            self.map_ptr = (<_MapStrInt> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[std_string, int]()
            for key, value in new_map.items():


                item = pair[std_string, int](std_string(<char *> key), value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[std_string, int]()
            for key, value in new_map:


                item = pair[std_string, int](std_string(<char *> key), value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[std_string, int]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef std_string k

        if not isinstance(key, basestring):
            return False

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterStrInt mi = _MapIterStrInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef std_string k
        cdef int v


        if not isinstance(key, basestring):
            raise TypeError("Only string keys are valid.")

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return int(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[std_string, int] item


        item = pair[std_string, int](std_string(<char *> key), value)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef std_string k

        if key in self:

            k = std_string(<char *> key)
            self.map_ptr.erase(k)


class MapStrInt(_MapStrInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <string, integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Str)
cdef class _MapIterIntStr(object):
    cdef void init(self, cpp_map[int, std_string] * map_ptr):
        cdef cpp_map[int, std_string].iterator * itn = <cpp_map[int, std_string].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, std_string].iterator * ite = <cpp_map[int, std_string].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, std_string].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, std_string].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntStr:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, std_string] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntStr):
            self.map_ptr = (<_MapIntStr> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, std_string]()
            for key, value in new_map.items():


                item = pair[int, std_string](key, std_string(<char *> value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, std_string]()
            for key, value in new_map:


                item = pair[int, std_string](key, std_string(<char *> value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, std_string]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int) and not isinstance(key, long):
            return False

        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntStr mi = _MapIterIntStr()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef std_string v


        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only integer keys are valid.")

        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return str(<char *> deref(self.map_ptr)[k].c_str())
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[int, std_string] item


        item = pair[int, std_string](key, std_string(<char *> value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = key
            self.map_ptr.erase(k)


class MapIntStr(_MapIntStr, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, string>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Str, UInt)
cdef class _MapIterStrUInt(object):
    cdef void init(self, cpp_map[std_string, extra_types.uint] * map_ptr):
        cdef cpp_map[std_string, extra_types.uint].iterator * itn = <cpp_map[std_string, extra_types.uint].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[std_string, extra_types.uint].iterator * ite = <cpp_map[std_string, extra_types.uint].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[std_string, extra_types.uint].iterator inow = deref(self.iter_now)
        cdef cpp_map[std_string, extra_types.uint].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = str(<char *> deref(inow).first.c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapStrUInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[std_string, extra_types.uint] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapStrUInt):
            self.map_ptr = (<_MapStrUInt> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[std_string, extra_types.uint]()
            for key, value in new_map.items():


                item = pair[std_string, extra_types.uint](std_string(<char *> key), <extra_types.uint> long(value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[std_string, extra_types.uint]()
            for key, value in new_map:


                item = pair[std_string, extra_types.uint](std_string(<char *> key), <extra_types.uint> long(value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[std_string, extra_types.uint]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef std_string k

        if not isinstance(key, basestring):
            return False

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterStrUInt mi = _MapIterStrUInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef std_string k
        cdef extra_types.uint v


        if not isinstance(key, basestring):
            raise TypeError("Only string keys are valid.")

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return int(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[std_string, extra_types.uint] item


        item = pair[std_string, extra_types.uint](std_string(<char *> key), <extra_types.uint> long(value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef std_string k

        if key in self:

            k = std_string(<char *> key)
            self.map_ptr.erase(k)


class MapStrUInt(_MapStrUInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <string, unsigned integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(UInt, Str)
cdef class _MapIterUIntStr(object):
    cdef void init(self, cpp_map[extra_types.uint, std_string] * map_ptr):
        cdef cpp_map[extra_types.uint, std_string].iterator * itn = <cpp_map[extra_types.uint, std_string].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[extra_types.uint, std_string].iterator * ite = <cpp_map[extra_types.uint, std_string].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[extra_types.uint, std_string].iterator inow = deref(self.iter_now)
        cdef cpp_map[extra_types.uint, std_string].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapUIntStr:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[extra_types.uint, std_string] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapUIntStr):
            self.map_ptr = (<_MapUIntStr> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[extra_types.uint, std_string]()
            for key, value in new_map.items():


                item = pair[extra_types.uint, std_string](<extra_types.uint> long(key), std_string(<char *> value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[extra_types.uint, std_string]()
            for key, value in new_map:


                item = pair[extra_types.uint, std_string](<extra_types.uint> long(key), std_string(<char *> value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[extra_types.uint, std_string]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef extra_types.uint k

        if not isinstance(key, int) and not isinstance(key, long):
            return False

        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterUIntStr mi = _MapIterUIntStr()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef extra_types.uint k
        cdef std_string v


        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only unsigned integer keys are valid.")

        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return str(<char *> deref(self.map_ptr)[k].c_str())
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[extra_types.uint, std_string] item


        item = pair[extra_types.uint, std_string](<extra_types.uint> long(key), std_string(<char *> value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef extra_types.uint k

        if key in self:

            k = <extra_types.uint> long(key)
            self.map_ptr.erase(k)


class MapUIntStr(_MapUIntStr, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <unsigned integer, string>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Str, Double)
cdef class _MapIterStrDouble(object):
    cdef void init(self, cpp_map[std_string, double] * map_ptr):
        cdef cpp_map[std_string, double].iterator * itn = <cpp_map[std_string, double].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[std_string, double].iterator * ite = <cpp_map[std_string, double].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[std_string, double].iterator inow = deref(self.iter_now)
        cdef cpp_map[std_string, double].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = str(<char *> deref(inow).first.c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapStrDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[std_string, double] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapStrDouble):
            self.map_ptr = (<_MapStrDouble> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[std_string, double]()
            for key, value in new_map.items():


                item = pair[std_string, double](std_string(<char *> key), <double> value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[std_string, double]()
            for key, value in new_map:


                item = pair[std_string, double](std_string(<char *> key), <double> value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[std_string, double]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef std_string k

        if not isinstance(key, basestring):
            return False

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterStrDouble mi = _MapIterStrDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef std_string k
        cdef double v


        if not isinstance(key, basestring):
            raise TypeError("Only string keys are valid.")

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return float(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[std_string, double] item


        item = pair[std_string, double](std_string(<char *> key), <double> value)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef std_string k

        if key in self:

            k = std_string(<char *> key)
            self.map_ptr.erase(k)


class MapStrDouble(_MapStrDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <string, double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(UInt, UInt)
cdef class _MapIterUIntUInt(object):
    cdef void init(self, cpp_map[extra_types.uint, extra_types.uint] * map_ptr):
        cdef cpp_map[extra_types.uint, extra_types.uint].iterator * itn = <cpp_map[extra_types.uint, extra_types.uint].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[extra_types.uint, extra_types.uint].iterator * ite = <cpp_map[extra_types.uint, extra_types.uint].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[extra_types.uint, extra_types.uint].iterator inow = deref(self.iter_now)
        cdef cpp_map[extra_types.uint, extra_types.uint].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapUIntUInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[extra_types.uint, extra_types.uint] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapUIntUInt):
            self.map_ptr = (<_MapUIntUInt> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[extra_types.uint, extra_types.uint]()
            for key, value in new_map.items():


                item = pair[extra_types.uint, extra_types.uint](<extra_types.uint> long(key), <extra_types.uint> long(value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[extra_types.uint, extra_types.uint]()
            for key, value in new_map:


                item = pair[extra_types.uint, extra_types.uint](<extra_types.uint> long(key), <extra_types.uint> long(value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[extra_types.uint, extra_types.uint]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef extra_types.uint k

        if not isinstance(key, int) and not isinstance(key, long):
            return False

        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterUIntUInt mi = _MapIterUIntUInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef extra_types.uint k
        cdef extra_types.uint v


        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only unsigned integer keys are valid.")

        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return int(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[extra_types.uint, extra_types.uint] item


        item = pair[extra_types.uint, extra_types.uint](<extra_types.uint> long(key), <extra_types.uint> long(value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef extra_types.uint k

        if key in self:

            k = <extra_types.uint> long(key)
            self.map_ptr.erase(k)


class MapUIntUInt(_MapUIntUInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <unsigned integer, unsigned integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Int)
cdef class _MapIterIntInt(object):
    cdef void init(self, cpp_map[int, int] * map_ptr):
        cdef cpp_map[int, int].iterator * itn = <cpp_map[int, int].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, int].iterator * ite = <cpp_map[int, int].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, int].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, int].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, int] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntInt):
            self.map_ptr = (<_MapIntInt> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, int]()
            for key, value in new_map.items():


                item = pair[int, int](key, value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, int]()
            for key, value in new_map:


                item = pair[int, int](key, value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, int]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int) and not isinstance(key, long):
            return False

        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntInt mi = _MapIterIntInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef int v


        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only integer keys are valid.")

        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return int(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[int, int] item


        item = pair[int, int](key, value)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = key
            self.map_ptr.erase(k)


class MapIntInt(_MapIntInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Double)
cdef class _MapIterIntDouble(object):
    cdef void init(self, cpp_map[int, double] * map_ptr):
        cdef cpp_map[int, double].iterator * itn = <cpp_map[int, double].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, double].iterator * ite = <cpp_map[int, double].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, double].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, double].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, double] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntDouble):
            self.map_ptr = (<_MapIntDouble> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, double]()
            for key, value in new_map.items():


                item = pair[int, double](key, <double> value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, double]()
            for key, value in new_map:


                item = pair[int, double](key, <double> value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, double]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int) and not isinstance(key, long):
            return False

        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntDouble mi = _MapIterIntDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef double v


        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only integer keys are valid.")

        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return float(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[int, double] item


        item = pair[int, double](key, <double> value)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = key
            self.map_ptr.erase(k)


class MapIntDouble(_MapIntDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Complex)
cdef class _MapIterIntComplex(object):
    cdef void init(self, cpp_map[int, extra_types.complex_t] * map_ptr):
        cdef cpp_map[int, extra_types.complex_t].iterator * itn = <cpp_map[int, extra_types.complex_t].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, extra_types.complex_t].iterator * ite = <cpp_map[int, extra_types.complex_t].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, extra_types.complex_t].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, extra_types.complex_t].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntComplex:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, extra_types.complex_t] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntComplex):
            self.map_ptr = (<_MapIntComplex> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, extra_types.complex_t]()
            for key, value in new_map.items():


                item = pair[int, extra_types.complex_t](key, extra_types.py2c_complex(value))
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, extra_types.complex_t]()
            for key, value in new_map:


                item = pair[int, extra_types.complex_t](key, extra_types.py2c_complex(value))
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, extra_types.complex_t]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int) and not isinstance(key, long):
            return False

        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntComplex mi = _MapIterIntComplex()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef extra_types.complex_t v


        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only integer keys are valid.")

        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return complex(float(deref(self.map_ptr)[k].re), float(deref(self.map_ptr)[k].im))
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[int, extra_types.complex_t] item


        item = pair[int, extra_types.complex_t](key, extra_types.py2c_complex(value))
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = key
            self.map_ptr.erase(k)


class MapIntComplex(_MapIntComplex, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, complex>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(UInt, Double)
cdef class _MapIterUIntDouble(object):
    cdef void init(self, cpp_map[extra_types.uint, double] * map_ptr):
        cdef cpp_map[extra_types.uint, double].iterator * itn = <cpp_map[extra_types.uint, double].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[extra_types.uint, double].iterator * ite = <cpp_map[extra_types.uint, double].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[extra_types.uint, double].iterator inow = deref(self.iter_now)
        cdef cpp_map[extra_types.uint, double].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapUIntDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[extra_types.uint, double] item



        # Decide how to init map, if at all
        if isinstance(new_map, _MapUIntDouble):
            self.map_ptr = (<_MapUIntDouble> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[extra_types.uint, double]()
            for key, value in new_map.items():


                item = pair[extra_types.uint, double](<extra_types.uint> long(key), <double> value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[extra_types.uint, double]()
            for key, value in new_map:


                item = pair[extra_types.uint, double](<extra_types.uint> long(key), <double> value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[extra_types.uint, double]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef extra_types.uint k

        if not isinstance(key, int) and not isinstance(key, long):
            return False

        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterUIntDouble mi = _MapIterUIntDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef extra_types.uint k
        cdef double v


        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only unsigned integer keys are valid.")

        k = <extra_types.uint> long(key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return float(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[extra_types.uint, double] item


        item = pair[extra_types.uint, double](<extra_types.uint> long(key), <double> value)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef extra_types.uint k

        if key in self:

            k = <extra_types.uint> long(key)
            self.map_ptr.erase(k)


class MapUIntDouble(_MapUIntDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <unsigned integer, double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Str, VectorDouble)
cdef class _MapIterStrVectorDouble(object):
    cdef void init(self, cpp_map[std_string, cpp_vector[double]] * map_ptr):
        cdef cpp_map[std_string, cpp_vector[double]].iterator * itn = <cpp_map[std_string, cpp_vector[double]].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[std_string, cpp_vector[double]].iterator * ite = <cpp_map[std_string, cpp_vector[double]].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[std_string, cpp_vector[double]].iterator inow = deref(self.iter_now)
        cdef cpp_map[std_string, cpp_vector[double]].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = str(<char *> deref(inow).first.c_str())
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapStrVectorDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[std_string, cpp_vector[double]] item

        cdef cpp_vector[double] value_proxy
        cdef int i
        cdef int value_size
        cdef double * value_data

        # Decide how to init map, if at all
        if isinstance(new_map, _MapStrVectorDouble):
            self.map_ptr = (<_MapStrVectorDouble> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[std_string, cpp_vector[double]]()
            for key, value in new_map.items():

                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                    value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for i in range(value_size):
                        value_proxy[i] = value_data[i]
                else:
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for i in range(value_size):
                        value_proxy[i] = <double> value[i]
                item = pair[std_string, cpp_vector[double]](std_string(<char *> key), value_proxy)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[std_string, cpp_vector[double]]()
            for key, value in new_map:

                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                    value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for i in range(value_size):
                        value_proxy[i] = value_data[i]
                else:
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for i in range(value_size):
                        value_proxy[i] = <double> value[i]
                item = pair[std_string, cpp_vector[double]](std_string(<char *> key), value_proxy)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[std_string, cpp_vector[double]]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef std_string k

        if not isinstance(key, basestring):
            return False

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterStrVectorDouble mi = _MapIterStrVectorDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef std_string k
        cdef cpp_vector[double] v

        cdef np.ndarray v_proxy
        cdef np.npy_intp v_proxy_shape[1]
        if not isinstance(key, basestring):
            raise TypeError("Only string keys are valid.")

        k = std_string(<char *> key)

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            v_proxy_shape[0] = <np.npy_intp> deref(self.map_ptr)[k].size()
            v_proxy = np.PyArray_SimpleNewFromData(1, v_proxy_shape, np.NPY_FLOAT64, &deref(self.map_ptr)[k][0])
            return v_proxy
        else:
            raise KeyError

    def __setitem__(self, key, value):

        cdef cpp_vector[double] value_proxy
        cdef int i
        cdef int value_size
        cdef double * value_data
        cdef pair[std_string, cpp_vector[double]] item

        value_size = len(value)
        if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
            value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
            value_proxy = cpp_vector[double](<size_t> value_size)
            for i in range(value_size):
                value_proxy[i] = value_data[i]
        else:
            value_proxy = cpp_vector[double](<size_t> value_size)
            for i in range(value_size):
                value_proxy[i] = <double> value[i]
        item = pair[std_string, cpp_vector[double]](std_string(<char *> key), value_proxy)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef std_string k

        if key in self:

            k = std_string(<char *> key)
            self.map_ptr.erase(k)


class MapStrVectorDouble(_MapStrVectorDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <string, vector [ndarray] of double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, VectorDouble)
cdef class _MapIterIntVectorDouble(object):
    cdef void init(self, cpp_map[int, cpp_vector[double]] * map_ptr):
        cdef cpp_map[int, cpp_vector[double]].iterator * itn = <cpp_map[int, cpp_vector[double]].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, cpp_vector[double]].iterator * ite = <cpp_map[int, cpp_vector[double]].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, cpp_vector[double]].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, cpp_vector[double]].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntVectorDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, cpp_vector[double]] item

        cdef cpp_vector[double] value_proxy
        cdef int i
        cdef int value_size
        cdef double * value_data

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntVectorDouble):
            self.map_ptr = (<_MapIntVectorDouble> new_map).map_ptr
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, cpp_vector[double]]()
            for key, value in new_map.items():

                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                    value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for i in range(value_size):
                        value_proxy[i] = value_data[i]
                else:
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for i in range(value_size):
                        value_proxy[i] = <double> value[i]
                item = pair[int, cpp_vector[double]](key, value_proxy)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, cpp_vector[double]]()
            for key, value in new_map:

                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                    value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for i in range(value_size):
                        value_proxy[i] = value_data[i]
                else:
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for i in range(value_size):
                        value_proxy[i] = <double> value[i]
                item = pair[int, cpp_vector[double]](key, value_proxy)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, cpp_vector[double]]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int) and not isinstance(key, long):
            return False

        k = key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntVectorDouble mi = _MapIterIntVectorDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef cpp_vector[double] v

        cdef np.ndarray v_proxy
        cdef np.npy_intp v_proxy_shape[1]
        if not isinstance(key, int) and not isinstance(key, long):
            raise TypeError("Only integer keys are valid.")

        k = key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            v_proxy_shape[0] = <np.npy_intp> deref(self.map_ptr)[k].size()
            v_proxy = np.PyArray_SimpleNewFromData(1, v_proxy_shape, np.NPY_FLOAT64, &deref(self.map_ptr)[k][0])
            return v_proxy
        else:
            raise KeyError

    def __setitem__(self, key, value):

        cdef cpp_vector[double] value_proxy
        cdef int i
        cdef int value_size
        cdef double * value_data
        cdef pair[int, cpp_vector[double]] item

        value_size = len(value)
        if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
            value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
            value_proxy = cpp_vector[double](<size_t> value_size)
            for i in range(value_size):
                value_proxy[i] = value_data[i]
        else:
            value_proxy = cpp_vector[double](<size_t> value_size)
            for i in range(value_size):
                value_proxy[i] = <double> value[i]
        item = pair[int, cpp_vector[double]](key, value_proxy)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = key
            self.map_ptr.erase(k)


class MapIntVectorDouble(_MapIntVectorDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, vector [ndarray] of double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



